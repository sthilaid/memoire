
#+TITLE: Langage spécifique à l'écriture d'agents dans un jeu
#+STYLE: <link rel="stylesheet" type="text/css" href="style.css" />

* Prototypage du langage [2009-01-29 Thu]
  Afin de pouvoir concevoir un DSL, un prototype du jeu space-invaders
  doit être écrit afin de permettre d'observer comment le comportement
  d'agents pourrait être bien représenté sous forme de code abstrait,
  qui serait par la suite traduit en Scheme.

  Par exemple, pour un invader, on pourrait avoir du code ressemblant à:

#+BEGIN_SRC scheme
(define-agent (Invader stimulus)
  (case stimulus
    ((turn)
     (unless (or (exists? player-explosion)
                 (game-paused?))
             (begin (if (not (received-godown-warning?))
                        (move self dx)
                        (move self (- dy)))
                    ;; Wake up the next invader
                    (Invader (next-invader self) 'turn))))
    ((collision self -> wall)
     (for-each send-godown-warning other-invaders)
     (set! dx (- dx))
     (move self dx)
     (move self (- dy)))
    ((collision self <-> player)
     (game-over!))))
#+END_SRC

** Synchronisation des agents via les "fair threads"

   L'utilisation des "[[http://www-sop.inria.fr/members/Manuel.Serrano/publi/sbs-ppdp04.html][fair threads]]" décrits par Manuel Serrano
   permettrait de pouvoir expliciter les contraintes temporelles se
   retrouvant dans le je de space invaders de manière assez élégante,
   par exemple, pour la synchronisation d'affichage entre les
   différentes lignes d'invaders, on pourrait avoir:
     
   |------------+---------------+---------------+---------------|
   | time frame | Botom Inv     | Middle Inv    | Upper Inv     |
   |------------+---------------+---------------+---------------|
   |          1 | move          | [wait mid]    | [wait up]     |
   |            | signal redraw |               |               |
   |            | yield         |               |               |
   |------------+---------------+---------------+---------------|
   |          2 | signal mid    | move          |               |
   |            | wait bot      | signal redraw |               |
   |            |               | yield         |               |
   |------------+---------------+---------------+---------------|
   |          3 |               | signal up     | move          |
   |            |               | wait mid      | signal redraw |
   |            |               |               | yield         |
   |------------+---------------+---------------+---------------|
   |          4 |               |               | signal bottom |
   |            |               |               | wait up       |
   |------------+---------------+---------------+---------------|

   Par contre, il semble y avoir un probleme lorsqu'il n'y a plus
   d'invaders qui existent, pour une rangée donnée (deadlock). Ainsi,
   le comportement des invaders doit être dynamique et modifié en
   cours de route. Ainsi, si tous les invaders de la ligne du bas sont
   tués, le comportement des lignes subsistance devra être modifiée
   à:

   | time frame | Middle Inv    | Upper Inv     |
   |------------+---------------+---------------|
   |          1 | move          |               |
   |            | signal redraw |               |
   |            | yield         |               |
   |------------+---------------+---------------|
   |          2 | signal up     | move          |
   |            | wait mid      | signal redraw |
   |            |               | yield         |
   |------------+---------------+---------------|
   |          3 |               | signal *mid*  |
   |            |               | wait up       |
   |------------+---------------+---------------|


   De plus, l'utilisation d'un style de programmation à la FRP
   (functionnal reactive programming), permettrait de pouvoir aussi
   bien identifier toute les autres contrainte du jeu. Par exemple,
   afin de mettre en pause le jeu, il ne suffit que de creer les
   signaux correspondant.

   Pour inclure de tels comportements, il faudrait ajouter au code
   d'un invader:

#+BEGIN_SRC scheme
(define-agent Invader
  (wait-for
   ((turn (line-id self))
    (move self dx)
    (signal 'moved (find-barrier (invader-row self))))
   ((wall-collision row)
    ;; not very efficient...?
    (if (= row (invader-row self))
        (begin (move self (- dy))
               (invader-invert-speed self)
               ;; need to move back the invader so its no longer in the wall
               (move self dx))))
   ((player-explosion)
    (wait player-explosion-end))
   ((game-paused)
    (wait game-unpaused))
   ;; Must be integrated into collision resolution
   #;
   ((collision self -> wall)
    ;; warn the barriers of a wall collision
    (for-each (lambda (b) (signal 'go-down-warning b)) all-row-barriers))))

(define-class Barrier () (slot: row) (slot: agent-arrived) (slot: warned?))
(define-agent Barrier
  (wait-for
   ((go-down-warning)
    (Barrier-warned?-set! self #t))
   ((moved row)
    (if (= row (Barrier-row self))
        (update! self Barrier agent-arrived (lambda (n) (+ n 1)))
        (begin
         (if (>= (Barrier-agent-arrived self) (row-size (Barrier-row self)))
             (begin
               (Barrier-agent-arrived-set! self 0)
               (if (Barrier-warned? self)
                   (signal `(wall-collision ,(Barrier-row self))))
               (Barrier-warned?-set! self #f)
               ;; Sync with all the sent signals (wait until the next intant
               (yield)
               (signal `(redraw ,(Barrier-row self))))))))))


(define-agent redraw-agent
  (wait-for
   ((redraw last-row)
    (process-user-input)
    (render current-level)
    (yield) ; Beginning of the next instant
    (signal `(turn ,(next-row last-row)))
    (wait 'redraw))
   ((destroyed invader)
    (if (null? (invaders-from-row (invader-row invader)))
        (next-row-set! self (get-next-available-row))))))
#+END_SRC

        Pour cette version, le flot des signaux est plus complexe, si
        l'on suppose qu'il y aie 3 invaders par rangées, on peut
        imaginer le flot comme étant le suivant:

  | Instant | Inv1          | Inv2          | Inv3                  | Barrier-r1       | redraw        |
  |---------+---------------+---------------+-----------------------+------------------+---------------|
  |       1 | /[turn 1]/    | /[turn 1]/    | /[turn 1]/            |                  |               |
  |         | move dx       | move dx       | move dx               |                  |               |
  |         | *sig moved 1* | *sig moved 1* | -> *sig warn-go-down* | /[moved]/        |               |
  |         | (_yield_)     | (_yield_)     | *sig moved 1*         | ar = 0+1         |               |
  |         |               |               | (_yield_)             | /[moved]/        |               |
  |         |               |               |                       | ar = 1+1         |               |
  |         |               |               |                       | /[warn-go-down]/ |               |
  |         |               |               |                       | warned = #t      |               |
  |         |               |               |                       | /[moved]/        |               |
  |         |               |               |                       | ar = 2+1         |               |
  |         |               |               |                       | ar = 0           |               |
  |         | /[wall-coll]/ | /[wall-coll]/ | /[wall-coll]/         | *sig wall-col*   |               |
  |         | move -dy      | move -dy      | move -dy              | warned = #f      |               |
  |         | dx = -dx      | dx = -dx      | dx = -dx              | _yield_          |               |
  |         | move dx       | move dx       | move dx               |                  |               |
  |         | (_yield_)     | (_yield_)     | (_yield_)             |                  |               |
  |---------+---------------+---------------+-----------------------+------------------+---------------|
  |       2 |               |               |                       | *sig redraw*     | /[redraw]/    |
  |         |               |               |                       | (_yield_)        | process-input |
  |         |               |               |                       |                  | render        |
  |         |               |               |                       |                  | *yield*       |
  |---------+---------------+---------------+-----------------------+------------------+---------------|
  |       3 |               |               |                       |                  | sig turn 2    |
  |         |               |               |                       |                  | (_yield_)     |
        
** Synchronisation des agents avec une syntax à la Termite <2009-02-05 Thu 14:15>
   Nous voulons ici essayer de reprenre les exemples de code abstraits
   écrits dans une syntax à la Termite. Puisque Termite utilise du
   pattern matching sur la reception de messages, on peut également
   arriver à écrire facilement les contraintes de synchronisations
   données plus haut dans un tel language.

#+BEGIN_SRC scheme
(define (invader self)
  (lambda ()
    (let loop ()
      (recv
       (('turn ,(line-id self)) ; NOTE: ',' escape not supported by termite
        (begin (move self dx)
               (! (find-barrier (invader-row self))
                  `(moved ,(invader-row self)))))
       (('wall-collision ,(invader-row self))
        (begin (move self (- dy))
               (invader-invert-speed self)
               ;; need to move back the invader so its no longer in the wall
               (move self dx)))
       (('player-explosion)
        (begin (wait player-explosion-end)))
       (('game-paused)
        (begin (wait game-unpaused))))
      (loop))))
  
(define-class Barrier () (slot: row) (slot: agent-arrived) (slot: warned?))
(define (barrier self)
  (lambda ()
    (define (state1)
      (recv
       (('go-down-warning)
        (begin (Barrier-warned?-set! self #t)
               (state1)))
       (('moved ,(Barrier-row self))
        (begin
          (update! self Barrier agent-arrived (lambda (n) (+ n 1)))
          (if (>= (Barrier-agent-arrived self) (row-size (Barrier-row self)))
              (begin
                (Barrier-agent-arrived-set! self 0)
                (if (Barrier-warned? self)
                    (for-each (lambda (i)
                                (! i `(wall-collision ,(Barrier-row self))))
                              all-invaders))
                (Barrier-warned?-set! self #f)
                (state2))
              (state1))))))
    (define (state2)
      (recv
       (('moved ,(Barrier-row self))
        (begin
          (update! self Barrier agent-arrived (lambda (n) (+ n 1)))
          (if (>= (Barrier-agent-arrived self) (row-size (Barrier-row self)))
              (begin
                (Barrier-agent-arrived-set! self 0)
                (! redraw-agent `(redraw ,(Barrier-row self)))
                (state1))
              (state2))))))
    state1))

(define (redraw-agent self)
  (lambda ()
    (let loop ()
     (recv
      (('redraw last-row)
       (process-user-input)
       (render current-level)
       (for-each (lambda (i) (! i `(turn ,(next-row last-row))))
                 all-invaders)
       (loop))))))
#+END_SRC

   Puisqu'il n'existe pas de moyen de synchronisation autre que les
   messages en Termite, il est nécessaire que la barrière soit
   utilisée une 2ième fois lorsque l'on attend que la correction de
   mouvement effectuée soit terminée, après une collision avec un
   mur. Quoi que plus simple syntaxiquement, l'utilisation directe de
   Termite pause quelques problèmes, entre autres:

   - On doit connaître tous les threads à qui l'ont envoi un
     message
   - Problème de fuite de mémoire pour les événements non gérés

   De plus, le pseudo-code utilise aussi des features non-existants de
   Termites, comme les échappement de patterns (effectués avec le
   charactère #\,). De plus, la doc de Termite stipule clairement que
   les effets de bords ne doivent pas être utilisés, ce qui n'est pas
   du tout le cas du code de cet exemple...

** Animations en RFP

   Les animations sembleraient à première vue, faciles à implenter en
   utilisant un modèle de programmation basé sur la programmation
   réactive. Voici comment on pourraît programmer l'animation du début
   de jeu, par exemple.

#+BEGIN_SRC scheme

#+END_SRC
