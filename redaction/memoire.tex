\documentclass[12pt,oneside,letterpaper,francais]{book}

%% \documentclass[12pt]{report}

\usepackage[french, english]{babel}
%\usepackage{isolatin1}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{setspace}
\usepackage{verbatim}

\usepackage{udem_these_fr}

\newcommand{\todo}[1]{[TODO: {\it #1}]}

%\newcommand{\object}[1]{$\#<#1 \ldots>$}
\newcommand{\object}[1]{{\it #1}}

\input{r5rscommands.tex}

\newcommand{\codeinput}[1]{\begin{singlespace}\verbatiminput{#1}\end{singlespace}}
\newcommand{\schemeinput}[1]{\begin{schemecode}\input{#1}\end{schemecode}}

\newcommand{\scheme}[1]{\selectlanguage{english}{\tt #1}\selectlanguage{french}}
\newcommand{\schemeresult}[1]{{\tt #1}}

%% \hyphenation{ex-écu-tion} %% marche pas a cause de l'accent

\title{Development de jeux vidéo en Scheme}

% remplir les champs...
\Auteur{David}{St-Hilaire}

\President{M.}{Mostapha}{Aboulhamid}{Ph.D.}

\Directeur{M.}{Marc}{Feeley}{Ph.D.}

\Membres{1}{M.}{Yann-Gaël}{Guéhéneuc}{Ph.D.}

%pour le doctorat seulement

%examinateur externe
%\Membres{2}{M.}{Membre}{deux}{Ph.D.}
%
%%representant du doyen de la FES
%\Membres{3}{M.}{Membre}{trois}{Ph.D.}

%Pour un doctorat, changer simplement \MSc par \PhD
%titre: 15 mots, max. 175 caractère
\MSc{Dévelopment de jeux vidéo en Scheme}
    {}
    {d'informatique et de recherche op\'{e}rationnelle}
    {informatique}
    {Décembre}
    {2009}

\setstretch{2}
\begin{document}

\setcounter{page}{1}
 \PagesCouverture

\resume


\vspace{2em}

\noindent {\bf Mots clés}: Language de programmation fonctionnels,
Scheme, jeux vidéo, programmation orientée objet.

\abstract

\selectlanguage{english}


\vspace{2em}

\noindent {\bf Keywords}: Functional programming languages, Scheme,
video games, object oriented programming.


\selectlanguage{french}

%% \maketitle
 
\tabledesmatieres

% \listedestableaux

\listedesfigures

% \listedesannexes

\remerciements

blablabla

% \preface
% 
% Préface...

\debutchapitres

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

\section{Contexte}
\subsection{jeu video -> \$\$}
\subsection{prog de jeu complexe: bcp années/hommes de travail}

\section{Motivation}
\subsection{Comment faciliter le dév?}
\subsection{Prog haut niveau vs bas niveau}
\subsection{Scheme}

\section{Problématique}
Ce mémoire de maîtrise vise à répondre à la problématique suivante:

\begin{quote}
  Est-ce possible ou envisageable de concevoir et développer des jeux
  vidéo en Scheme? Quels en sont les avantages et les inconvénients?
\end{quote}


\section{Méthodologie}

\subsection{Dev 1er jeu simple pour determiner les besoins pour Scheme}
\subsection{Augmenter Scheme pour repondre a ces besoins}
\subsection{Ecrire un nouveau jeu utilisant les techniques developpees pour le 1er jeu}

Afin de pouvoir répondre à ces questions, 2 jeux vidéo ont été
developpés en utilisant le langage de programmation Scheme. Le premier
jeux a servi de platforme d'exploration permettant d'élaborer une
méthodologie qui semble efficace pour le développement de jeux. Afin
d'obtenir une telle méthodologie, plusieurs itérations de
développement ont été effectuées, chacune permettant d'explorer de
nouveaux aspects sur la manière de résoudre les problématiques
associées à la création de jeux, comme par exemple comment arriver à
synchroniser des entités dans le jeux ou comment arriver à décrire
efficacement un système de détection et de résolution de collisions.

Suite à l'écriture de ce premier jeu, un autre jeu plus complexe que
le premier a été écrit afin de consolider les méthodologies
précédemment utilisées.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Développement de jeux vidéo}

\section{Contexte (intro?)}

\subsection{Grosseur du marche des JV}
\subsection{Diversite des jeux (genres, plates-formes)}
\subsection{Charactéristiques de jeux modernes}

Les jeux vidéo font parti d'un domaine de l'informatique en pleine
effervescence grâce à une demande constante de nouveaux produits. Ces
produits possèdent plusieurs caractéristiques de qualité auxquelles
les consommateurs s'attendent à obtenir en effectuant l'acquisition
d'un nouveau titre. Ces attentes du consommateur peuvent se traduire
par les besoins suivant:

mettre ici une liste des attentes pour un jeu moderne

\section{Historique}

%% http://en.wikipedia.org/wiki/History_of_video_games

\subsection{préhistoire 1948-1970}
\subsubsection{CRT games}
\subsubsection{Mainframe games}

\subsection{Système arcade 1970-1985}
\subsubsection{Pong}
\subsubsection{Space Invaders}
\subsubsection{Pac-Man}

\subsection{Premières consoles 1972-1984}
\subsubsection{Magnavox Odyssey}
\subsubsection{Atari XX00 et ColecoVision}

\subsection{Ordinateurs personnels 1977-...}
\subsubsection{Évolution parallèle constante}
\subsubsection{Toujours été jusqu'à la venu des console modernes la plateforme offrant les meilleurs performances.}

\subsection{Consoles portables 1980-...}
\subsubsection{GameBoy etc...}

\subsection{Consoles intermédiaires 1984-2006}
\subsubsection{NES, SNES, N64, GameCube}

\subsection{Consoles modernes 2005-...}
\subsubsection{Interfaces plus 'casual' = Wii}
\subsubsection{Consoles très performantes}




\section{Contraintes de programmation}

\subsection{fluidité}

\subsubsection{Taux de rafraîchissement}
\subsubsection{Réponse quasi temps réelle}

\subsection{Modularité}

\subsubsection{Complexité des jeux ... gros logiciels}
\subsubsection{Développement itératif ... plusieurs modifications du système}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Le langage Scheme}

Référence temporaire pour pas faire planter le makefile\cite{SICP}


\section{Programmation fonctionnelle}
\subsection{Fonctions sont des données de premier ordre}
\subsection{Fonctions d'ordres supérieures (avec exemples)}
\subsection{Programmation fonctionnelle pure (exemples)}
\subsection{Effets de bords dans Scheme}


\section{Macros}
\subsection{Introduction}
\subsubsection{Explications sur la simplicite provenant que le code scheme est utilise aussi comme donnee a un programme scheme (macro) comme un ASA.}
\subsubsection{Puissance de calcul lors de l'expansion.}

\subsection{Exemples simples}
\subsection{Problème de l'hygiène des macros}
\subsection{Différentes formes spéciales (define-macro, define-syntax)}

\section{Continuations}
\subsection{Introductions du sujet et explications}
\subsection{Réification de continuations}
\subsection{Exemples d'utilisations}
\subsection{Exemple d'implantations}
\subsection{Forme d'écriture de code en CPS}


\section{Gestion mémoire automatique}
\subsection{Motivation}
\subsection{Historique et survol des techniques}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation orientée objet}

\section{Motivation (ou Objectifs?)}
\subsection{Parler des define-type de Gambit-C et du SRFI-9}
\subsection{Parler de CLOS}

\section{Description du langage}
\subsection{Définition de classes}
\subsubsection{Compatibilité avec les define-type}
\subsubsection{Définitions simples (instance slots et class slots)}
\subsection{Héritages des membres}
\subsubsection{Utilisation de hook sur les slots}
\subsubsection{Constructeurs}


\subsection{Définition de fonctions génériques}
\subsubsection{Dispatch simple}
\subsubsection{Dispatch multiple (avec les problèmes reliés à la résolution de la méthode à choisir)}
\subsubsection{call-next-method}
\subsubsection{Type '*'}


\section{Implantation}
\subsection{Apercu global}
\subsection{Séparation entre le travail fait durant l'expantion macro et l'exécution}
\subsection{Implantation de define-class}
\subsection{Structures de données (descripteurs de classes, format des instances, etc..)}
\subsubsection{Polymorphisme}
\subsubsection{Constructeur et describe comme fonction génériques}

\subsection{Implantation de define-generic}
\subsubsection{Vérifications de types}
\subsubsection{Délégation à l'exécution}

\subsection{Implantation de define-method}
\subsubsection{Stockages des fermetures}


\section{Conclusion}
\subsection{Ouverture sur le fait qu'un meta-protocole serait très intéressant à ajouter, mais à quel prix?}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Système de coroutines}
\section{Motivation}
\subsection{Contrôle fin du comportement de threads}
\subsection{Parler de l'intérêt de Termite}
\subsection{Motivation de l'utilisation de coroutines (contrôle exact sur le flot de contrôle == système toujours dans un état consistant).}

\section{Description du langage}
\subsection{Création de coroutines}
\subsection{Manipulation du flot de contrôle}
\subsubsection{yield}
\subsubsection{super-yield}
\subsubsection{terminate-corout, kill-all!, super-kill-all!}
\subsubsection{sleep-for}
\subsubsection{continue-with}
\subsubsection{spawn-brother, spawn-brother-thunk}
\subsubsection{Composition of coroutines}

\subsection{Système de communication inter coroutines}
\subsubsection{!}
\subsubsection{?}
\subsubsection{??}
\subsubsection{recv, dynamic msg handlers}
\subsubsection{timeouts}
\subsubsection{Messaging lists}

\subsection{Démarrage du système}
\subsubsection{simple-boot}
\subsubsection{boot}
\subsubsection{Systèmes cascadés}


\section{Implantation}

\subsection{Implantation des coroutines}

\subsubsection{Structure de données}
\subsubsection{États d'une coroutines}

\subsection{Scheduler}
\subsubsection{Abstraction du temps via timer}
\subsubsection{États du scheduler}
\subsubsection{Algorithme de scheduling}

\subsection{Système de messagerie}
\subsubsection{Structures de données}
\subsubsection{Envoi de messages}
\subsubsection{Réception de messages}
\subsubsection{Macro recv}


\section{Conclusion}
\subsection{Ouverture sur le profilage des coroutine}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Évaluation et expériences}

\section{Développement de \og Space Invaders \fg}

\subsection{Objectifs}
\subsubsection{Expérimentation avec un jeu très simple}
\subsubsection{Trouver les problèmes fondamentaux pour le développement de jeux}
\subsubsection{Tenter de les résoudre}

\subsection{Version initiale}
\subsubsection{Premier jet dans le but de trouver des problèmes potitiels}
\subsubsection{Comment faire des animations? => CPS}
\subsubsection{Comment concevoir une partie a 2 joueurs? => coroutines}
\subsubsection{Difficulté à décrire la résolution de collision de manière efficace}
\subsubsection{Est-il possible d'écrire le comportement d'une entité de manière indépendante, i.e. que le code soit centralisé dans une même fonction?}

\subsection{Version orientée objet}
\subsubsection{Motivation: Utilisation de fonctions génériques}
\subsubsection{Code Highlight: Résolution de collisions}

\subsection{Version avec système de co-routine}
\subsubsection{Motivation: Intégrer les coroutines a chaque objet de manière à ce que chaque instance soit une entité à part entière qui doit régir son propre comportement.}
\subsubsection{Difficultés: synchronisation des entités}
\subsubsection{Code Highlight: synchronisation des invaders}

\subsection{Conclusion}
\subsubsection{Trouvé plusieurs problèmes et pu résoudres ces derniers}
\subsubsection{ouverture: Essayer ces techniques dans un jeu plus complexe pour voir si elles sont toujours valides}


\section{Développement de \og Lode Runner \fg}
\subsection{Objectifs}
\subsubsection{Jeux plus complexe: plus d'interaction du joueur, intelligence artivicielle, niveaux, schema d'animations plus complexe, etc...}
\subsubsection{Utiliser ce qui semblait de meilleur dans space-invaders de manière a non seulement confirmer la pertinance de ces methodes, mais aussi a potentiellement en developper de nouvelles dû aux nouvelles contraintes de ce jeu.}

\subsection{Synchronisation}
\subsubsection{Utilisation du concept de frame pour faire la synchro. Réduit de beaucoup la complexité.}
\subsubsection{Danger si le framerate varie, la vitesse du jeu varie}

\subsection{Machines à états}
\subsubsection{Utiliation des fonctions génériques}
\subsubsection{Utilisez un LSD pour ca??? Des idées?}

\subsection{Intelligence Artificielle}
\subsubsection{À venir...}

\subsection{Conclusion}
\subsubsection{À venir...}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\chapter{Mesures de performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Travaux reliés}

\section{Comparaison de langages}

\subsection{Lua}
\subsubsection{Differences entre lua et Scheme}
\begin{itemize}
\item Lua est de petite taille en mem
\item ..
\end{itemize}

\subsection{C++}
\subsubsection{Differences entre C++}
\begin{itemize}
\item Gestion memoire manuelle
\item méthode surdéfinies vs fonctions génériques
\end{itemize}


\section{Jeux en Lisp}

\subsection{QuantZ}
\subsubsection{A voir avec Robert}
\subsubsection{FRP}
\subsubsection{Techniques anti-gc}
\subsubsection{Delegation de fermetures}

\subsection{Naughty Dogz}
\subsubsection{GOAL}
%% http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
%% http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\begin{itemize}
\item http://en.wikipedia.org/wiki/Game\_Oriented\_Assembly\_Lisp
\item http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}


L'expérience d'écriture de ces jeux aura permis de faire le point sur
les avantages et les inconvénients de l'utilisation d'un langage tel
que Scheme pour le développement de jeu vidéo.


\begin{itemize}
  \item[+] puissance d'expression / d'abstraction
  \item[+] langage dynamique (développement en-direct, malléabilités)
  \item[+] création de langages spécifiques au domaine

  \item[-] Garbage Collection et sur-allocation
  \item[-] Profilage plus difficile avec des LSD (pour Gambit-C et statprof)
  \item[-] Balance entre abstraction et efficacité
\end{itemize}


%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chapter{Bibliographie}

\setstretch{1}
\bibliographystyle{unsrt} %% or maybe plain or abbrv
\bibliography{memoire}

%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
% TODO: ce compteur doit être ajusté à la main 
% \setcounter{page}{99}

%% \chapter{Code des exemples}

%% \section{Compte de banque}

%% \subsection{Compte de banque en Java}\label{account_java}

%% \subsubsection{Classe Account}
%% \codeinput{bank/Account.java}

%% \subsubsection{Interface RemoteAccount}
%% \codeinput{bank/RemoteAccount.java}

%% \subsubsection{Classe LogRecord}
%% \codeinput{bank/LogRecord.java}

%% \subsubsection{Classe AccountServer}
%% \codeinput{bank/AccountServer.java}

%% \subsubsection{Classe AccountClient}
%% \codeinput{bank/AccountClient.java}

%% %% \subsection{Compte de banque en Termite}\label{account_termite}
%% %% \schemeinput{bank/account.scm}

%% \newpage 

%% \section{Serveur générique: genserver.scm}
%% \schemeinput{genserver.scm}

%% %% \section{Superviseur générique: supervisor.scm}
%% %% 
%% %% \schemeinput{supervisor.scm}

%% \newpage

%% \section{Définition de type}\label{define_termite_type}
%% \schemeinput{deftype.scm}

%% \newpage
%% \chapter{Code des tests de performance}

%% \section{Fibonacci}

%% \subsection{Scheme}\codeinput{bench/fib.scm}
%% \subsection{Erlang}\codeinput{bench/fib.erl}

%% \newpage
%% \section{Takeuchi}

%% \subsection{Scheme}\codeinput{bench/tak.scm}
%% \subsection{Erlang}\codeinput{bench/tak.erl}

%% \newpage
%% \section{Inversion naïve}
%% \subsection{Scheme}\codeinput{bench/nrev.scm}
%% \subsection{Erlang}\codeinput{bench/nrev.erl}

%% \newpage
%% \section{Quick Sort}
%% \subsection{Scheme}\codeinput{bench/qsort.scm}
%% \subsection{Erlang}\codeinput{bench/qsort.erl}


%% \newpage
%% \section{Smith Waterman}
%% \subsection{Scheme}\codeinput{bench/smith.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/smith.erl}

%% \newpage
%% \section{Self}
%% \subsection{Termite}\codeinput{bench/self.scm}
%% \subsection{Gambit}\codeinput{bench/self_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/self.erl}

%% \newpage
%% \section{Spawn}
%% \subsection{Termite}\codeinput{bench/spawn.scm}
%% \subsection{Gambit}\codeinput{bench/spawn_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/spawn.erl}

%% \newpage
%% \section{Ring}

%% \subsection{Termite}\codeinput{bench/ring.scm}
%% \newpage
%% \subsection{Gambit}\codeinput{bench/ring_gambit.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/ring.erl}

%% \newpage
%% \section{Ping-pong}

%% \subsection{Termite}\codeinput{bench/pingpong.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/pingpong.erl}


%% \newpage
%% \section{``Migration''}

%% \subsection{Termite}\codeinput{bench/migrate.scm}

\end{document}
