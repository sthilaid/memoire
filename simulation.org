
#+TITLE: Utilisation de systèmes de simulations

* Idée

  L'idée d'utiliser des système de simulation afin de contrôler le
  flot d'exécution m'est venue suite au cours de simulation
  stochastiques que j'ai suivi. En effet, en décrivant des simulations
  sous formes d'événements discrets ou de fils d'éxécution (threads),
  on pouvait facilement écrire le comportement de chaque individu, et
  ce de manière modulaire.

* Simulation à événements discrets

  La première forme de simulation utilisée fut une simulation à
  événements discrets. Le résultat de son utilisation est moyen,
  principalement dû au fait que les objets possèdent la pluspart du
  temps des comportements + ou - infinis, ou dont la durée n'est pas
  pré-déterminée. Par exemple, 

#+BEGIN_SRC scheme
;; Event that moves a mothership and handles its collisions.
(define (create-mothership-event level)
  (define mothership-event
    (synchronized-event-thunk level
      (let ((mothership (level-mothership level)))
        (if mothership
            (let ((collision-occured? (move-object! level mothership)))
              (if (or (not collision-occured?)
                      (is-explosion? collision-occured?)
                      (eq? collision-occured? 'message))
                  (in mothership-update-interval mothership-event)))))))
  mothership-event) 
#+END_SRC

  où l'on constate que l'évènement principal contrôlant les entitées
  de type "mothership" doit se re-schéduler plus tard dans le temps,
  et vérifier que le vaiseau "mothership" est toujours en un seul
  morceau avant de pouvoir continuer. Cela résulte donc en l'écriture
  de code pouvant facilement mener à des bugs (par exemple par l'oubli
  de la vérification de l'existance du "mothership" lors de
  l'exécution du prochain évenement.
  
  Par contre, cette approche semblait fonctionner assez bien pour la
  création d'animation, où justement la durée est décidée à l'avance.

#+BEGIN_SRC scheme
(define (create-text-flash-animation-event level msg-obj duration continuation)
  (define (flash-ev dt)
    (lambda ()
      (if (< dt duration)
          (begin (cycle-msg-state! msg-obj)
                 (in animation-delay (flash-ev (+ dt animation-delay))))
          (begin
            (game-object-color-set! msg-obj original-color)
            (in 0 continuation)))))
  (flash-ev 0)) 
#+END_SRC

  Comme l'illustre cet exemple d'animation de scintillement de text,
  on peut naturellement programmer une suite d'animations en utilisant
  des événements continuations. Par contre, la manipulation et la
  création de nouvelles continuations peut devienir fastidieuse.

* Simulations par fils d'exécutions

  Une approche qui nous a donc semblée plus naturelle pour la suite
  fut donc de transformer le système de simulation à événements
  discrets pour créer une simulations par "threads". Par contre, un
  des désavantages majeurs de la programmation parallèle est la
  difficulté, généralement reliée aux conditions de courses et aux
  problèmes de synchronisations.

  Ainsi, nous avons décider de créer un système de "threads"
  co-opératifs, changeant de context avec des yields explicites ou
  avec des sleeps. Ainsi, le comportement des objets était beaucoup
  plus compact et facile à écrire et comprendre. De plus, l'écriture
  de quelques macros ont permis de pouvoir composer facilement
  plusieurs animations.

#+BEGIN_SRC scheme
(define (create-mothership level)
  (synchronized-thunk level
    (let loop ((mothership (level-mothership level)))
      (if mothership
          (let ((collision-occured? (move-object! level mothership)))
            (if (or (not collision-occured?)
                    (explosion? collision-occured?)
                    (eq? collision-occured? 'message))
                (begin (sleep-for mothership-update-interval)
                       (loop (level-mothership level)))))))))
#+END_SRC

  Par exemple, on voit maintenant que le comportement d'un
  "mothership" se retrouve encapsulé dans une boucle infinie qui
  applique sont comportement à chaque itération.

  Similairement, des simples macros permettent de pouvoir composer de
  manière très élégante plusieurs animations. Par exemple, pour créer
  l'animation du début de jeu, il n'a suffit que d'utiliser le code
  suivant:

#+BEGIN_SRC scheme
(define (create-animation-A level)
  (lambda ()
    ;; messages declaration
    (let* ((play   ...) (space  ...) (score  ...)
           (mother ...) (hard   ...) (medium ...) (easy   ...)
           (anim-messages
            (list play space score mother hard medium easy)))
      (for-each (lambda (m) (level-add-object! level m)) anim-messages )
      (continue-with-thunk!
       (compose-thunks
        (animate-message play "PLAY")
        (animate-message space "SPACE   INVADERS")
        (create-animate-score-adv-table level))))))
#+END_SRC

  qui affiche de maniere successive du text et affiche par la suite la
  liste des points que valent chaque type de vaisseaux.
