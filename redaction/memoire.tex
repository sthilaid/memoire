\documentclass[12pt,oneside,letterpaper,francais]{book}

%% \documentclass[12pt]{report}

\usepackage[french, english]{babel}
%\usepackage{isolatin1}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{setspace}
\usepackage{verbatim}

\usepackage{udem_these_fr}

\newcommand{\todo}[1]{[TODO: {\it #1}]}

%\newcommand{\object}[1]{$\#<#1 \ldots>$}
\newcommand{\object}[1]{{\it #1}}

\newcommand{\ie}{{\textit{i.e.}}}

\input{r5rscommands.tex}

\newcommand{\codeinput}[1]{\begin{singlespace}\verbatiminput{#1}\end{singlespace}}
\newcommand{\schemeinput}[1]{\begin{schemecode}\input{#1}\end{schemecode}}

\newcommand{\scheme}[1]{\selectlanguage{english}{\tt #1}\selectlanguage{french}}
\newcommand{\schemeresult}[1]{{\it #1}}

%% \hyphenation{ex-écu-tion} %% marche pas a cause de l'accent

\title{Développement de jeux vidéo en Scheme}

% remplir les champs...
\Auteur{David}{St-Hilaire}

\President{M.}{Mostapha}{Aboulhamid}{Ph.D.}

\Directeur{M.}{Marc}{Feeley}{Ph.D.}

\Membres{1}{M.}{Yann-Gaël}{Guéhéneuc}{Ph.D.}

%pour le doctorat seulement

%examinateur externe
%\Membres{2}{M.}{Membre}{deux}{Ph.D.}
%
%%representant du doyen de la FES
%\Membres{3}{M.}{Membre}{trois}{Ph.D.}

%Pour un doctorat, changer simplement \MSc par \PhD
%titre: 15 mots, max. 175 caractère
\MSc{Dévelopment de jeux vidéo en Scheme}
    {}
    {d'informatique et de recherche op\'{e}rationnelle}
    {informatique}
    {Décembre}
    {2009}

\setstretch{2}
\begin{document}

\setcounter{page}{1}
 \PagesCouverture

\resume


\vspace{2em}

\noindent {\bf Mots clés}: Language de programmation fonctionnels,
Scheme, jeux vidéo, programmation orientée objet.

\abstract

\selectlanguage{english}


\vspace{2em}

\noindent {\bf Keywords}: Functional programming languages, Scheme,
video games, object oriented programming.


\selectlanguage{french}

%% \maketitle
 
\tabledesmatieres

% \listedestableaux

\listedesfigures

% \listedesannexes

\remerciements

blablabla

% \preface
% 
% Préface...

\debutchapitres

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{Chap:Intro}

L'industrie du jeu vidéo devient de plus en plus importante dans le
domaine de l'informatique. Cette croissance est bien reflétée par
l'augmentation de 28\% des revenus provenant de la vente de jeux vidéo
aux États-Unis durant l'année 2007~\cite{NPD_Games_2007}. La place
occupée par l'industrie du jeu vidéo durant cette même année s'estime
à 76\% du marché de tous les logiciels vendus~\cite{NPD_Soft_2008}. 

L'engouement du marché du jeu vidéo incite les compagnies oeuvrant
dans le domaine à repousser les limites de l'état de l'art du
développement de jeux. La compétition est féroce et donc beaucoup
d'efforts doivent être investis dans la création d'un jeu afin qu'il
se démarque de la masse et devienne un nouveau \og Blockbuster Hit
\fg. Le président de la compagnie Française UbiSoft estime que le coût
moyen de développement d'un jeu sur une console moderne se situe entre
20 et 30 millions de dollars~\cite{cbc_ubisoft}. Si l'on estime le
salaire moyen d'un artiste ou d'un développeur de jeu vidéo à 60
000\$ par année, cela reviendrait à un travail d'environ 300 à 500
hommes par année.

Puisque la création d'un jeu vidéo peu nécessiter autant d'efforts, il
semble très intéressant de vouloir tenter de faciliter le
développement de ces derniers. Avec autant d'efforts mis en place,
même une petite amélioration sur le cycle de développement peu
engendrer une diminution énorme des coûts de production et aussi
améliorer la qualité des environnements utilisés par les développeurs.

Jusqu'à ce jour, la grande majorité des jeux vidéo sont écrits à
l'aide de langages de relativement bas niveau, par exemple en C, C++
ou encore C\#~\cite{CSHARP_SPEC}. Ces langages sont généralement
utilisés parce qu'ils sont déjà bien établis et que la main d'oeuvre
est facilement accessible.

\todo{expliquer haut niveau / bas niveau}

Les langages de haut niveau sont généralement caractérisés par le fait
qu'ils font une bonne abstraction du système utilisé et permettent
d'utiliser celles-ci de manière naturelle. Elles facilitent donc le
travail de programmation. Le coût de ces abstractions se répercute
généralement en un coût de performance du programme. Dans le passé, la
performance était critique dans les jeux vidéo, mais les consoles
modernes sont devenues plus performantes que la plupart des
ordinateurs personnels. Actuellement la performance n'est donc plus
aussi important. Aussi, les améliorations du domaine de la compilation
de langages de haut niveau font en sorte que les performances de ces
systèmes sont comparables à l'utilisation de langages de plus bas
niveau.

Ainsi, l'utilisation de langages de plus haut niveau pourrait
potentiellement améliorer les délais occasionnés par les cycles de
développement des jeux en permettant aux programmeurs et designers de
s'exprimer plus facilement. Le langage de programmation
Scheme~\cite{R5RS} semble être un bon candidat en tant que langage de
haut niveau. En effet, le langage Scheme offre les fonctionnalités de
haut niveau suivantes:

\todo{Gardes les bullets ou changer en texte??}

\begin{itemize}
\item Typage dynamique
\item Fonctions de premier ordre
\item Système de macros évolué
\item Accès direct aux continuations du calcul
\item Un système de déboggage très efficace
\end{itemize}

Ces particularités du langage Scheme sont discutées plus en détail
dans le chapitre \ref{Chap:Scheme}.

Le système Gambit-C, l'une des implantations de Scheme les plus
performantes~\cite{GAMBIT_BENCHMARKS} sera utilisée pour effectuer les
expériences pratiques. Ce système comporte de nombreuses extensions
pouvant être très utiles au développement de jeux vidéo. On y retrouve
entre autres des tables de hachages ou des \textit{threads} (processus
légers).

Il semble donc qu'une utilisation judicieuse de ce système pourrait
faire bénéficier des projets aussi complexes que le sont les
productions de jeux vidéo.

\section{Problématique}
Ce mémoire de maîtrise vise à répondre à la problématique suivante:

\todo{Inserer dans un texte ou garder en quotation?}

\begin{quote}
  Quelles sont les forces et les faiblesses du langages de
  programmation Scheme pour le développement de jeux vidéo.
\end{quote}

\section{Méthodologie}

%% Afin de pouvoir répondre à la problématique posée, nous avons utilisé
%% l'approche

%% \begin{itemize}
%% \item Dev 1er jeu simple pour determiner les besoins pour Scheme
%% \item Augmenter Scheme pour repondre a ces besoins
%% \item Ecrire un nouveau jeu utilisant les techniques developpees pour le 1er jeu
%% \end{itemize}

Afin de pouvoir répondre à la problématique posée, nous avons étudié
les caractéristiques de Scheme et du compilateur Gambit-C, ainsi que
les besoins au niveau du développement de jeux vidéo. Concurremment, 2
jeux ont été développés pour raffiner nos approches et les évaluer
dans un contexte réel.

Le premier jeux a servi de plate-forme d'exploration permettant
d'élaborer une méthodologie qui semble efficace pour le développement
de jeux. Afin d'obtenir une telle méthodologie, plusieurs itérations
de développement ont été effectuées, chacune permettant d'explorer de
nouveaux aspects sur la manière de résoudre les problématiques
associées à la création de jeux, par exemple comment arriver à
synchroniser des entités dans le jeux ou comment arriver à décrire
efficacement un système de détection et de résolution de collisions.

Suite à l'écriture de ce jeu, un deuxième jeu, plus complexe, a été
développé afin de consolider les techniques précédemment utilisées et
étendre ces techniques dans le cadre de ce nouveau jeu comportant de
nouveaux défi, comme l'implantation d'une intelligence artificielle.



\section{Aperçu du mémoire}
Ce mémoire est composé de quatre parties. La première partie est une
introduction qui traite de programmation fonctionnelle, du langage de
programmation Scheme et des outils de développement disponibles, en
particulier le compilateur Gambit-C. Ce chapitre donne un aperçu
général de ces langages et permet de saisir les concepts fondamentaux
du langage Scheme. Une présentation de l'industrie des jeux vidéo et
des défis découlant du développement suit ce chapitre.

La deuxième partie du mémoire porte sur des extensions faites au
langage Scheme qui ont été utilisées dans le but d'améliorer le
développement de jeux vidéo. On y présente la programmation orientée
objet et un système d'objets conçu pour répondre aux besoins de la
programmation de jeux vidéo. Un système de coroutines conçu dans les
mêmes optiques est également présenté.

La troisième partie du mémoire porte sur l'expérience acquise par
l'auteur en effectuant l'écriture de 2 jeux vidéo simples, mais
possédant suffisamment de complexité pour exposer les problèmes
associés à la création de jeux vidéo et comment tirer profit du
langage de programmation Scheme pour résoudre ces problèmes. Une
présentation des travaux reliés aux résultats présentés suit ce
dernier chapitre. On y parle de l'utilisation d'autres langages
pour le développement de jeux vidéo et cite des exemple d'utilisation
du langage Scheme dans des jeux vidéo commerciaux et de l'expérience
tirée de cette utilisation par les développeurs.

Finalement, une conclusion apporte la lumière sur la problématique
exposée dans ce mémoire. Le point sur l'expérience acquise pour le
développement de jeux vidéo en Scheme y est fait et les avantages et
inconvénients ou problèmes obtenus seront exposés.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Développement de jeux vidéo}
\label{Chap:JV}

Les jeux vidéo font parti d'un domaine de l'informatique en pleine
effervescence grâce à une demande constante de nouveaux
produits. 

L'histoire des jeux vidéo possède déjà un demi-siècle de créations de
tout genres qui ont contribué à générer l'engouement actuel pour ces
derniers. Une brève historique des jeux vidéo sera présentée dans ce
chapitre afin de pouvoir illustrer l'évolution des jeux vidéo et de
permettre de situer dans le temps où se situent les jeux développés
pour ce mémoire.

L'industrie du jeu vidéo actuelle est le moteur qui permet aux jeux
vidéo de continuer à évoluer et se raffiner. Un aperçu global de
l'industrie du jeu vidéo est ainsi donné dans ce chapitre.

Finalement, les besoins aux niveau de la programmation exprimés par
les jeux vidéo sont énoncées afin de permettre de pouvoir cerner les
composantes importantes pour un langage de programmation utilisé pour
le développement de jeux.


\section{Historique}

L'histoire des jeux vidéo s'étale sur environ un demi-siècle et
renferme une mine d'informations importante qui permet d'exposer la
manière avec laquelle les jeux vidéo évoluent. Seulement un bref
résumé de cette histoire est présenté afin de donner présenter les
grandes ligne de l'évolution des jeux au cours des cinquante dernières
années~\cite{VIDEOGAMES_history}~\cite{HISCORE}.

\todo{Mettre des references partout, ou bien ne pas en mettre du tout?}

%% http://en.wikipedia.org/wiki/History_of_video_games

\subsection{Préhistoire 1948-1970}
Les jeux vidéo ont fait leurs apparitions avant même les premiers
ordinateurs. En effet, le \textit{Cathode Ray Amusement
  Device}~\cite{CRTAD} fit sont apparition en 1948. Il s'agissait d'un
jeu rendu sur un tube cathodique simulant le lancement de missiles sur
des cibles. 

Vers le début des années 1960, quelques jeux ont fait leurs apparition
sur les premiers ordinateurs universitaires, notamment au \textit{MIT}
et à l'université de Cambridge. On y retrouve notamment le jeu
\textit{Spacewar!} qui est l'un des premier jeu multi-joueurs mettant
les joueurs en adversité dans leurs vaisseaux spatiaux pouvant lancer
des missiles. 

Avec un intérêt stimulé envers le potentiel de divertissement
qu'offrait les jeux vidéo de l'époque, le développement de machines
dédiées aux jeux vidéo a ainsi débuté.

\subsection{Système arcade 1970-1985}
En 1971, des étudiants de l'université de Standford ont porté le jeu
\textit{Spacewar!} sur une machine fonctionnant avec de l'argent (de
la monnaie). Ce fut la première machine arcade.

Par la suite, le développement de telles machines est devenu très
répandu. En 1972, la compagnie \textit{Atari} fut fondé et démarra
l'industrie du jeu vidéo sur arcade avec le jeu \textit{Pong}, un jeu
de tennis de table permettant à un joueur de jouer contre une
intelligence artificielle ou bien de se mesurer à un autre joueur.

Ce fut alors l'âge d'or des machines d'arcade où l'on a créé beaucoup
de jeu au contenu diversifié. Parmi ceux-ci, \textit{Space
  Invaders}(1978) et \textit{PacMan}(1980) furent extrêmement
populaires. 

Malgré que les jeux d'arcades étaient très simple, ils étaient
beaucoup appréciés pour l'amusement qu'ils procuraient aux joueurs qui
tentaient toujours de se surpasser.

\todo{Marc, quelles genre de machines est-ce que c'etait? Processeur
  8bit?}

On retrouve toujours des salles d'arcades de nos jours, mais celles-ci
sont devenues beaucoup moins populaire que les consoles de jeu qui se
retrouvent dans nos salons.

\subsection{Premières consoles 1972-1984}

La première console de jeu vidéo, le \textit{Magnavox Odyssey} fut son
apparition en Amérique du Nord en 1972. Cette console permettant aux
joueurs de jouer sur le télévision assis confortablement dans leurs
salon. Elle permettait aussi d'insérer des jeux sous forme de
cartouches. Un total de 28 jeux ont été disponible pour cette console,
qui malgré l'absence de périphérique audio, a été vendu pour environ
300 000 exemplaires.

Plusieurs autres consoles ont par la suite été créées. Allant d'une
version console de \textit{Pong} jusqu'à des consoles plus puissante
comme le \textit{ColecoVision} qui démarrèrent l'ère des consoles
8-bit. La vocation principale de ces consoles n'étaient pas d'innover
dans le développement de jeu, mais plutôt de porter les jeux
d'arcades populaires sur leurs consoles.

\subsection{Ordinateurs personnels 1977-...}
Les premiers ordinateurs personnels furent leurs apparition vers la
fin des années 1970, dont notamment l'ordinateur \textit{Apple II}
produit par \textit{Apple Inc.}. Ces ordinateurs personnels offraient
plus de puissance que les consoles de l'époque et offraient la
possibilité aux amateurs de créer leurs propres jeux.

Les jeux d'ordinateurs étaient distribués sur beaucoup de média
différents. La distribution allait de cassettes, aux disquette, en
passant bien sur par des échanges postaux de code sources.

En 1982, le jeux \textit{Lode Runner} fut développé pour les
ordinateurs \textit{Apple II}. Ce jeux d'action fut l'un des premiers
jeu comprenant un éditeur de niveaux.

Aussi, le jeu \textit{Rogue} fut créé durant les années 1980, pour les
premiers système Unix. Il fut le pionnier d'un nouveau genre de jeu
(surnommé \textit{Roguelike}) qui différait beaucoup des jeux
d'actions retrouvés en sales d'arcades ou sur consoles. Il présentait
une interface visuelle très minimaliste. La narration, qui était un
point central du jeu, était effectuée de manière textuelle et le
joueur interagissait aussi de manière textuelle avec le jeu.

Les jeux d'ordinateurs ont longtemps été supérieurs aux jeux de
consoles puisque les ordinateurs étaient toujours à la fine pointe de
la technologie, et les consoles traînaient un peu derrière en terme de
technologies. Ainsi, on retrouvait des jeux ayant de meilleurs
graphique ou utilisant des périphériques plus variés sur les
ordinateurs personnels. Ainsi, les jeux d'ordinateurs existait dans un
monde parallèle à celui des consoles, ne se livrant pas de compétition
réelle.

Par contre, avec l'avènement des consoles modernes qui sont plus
performantes que la plupart des ordinateurs personnels, cet énoncé
n'est plus valide. Ainsi, les jeux sur des consoles actuelles
rivalisent avec les jeux d'ordinateurs.


\subsection{Consoles portables 1980-...}
Les toutes premières consoles portables furent développées par la
compagnie \textit{Mattel Toys} qui créèrent les jeux \textit{Auto
  Race} et \textit{Football} qui étaient distribués sur des consoles
de la taille d'une calculatrice, ne nécessitant pas de téléviseurs
externes à la console et étaient dédiées à un seul jeu. Ces consoles
furent un succès rapportant plusieurs centaines de millions de dollars
à leurs créateurs.

Par la suite, les grandes compagnie du jeu vidéo comme
\textit{Nintendo} et \textit{Bandai} se sont intéressée à de telles
consoles et en produisirent plusieurs exemplaires des consoles
\textit{Game \& Watch} qui contenaient des succès d'arcades tel
\textit{Mario's Cement Factory} et \textit{Donkey Kong Jr.}.

Le même concepteur de ces consoles à par la suite fusionner ces
dernière avec le contrôleur du \textit{Nintendo Entertainement
  System}(NES) pour obtenir la première console à grand succès: le
\textit{GameBoy}. Cette console qui offrait un écran monochrome fut
vendue à 118 million d'exemplaire dans le monde. Le jeu le plus vendu
sur cette console fut nulle autre que le jeu \textit{Tetris} qui a
vendu environ 33 millions d'unités.

Les consoles ont continuées d'évoluer grandement et elles sont
actuellement équivalente aux consoles de une ou deux génération
précédente. Par exemple, le Sony \textit{PlayStation Portable}
rivalise en matière de puissance de matériel à la précédente console
de Sony, le \textit{PlayStation 2}. On peut donc développer des jeux
très complexe sur ces consoles portables, mais ils ne peuvent toujours
pas rivaliser avec les jeux sur consoles ou d'ordinateurs.

\subsection{Consoles intermédiaires 1984-2006}
Au début des années 1980, plusieurs consoles étaient disponibles sur
le marché, mais une saturation de mauvais jeux et des problèmes de
mauvaises gestions ont fait en sorte que l'industrie du jeux vidéo à
connu une grande dépression vers en 1983. Par exemple, il y a eu une
plus grande production d'unités du jeu \textit{PacMan} qu'il n'y avait
eu de console d'Atari vendues.

Cette dépression a pris subitement fin avec la sortie de la console
produite par \textit{Nintendo}, le \textit{Nintendo Entertainement
  System} (NES) qui connu un succès fulgurant en vendant 62 millions
de consoles dans le monde. La grande qualité des jeux produits ont
certainement favorisé l'adoption de cette nouvelle console. On
retrouve entre autre des jeux de tout genre comme le jeu de
plate-forme \textit{Super Mario Bros}, le jeux d'aventure \textit{The
  Legend of Zelda} et le jeu d'action aventure \textit{Metroid}.

Par la suite, la compagnie SEGA sortit un compétiteur sérieux au NES,
le \textit{Master System}, qui rivalisait en terme de puissance
matérielle et de prix. Depuis ce temps, c'est la guerre des consoles
qui se livre où lorsqu'une compagnie développe un nouveau jeu ou une
nouvelle console, les compétiteurs ne tardent pas à produire un jeu ou
console équivalent pour les utilisateurs de leurs produits.

\subsection{Consoles modernes 2005-...}
Les consoles modernes sont généralement conçues avec du matériel à la
fine pointe de la technologie et tentent de séduire un certain public
cible.

Au moment de l'écriture de ce mémoire, on retrouve la console
\textit{Wii} de Nintendo conçu pour un publique constitué de joueurs
occasionnels grâce au contrôleur révolutionnaire de cette console
permettant de jouer en effectuant des mouvement plus naturels.

D'un autre côté compétionnent le \textit{PlayStation 3} de Sony et le
\textit{XBox 360} de Microsoft qui cherchent à convaincre les joueurs
plus sérieux d'utiliser leur système en offrant des consoles à la fine
pointe de la technologie et à prix très raisonnable en comparaison aux
prix des ordinateurs de jeu équivalents. 



\section{Industrie du jeu vidéo}
Comme mentionné dans le chapitre \ref{Chap:Intro}, l'industrie du jeu
vidéo est très importante et génère des milliards de dollars de
revenus par années. Ce profit provient d'une grande diversité de
joueurs, allant de jeunes enfants jusqu'à leurs grands-parents avec
une population féminine presque aussi importante que celle
masculine. Il en résulte donc qu'une grande diversité de jeux et de
plates-formes de jeux se retrouvent sur le marché.

Ces produits possèdent plusieurs caractéristiques de qualité communes
auxquelles les consommateurs s'attendent à obtenir en effectuant
l'acquisition d'un nouveau titre. Ces attentes du consommateur peuvent
se traduire essentiellement par les besoins suivant:

\begin{itemize}
\item Exposer un \textit{gameplay} amusant
\item Offrir de beaux rendus graphiques et un affichage visuel
  agréable
\item Avoir une composante multi-joueurs
\item Optionnellement contenir une narration 
\end{itemize}

Ces besoins semblent simple, \textit{a priori}, mais impliquent
beaucoup de travail et imposent des contraintes sévères au
développeurs de jeux vidéo.

Afin qu'un jeu puisse offrir un \textit{gameplay} intéressant au
joueurs, une étroite collaboration entre les développeurs et les
designers doit être établie. Cela implique aussi de faire beaucoup
d'essaies de possibilités en testant sur des prototypes et en
effectuant de nombreux cycles de développement du jeu.

En ce qui concerne le rendu graphique du jeu, en plus des designers du
jeu, c'est aussi avec les artistes que les développeurs doivent
s'accorder dans le but de concevoir un moteur de rendu répondant bien
aux besoins de leurs créations et, leurs créations doivent être bien
sûr faites en respectant les contraintes imposées par le matériel ou
sera déployé le produit. Ainsi, le moteur de rendu doit pouvoir être
facilement extensible afin de pouvoir accommoder facilement les
nouvelles idées et les nouveaux concepts à intégrer.

Une composante multi-joueur, tout dépendant si elle implique des
parties faites sur le réseau ou non, pourrait nécessiter une grande
rigeur de programmation afin d'assurer une stabilité de connections et
empêcher les joueurs de tricher. Ces sujets ne sont pas discuter dans
ce mémoire.

La diversité des jeux développés a mené à une caractérisation des jeux
et une classification de ceux-ci. Les principaux genres de jeux sont:

\begin{itemize}
\item Action: Jeux rapides demandant souvent de l'habileté de la part
  des joueurs.
\item Stratégie: Jeux à rythme plus lent, exigeant une réflection plus
  profonde de la part des joueurs.
\item Jeux de Rôles: Jeu où la narration de l'histoire occupe une
  place importante et où les personnages de l'histoire subissent une
  évolution graduelle en fonction du temps.
\item Simulation: Jeux qui tentent de représenter fidèlement des
  phénomène réels comme la conduite automobile, des sports, etc...
\item \textit{Casual}: Jeux simples visant à être utilisés par des
  joueurs occasionnels. Le jeu \textit{Tetris} est considéré comme
  appartenant à ce genre.
\end{itemize}

Il existe d'innombrables autres genres et genres hybrides de ces
catégories, mais celles-ci donnent une idée de la diversité du contenu
des jeux vidéo produits.

\todo{Ajouter du texte liant a la prochaine section?}



\section{Contraintes de programmation}

Le développement de jeu vidéo implique une programmation sous des
contraints sévères afin que le jeu respecte les normes de l'industrie
et respecte les attentes des joueurs.

Une contrainte importante portant sur les jeux vidéo est relié à
l'efficacité algorithmique résultant du programme développé. En effet,
la fluidité d'un jeu est critique face à l'immersion du joueur dans
l'univers créé par le jeu. Les jeux doivent donc être des programmes
très efficaces de manière à inviter le joueur à entrer le plus
possible dans la narration du jeu.

Une autre contrainte importante relié au développement de jeu est la
modularité du code produit. En effet, afin que les efforts placés dans
la production d'un jeu vidéo puissent être réutilisés dans les
productions subséquentes, des abstractions doivent être bien faites
afin de faciliter la réutilisation de ces dernières.

\todo{Autres choses?}

\subsection{Fluidité}


\subsubsection{Taux de rafraîchissement}
Une contrainte très importante dans le développement d'un jeu vidéo
est la fluidité de celui-ci. Lorsqu'un film est projeté sur un écran
de cinéma le taux de rafraîchissement de l'image est d'environ 30
trames par secondes. Par contre, les images captées par les caméra
contiennent du \og flou de mouvement \fg, effet créé par le mouvement
s'étant produit durant la capture de cette image. Ce flou permet à
notre cerveau d'estimer ou de faire l'extrapolation du mouvement dans
une trame et donc de croire l'illusion créée par la projection des
images.

Par contre, dans un jeu vidéo, les images rendues sur l'écran sont
parfaitement nettes et ne contiennent donc pas ce flou de mouvement,
ce qui vient réduire la crédibilité de l'illusion faite par la
succession des images à l'écran. Il faut donc augmenter le taux de
rafraîchissement à environ 60 trames par secondes pour obtenir le
niveau de crédibilité du projection cinématographique.

\todo{references necessaire?}

Ceci étant dit, un taux de rafraîchissement de 60 trames par secondes
n'est pas nécessaire pour tout les jeux. Cela varie grandement avec la
nature des jeux. Par exemple, un jeu de stratégie où les joueurs
jouent à tours de rôles possède peu d'animations et donc pourrait très
probablement être satisfaisant avec un taux de rafraîchissement de 30
trames par secondes.

Aussi, il est possible que les designers du jeu acceptent de réduire
volontairement le taux de rafraîchissement afin d'avoir plus de temps
pour rendre une image. Un jeu possédant un taux de rafraîchissement de
60 trames par secondes implique que les images sont rafraîchies tous
les 16 millisecondes, ce qui ne laisse pas beaucoup de temps pour
effectuer le calcul du moteur du jeu en plus du rendu de
l'image. Heureusement, les cartes vidéo modernes sont capables de
faire une bonne partie du rendu laissant ainsi le ou les processeurs
principaux libres pour exécuter le moteur du jeu.

Il n'en demeure pas moins que toute la logique du jeu doit être aussi
optimisée que possible afin que le processus de rendu des trames soit
transparent au joueur.

\subsubsection{Réponse quasi temps réelle}

Une autre implication de la fluidité requise par un jeu vidéo est le
délais de réponse face aux entrées du joueur. Ce délais aussi doit
être aussi faible que possible pour donner l'impression que le
personnage dans le jeu ne soit qu'une extension de la volonté du
joueur. Ainsi le traitement des entrées du joueurs se doit aussi
d'être très efficace afin de ne pas encombré le moteur du jeu qui n'a
déjà pas beaucoup de temps pour effectuer son travail.

\subsection{Modularité}

En plus de devoir être efficacement implanté, un jeu vidéo moderne se
doit d'être aussi modulaire que possible. Pour y arriver, le couplage
entre les différentes composantes de ce dernières doit être faible. 

Le développement de logiciel favorisant la modularité est une qualité
standard en génie logiciel, mais elle vient très bien se marier avec
le développement de jeu, surtout de jeux modernes, car ce sont de
projets de très grande envergure impliquant beaucoup de
programmeurs. Il en résulte qu'un bon design modulaire permet de bien
séparer les tâches à effectuer de manière parallèles par des équipes
spécialisées. Si le projet est bien géré, cela pourrait certainement
réduire le coût de développement de tels projets.

Aussi, une bonne modularité permet de créer des composantes qui sont
cohésives et donc qui permettent d'être réutilisée par la suite. Une
réutilisation de composantes complexes tel un moteur de physique évite
de faire un travail supplémentaire non trivial pour chaque nouveau
projet. Ainsi, il est clair que l'effort supplémentaire placé pour
bien modulariser les composantes d'un jeu seront retables pour le
développement des prochains jeu.

Bien sûr, toute abstraction possède sont coût, notamment en coût de
performances. Ainsi, il faut bien pouvoir estimer les endroits où
l'utilisation de modules externes n'apportera pas de trop grands
impacts de performances.

Il est clair qu'un langage de programmation ayant un bon potentiel
d'abstraction, comme c'est généralement le cas pour les langages de
haut niveau, facilite cette tâche. Un système orienté objet ou un bon
système de module permettraient certainement aussi à bien modulariser
les composantes d'un jeu.

\subsection{Malléabilité}

Puisque le développement d'un jeu implique généralement de faire
beaucoup de prototypage, le code d'un jeu se doit d'être très
malléable afin d'aider à faire des changements rapidement au moteur du
jeu pour tester de nouvelles idées, sans ajouter un trop grand coût
pour le faire.

La modularité du jeu aura un effet positif sur la malléabilité en
permettant de modifier les mécanismes internes des composantes sans
trop affecter le reste du programme. Par contre, un langage de
programmation offrant une bonne puissance d'abstraction serait tout
aussi efficace, car il permet de pouvoir ajouter facilement de
nouvelles abstractions où les besoins de changement apparaissent.


\section{Conclusion}
Dans ce chapitre, l'industrie du jeu vidéo, avec son histoire, ont été
mis en lumière afin d'exposer l'évolution des jeux vidéo et de motiver
l'intérêt de travailler à améliorer le développement de ceux-ci.

Les jeux vidéo sont passés rapidement d'idées farfelues comme ce fut
le cas pour le \textit{Cathode Ray Amusement Device} à une industrie
complète générant des milliards de dollars annuellement. Il y a un
grand intérêt à vouloir diminuer le coût de développement de
ceux-ci. 

Les coûts de développement de jeux modernes sont de l'ordre des
millions de dollars et impliquent des dizaines voir des centaines
d'artistes, de programmeurs et de designers. Ainsi, mêmes de toutes
petites accélérations d'un cycle de développement, pourrait avoir de
l'impacte sur le travail de beaucoup de gens et ainsi se traduire en
de grandes économies sur les coûts de développement.

Les contraintes impliqués au niveau de la programmation par le
développement de jeux vidéo ont été étudiés. Ces derniers se résument
par les concepts de fluidité, modularité et de malléabilité du jeu
vidéo. Le respect de la contrainte de fluidité résulte en une bonne
immersion pour le joueur, qui est nécessaire afin que le jeu soit
considéré comme \og jouable \fg. La modularité facilite le
développement collaboratif et parallèle tout en permettant d'améliorer
la réutilisation des composantes communes à plusieurs jeux. L'aspect
de la malléabilité du code permet d'accélérer le prototypage du jeu.

Il semble donc que le choix d'un langage permettant de pouvoir
facilement répondre à ces contraintes pourrait certainement faciliter
le développement de jeux vidéo et ainsi, engendrer des économies
substantielles aux compagnies de l'industrie et rendant plus
accessible le développement de jeu aux plus petites compagnies
possédant des budgets moins importants.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Le langage Scheme}
\label{Chap:Scheme}

Dans le cadre d'un projet donné, le choix d'un langage de
programmation a beaucoup d'influence sur la structure du code écrit
pour la réalisation de celui-ci. Plusieurs facteurs influencent ces
différences. Par exemple, un langage à typage statique résultera en du
code qui se doit d'être bien structuré, mais qui sera beaucoup moins
malléable par la suite. Ainsi, afin d'optimiser les efforts
développement pour un projet, une bonne analyse des besoins exprimés
par le projet est de rigeur pour pouvoir faire le choix d'un langage
répondant le mieux possible à ceux-ci.

En se basant sur les besoins et les contraintes énoncées dans le
chapitre \ref{Chap:JV}, nous proposons l'utilisation du langage de
programmation Scheme comme outil principal de développement de jeux
vidéo. Il s'agit d'un langage de très haut niveau qui semble être un
candidat idéal afin de permettre un développement efficace de jeux
vidéo. 

Ce chapitre donne une historique du langage Scheme afin de mettre en
situation le langage et donné un aperçu de son origine. Par la suite,
une brève explications de concepts de bases du langage est
donnée. Plus d'informations sur les bases de Scheme peuvent êtres
obtenues dans la littérature~\cite{R5RS}~\cite{SICP}. Finalement, les
particularités du langages sont mise en lumière dans le but de faire
comprendre au lecteur quelle est l'ampleur de celles-ci.

\todo{d'autres idées?}

\section{Héritage LISP}
\label{Scheme:hist}

Le langage Scheme est une forme épurée du tout premier langage de
programmation de haut niveau, le langage LISP. Ainsi, pour illustrer
les origines de Scheme, une courte histoire du langage LISP est
présentée. Par la suite, les langages de programmation qui furent
inspirés du langage Scheme sont mentionnés en expliquant brièvement
les racines commune à Scheme est les principales disparités.

\subsection{Histoire de LISP}
\todo{McCarthy, GC, List Processing, AI...}

\todo{Common LISP = Grosse Bébitte}

\subsection{Avènement de Scheme}
\todo{Épuration de LISP à l'essence du langage}

\todo{évolution du langage via RNRS, SRFIs}

\todo{simplicité du langage, beaucoup d'extension disponibles }

\subsection{Langages inspirés de Scheme}
\todo{Javascript, Ruby: lang de scripting. Concept de fermetures}

\todo{Java??}


\section{Introduction au langage}
Tout en bénéficiant du riche héritage des langages LISP, Scheme
demeure un langage épuré et très simple à la base. Cette section vise
à présenter les bases du langages Scheme et de son implantation dans
le système Gambit-C afin de familiariser le lecteur avec non seulement
la syntaxe du langage, mais aussi les fonctionnalités de base et les
extensions au langages fournies par Gambit-C.

\subsection{Syntaxe}
La syntaxe de Scheme est une des caractéristique qui distingue le
distingue le plus des autres langages de programmation. En effet, la
syntaxe utilisée est extrêmement simple. À la base, toute expression
Scheme est une expression symbolique, nommée aussi \textit{S
  expression}. Une S expression est une forme de donnée structurée
récursive qui doit débuter par une parenthèse ouvrante, contient un
nombre arbitraire de données qui sont soit des atomes ou des S
expressions et qui doit se terminer par une parenthèse fermante. Les
atomes sont des symboles, des nombres, des valeurs booléennes,
etc.. La figure \ref{FIG:sexp} donne un exemple très simple de S
expression contenant des informations sur les prix de la nourriture
dans une épicerie.\\

\begin{figure}[htb!]
  \schemeresult{((bananes 1.52)(bonbons 1/100))}
  \caption{Exemple simple de S expression}
  \label{FIG:sexp}
\end{figure}

En Scheme, ces S expressions sont considérées comme étant des listes
chaînées où chacun des éléments de la liste chaînée contient la valeur
associée à cet élément et un pointeur vers le prochain élément. Les
listes sont ainsi implantées en utilisant des paires. Le point
(\scheme{.}) est utilisé pour démarquer le premier élément d'une paire
du deuxième. La figure \ref{FIG:sexp->list} explicite la structure de
liste de l'exemple de S expression provenant de la figure
\ref{FIG:sexp} en utilisant la notation de paires..\\


\begin{figure}[htb!]
{{\it
    ((bananes . (1.52 . ())) . ((bonbons . (1/100 . ())) . ()))
    }}
  \caption{Équivalence de la S expression de la figure \ref{FIG:sexp}
    sous forme explicite de liste}
  \label{FIG:sexp->list}
\end{figure}

Cette forme est strictement équivalente à celle donnée précédemment et
correspond à la structure de donnée de base employé en Scheme, les
listes. Toutes deux correspondent à des valeurs du langage, mais ne
peuvent pas être données telles quel dans un programme car un
programme Scheme est aussi une S expression qui correspond à \emph{un
  appel de fonction} (ou à une forme spéciale du langage). Le premier
élément de la liste doit être un symbole qui correspond à cette
fonction ou cette forme spéciale et le restes des éléments sont les
argument qui sont eux aussi des programmes Scheme sous forme de S
expressions. Conséquemment, une notation préfixe est utilisée en
Scheme.

La distinction entre un appel de fonction et une forme spéciale est
l'ordre d'évaluation des paramètres. Pour un appel de fonction, chacun
des paramètres passés sont d'abord évalués et ensuite, la valeurs
correspondante à leurs évaluation sont passées à la fonction
appelée. Il s'agit donc d'un \emph{passage par valeur}. En opposition,
les formes spéciales possèdent des règles d'évaluation propres à
elles. Les formes spéciales de bases de Scheme peuvent être étendu par
des macros qui utilisent un passage de valeur par nom, où les
paramètres sont passés directement à la macro comme étant des données
Scheme. Le fonctionnement des macros Scheme est détaillé dans la
section \ref{Scheme:macros}.

Il existe également quelques exception syntaxiques aux S expressions
qui sont utilisées, entres autres, pour construire des données
constantes. On utilise le caractère \scheme{'} ou la forme spéciale
\textit{quote} pour signifier que la S expression subséquente est
constante, \ie  qu'elle ne doit pas être considérée comme un
programme Scheme, mais bien comme une valeur. L'utilisation du
caractère \scheme{è} est strictement équivalente à l'utilisation de la
forme spéciale correspondante. Une exemple d'utilisation est illustré
dans la figure \ref{FIG:quote}.\\


\begin{figure}[htb!]
  \begin{schemecode}
'((bananes 1.52)(bonbons 1/100))
(quote ((bananes 1.52)(bonbons 1/100)))
  \end{schemecode}
  \caption{Exemples d'utilisation de la syntaxe \textit{quote} et de
    la forme spéciale correspondante.}
  \label{FIG:quote}
\end{figure}

Après évaluation, ces deux morceaux de code retournent tous deux la
valeur \schemeresult{((bananes 1.52)(bonbons 1/100))}.

On retrouve une forme altéré du \textit{quote} nommée
\textit{quasiquote} qui permet des évaluations partielles à
l'intérieur d'une forme \textit{quote} en utilisant le caractère
\scheme{,} équivalent à la forme spéciale \scheme{unquote}. La figure
\ref{FIG:quasiquote} illustre un exemple d'utilisation.\\

\begin{figure}[htb!]
  \begin{schemecode}
`((bananes ,(+ 1.0 52/100)) (bonbons 1/100))
(quasiquote ((bananes (unquote (+ 1.0 52/100))) (bonbons 1/100)))
  \end{schemecode}
  \caption{Exemple d'utilisation des formes spéciales
    \scheme{quasiquote} et \scheme{unquote}}
  \label{FIG:quasiquote}
\end{figure}

L'utilisation de la forme \scheme{unquote} permet donc ici
l'évaluation de la S expression effectuant l'addition pour donner
comme résultat la liste donnée dans la figure \ref{FIG:sexp}.

Malgré le fait que, pour certains, le parenthèsage des programmes
Scheme peut sembler imposant, il en résulte un code \emph{structuré}
et \emph{sans aucune ambiguïté}. Cette structure permet aussi de
pouvoir utiliser très efficacement des outils de d'édition de S
expressions, accélérant ainsi l'écriture de programmes.

\subsection{Aperçu des fonctionnalités requise par le standard}

Le standard du langage Scheme~\cite{R5RS} est très minimaliste, mais
requiert toutes les fonctionnalités de bases requise par un langage de
haut niveau comme Scheme. On y spécifie que Scheme est un langage typé
dynamiquement, \ie que les vérifications de types sont
faites durant l'exécution d'un programme, et non durant la
compilation. Cette particularité fait en sorte que Scheme est un
langage qui peut être facilement interprété ou compilé. Les types de
bases du langages sont tous disjoints entre eux (aucun n'objet ne peut
appartenir a plus d'un de ces types, mais doit appartenir à un
seul). Ces types sont vérifiés par les prédicats \scheme{boolean?},
\scheme{pair?}, \scheme{symbol?}, \scheme{number?}, \scheme{char?},
\scheme{string?}, \scheme{vector?}, \scheme{port?},
\scheme{procedure?}. Chacun de ces types sont documentés et possèdent
des fonctions standards de création et d'utilisation.

Les valeurs booléennes sont dénotées par \scheme{\#t} et
\scheme{\#f}. Par contre, le langage tire profit du dynamisme du typage
et considère que toute valeurs différentes à \scheme{\#f} est vraie.

Les paires, comme mentionné précédemment, sont les structures de
données de bases en Scheme. La fonction de création d'une paire se
nomme \scheme{cons} et les accesseurs aux premier et deuxième valeurs
sont nommés respectivement \scheme{car} et \scheme{cdr}. La figure
\ref{FIG:cons} illustre la création programmatique de la S expression
de la figure \ref{FIG:sexp}.\\

\begin{figure}[htb!]
  \begin{schemecode}
(cons (cons 'bananes (cons 1.52 '()))
      (cons (cons 'bonbons (cons 1/100 '()))
            '()))
  \end{schemecode}
  \schemeresult{((bananes 1.52)(bonbons 1/100))}
  \caption{Exemple de création programmatique de listes}
  \label{FIG:cons}
\end{figure}

Les symboles se sont spécifié uniquement par du texte dans le
programme et sont utilisé comme données, mais surtout pour faire des
liaisons dans le programmes. En effet, les variables sont représentées
par des symboles. Ainsi, pour utiliser un symbole comme une donnée
(donc un symbol constant), la forme spéciale \scheme{quote} doit être
utilisée. Aussi, plusieurs formes spéciales de liaisons sont spécifiée
dans le standard. Les plus fondamentales étant \scheme{define} et
\scheme{let}. La forme spéciale \scheme{define} permet la déclaration
de variables globales ou locales permettant la récursion. La forme
spéciale \scheme{let} permet la création de liaisons locales
non-récursives. La figure \ref{FIG:deflet} illustres de création de
liaisons globales, locales et d'utilisation de symboles comme
données. Le morceau de code présenté définit une fonction globale qui
vérifie si tout les éléments d'une liste sont strictement inférieurs à
10. Ainsi l'appel \scheme{(drole-de-fonction (list 1 11 4))} s'évalue
à la valeur \schemeresult{non}.\\

\begin{figure}[htb!]
  \begin{schemecode}
(define (drole-de-fonction x)
  (let ((premier (car x))
        (deuxieme (cdr x)))
    (if (< premier 10)
        (if (null? x)
            'oui
            (drole-de-fonction deuxieme))
        'non)))
  \end{schemecode}
  \caption{Exemple de créations de liaisons et d'utilisation de
    symboles comme données}
  \label{FIG:deflet}
\end{figure}

On y retrouve ainsi une spécification pour le calcul numérique qui
offre la possibilité de faire du calcul sur nombres flottants,
entiers, réels et même complexes. 

L'utilisation caractères et les chaînes de caractères est très
simple. Les caractères en tant que donné sont précédés par
\scheme{\#\textbackslash} et les chaînes de caractères sont facilement
convertibles en listes de caractères pour une manipulation plus \og
Schemiène \fg ou l'on peut accéder directement et modifier des
caractères dans l'objet de type \scheme{string}.

\todo{vectors}

\todo{ports}

\todo{procedures, apply, appels terminaux}

\subsection{Extensions présentées par Gambit-C}

\section{Programmation fonctionnelle}
Le langage Scheme est à la base un langage fonctionnel. Ces derniers
sont caractérisés par une programmation centrée sur l'appel de
fonctions dites avec une transparence référentielle, où la valeur de
retour d'une fonction dépend uniquement des paramètres et non de
l'état du système. Ce type de programmation fait contraste à la
programmation impérative qui est centrée sur la notion d'état et de
mutation de l'état de l'exécution d'un programme. Les programmes
écrits en utilisant des langages sont généralement beaucoup plus
facile à comprendre, ce qui attire un grand nombre de chercheurs à
contribuer au développement et l'utilisation de tels langages dans le
milieu commercial.

Une caractéristique importante des langages de programmation
fonctionnelle est la présence de fonctions de premier ordre, \ie que
les fonctions sont des objets appartenant aux valeurs du
langages. Elles peuvent donc être créées et manipulées comme tout
autre valeurs. Ces fonctions sont aussi appelées fermetures, car
lorsqu'elles sont créés, elle conserve l'environnement d'exécution
dans lequel elle se trouvait lors de sa création. 

Ce concept ouvre la porte à la création d'abstractions très
intéressantes: les fonctions d'ordre supérieures. Celles ci reçoivent
des fonctions en paramètre les manipulent en souvent en retournent de
nouvelles. La figure \ref{FIG:hof} illustre un exemple d'écriture et
d'utilisation de fonctions d'ordre supérieurs. La premières fonctions
définie prend une fonction en paramètre et applique cette fonction sur
chacun des éléments de la liste passée comme deuxième paramètre. La
deuxième fonction prend une fonction à deux paramètres comme premier
argument et prend le deuxième paramètre à appliquer à cette fonction
en deuxième argument, dans le but de faire une application partielle
de cet argument à cette fonction. L'exemple utilise ensuite ces deux
fonctions afin de créer une nouvelle à partir de celle donnée où l'on
aura retiré 1 à chaque élément.\\

\begin{figure}[htb!]
  \begin{schemecode}
(define (map f lst)
    (if (pair? lst)
        (cons (f (car lst)) (map f (cdr lst)))
        '()))
(define (flip f y)
    (lambda (x) (f x y)))
(map (flip - 1) '(1 2 3 4 5))
  \end{schemecode}
  \schemeresult{(0 1 2 3 4)}
  \caption{Exemple de création et d'utilisation de fonctions d'ordres
    supérieures.}
  \label{FIG:hof}
\end{figure}

L'utilisation de fonctions d'ordre supérieure permet l'abstraction
d'algorithmes de manière très générique. Une autre fonction d'ordre
supérieur très utilisée est la fonction \scheme{foldl} qui permet
d'utiliser chacun des éléments d'une liste pour calculer un résultat
unique. La figure \ref{Scheme:fold} illustre l'utilisation de cette
fonction pour faire la somme et le produit des nombres dans une liste.\\

\begin{figure}[htb!]
  \begin{schemecode}
(define (foldl f acc lst)
    (if (not (pair? lst))
        acc
        (foldl f (f acc (car lst)) (cdr lst))))
(foldl + 0 '(1 2 3 4 5))
  \end{schemecode}
  \schemeresult{15}
  \begin{schemecode}
(foldl * 1 '(1 2 3 4 5))
  \end{schemecode}
  \schemeresult{120}
  \caption{Fonction d'ordre supérieure \scheme{foldl}.}
  \label{Scheme:fold}
\end{figure}

\subsection{Programmation fonctionnelle pure}

Une programmation dite purement fonctionnelle respecte de manière
stricte le paradigme de la programmation fonctionnelle, \ie que les
fonctions sont des entités mathématique qui ne sont pas affectées par
l'état du système. Ce type de programmation est originaire d'avant
même la création des premiers ordinateurs. C'est dans les années 1936
que nul autre qu'Alonzo Church a introduit le formalisme mathématique
de définition de fonctions mathématique dénommé lambda calcul non
typé~\cite{LAMBDA_CALCULUS}. Ce formalisme introduit des notations
afin de définir des fonctions anonymes qui sert de base aux langages
de programmation fonctionnels. La figure \ref{FIG:lambda-calcul}
illustre la définition de la fonction \scheme{flip} définie en Scheme
dans la figure \ref{FIG:hof}.\\

\begin{figure}[htb!]
  \center
  $\lambda f \rightarrow \lambda y \rightarrow \lambda x \rightarrow f x y$
  \caption{Définition de la fonction \scheme{flip} en lambda calcul
    non typé}
  \label{FIG:lambda-calcul}
\end{figure}

Ces fonctions sont considérées comme pures car elles sont exemptes de
mutations de l'état du calcul. Ainsi, le résultat de l'application
d'une fonction (appellée $\beta$-reduction en lambda calcul) ne dépend
que des paramètres de ces dernières.

Comme déjà mentionné dans la section \ref{Scheme:hist}, le lambda
calcul a donné naissance une famille de langages dont la racine est le
langage LISP. Parmi cette famille, les langages ML~\cite{SML} et
Haskell~\cite{HASKELL} sont parmi les plus connu de ceux qui adhèrent
fidèlement au modèle de calcul de Alonzo Church.

Le langage Scheme est lui aussi un langage fonctionnel, mais il n'est
pas considéré comme étant pur puisque les mutations de l'état du
programme sont permises. En effet, des opérateurs tels que
\scheme{set!}, \scheme{set-car!} ou encore \scheme{vector-set!}
permettent la modification de liaison ou du contenu de cellules
mémoires. Ainsi, Scheme partage le meilleur des deux mondes en
laissant la liberté au programmeur de choisir le paradigme de
programmation qui lui apparaît le plus approprié. Par contre, un abus
de mutation est considéré comme étant de très mauvais style en Scheme.


\section{Macros}
\label{Scheme:macros}

Les macros d'un langage de programmation sont des systèmes utilisés
pour faire des abstractions qui sont résolues durant la compilation
d'un fichier sources. Dans sa forme la plus élémentaire, un système de
macro peut être implanté sous la forme d'un pré-processeur de code qui
ne fait que du remplacement de patrons par une expansion textuelle
directe. C'est ce genre de système de macro que l'on retrouve entre
autre dans le langage C. Ce type de macro, quoi que très simple,
permet de faire déjà beaucoup d'abstractions allant à des abstractions
d'optimisations à des expansions conditionnelles de code permettant de
développer des librairies sur plusieurs plates-formes. La figure
\ref{Scheme:c-macros} illustre des exemples de macros C. Dans cet
exemple, on défini la macro \scheme{swap} qui interchange la valeur de
deux variables entre elles. La fonction main retournera 1 si et
seulement si le symbole \scheme{\_\_WEIRD\_OS\_\_} est défini, et
retournera 0 sinon. On peut imaginer un système d'exploitation fictif
qui s'attend à une valeur de statut de terminaison de processus qui
doit être égale à 1 pour signaler la terminaison normale d'un
processus. Puisque normalement, le statut de terminaison normal d'un
processus est 0, on utilise une expansion conditionnelle à la présence
d'un symbole qui ne devrait qu'être présent que lorsque l'on se trouve
dans ce système fictif.\\

\begin{figure}[htb!]
  \begin{verbatim}
#define swap(x,y) do { int tmp; tmp = x; x = y; y = tmp; } while(0)
int main(){
  int x = 0;
  int y = 1;
#ifdef __WEIRD_OS__
  swap(x,y);
#endif
  return x;
}
  \end{verbatim}
  \caption{Exemple de macro C avec expansion conditionnelle.}
  \label{Scheme:c-macros}
\end{figure}

De telles macros comportent beaucoup de problèmes potentiels. Non
seulement, elle ne sont limitées qu'a faire des remplacements
syntaxiques très primitifs, mais aussi sont souvent la sources de
problèmes reliés au changement du contexte syntaxique des arguments de
la macro ou à une expansion dans un contexte qui n'était pas
prévu. Ces problèmes sont souvent très difficile à trouver car ils ne
surviennent que le programme est compilé, bien après l'expansion des
macros. Il en résulte que le code compilé ne contient aucune trace des
macros et donc le compilateur donne souvent des erreurs qui ne sont
pas reliées avec la vraie source du problème, soit la définition de la
macro en question.

La syntaxe préfixe extrêmement simple de Scheme donne la chance au
langage de posséder la même syntaxe que les structures de données de
base de ce dernier. Ceci ouvre la porte à implanter un système de
macro très puissant, un système de macro procédural. 

Plusieurs systèmes d'expansions de macro sont disponible en Scheme. Le
plus simple d'entre eux est celui qui provient directement de LISP, la
forme spéciale \scheme{define-macro}. Avec cet expanseur, une macro
Scheme est une fonction dont les paramètres \emph{ne sont pas évalués}
avant d'être passés au corps de la fonction. Il en résulte ainsi que
le code étant en position d'argument est considéré par la macro comme
étant des données Scheme (listes, symboles, nombres, etc...). Puisque
la macro Scheme est une fonction, elle possède toute la puissance du
langage à sa disposition. La S expression retournée par la macro sera
le résultat de l'expansion de celle-ci et sera donc évalué durant
l'exécution du programme à l'endroit où l'appel de la macro se
retrouvait.

Un exemple simple mais convaincant de macro Scheme est illustré dans
la figure \ref{Scheme:macro-ex1}. Cette macro sert à définir des
variables constantes correspondant à des nombres de la série de
Fibonacci. Le nombre \scheme{n} passé à la macro est utilisé pour
calculer le n\ieme nombre de Fibonacci \emph{durant l'expansion de la
  macro} pour générer le code présenté dans la figure
\ref{Scheme:macro-ex1-exp}. Ainsi, le code résultant de l'expansion
est par la suite évalué durant l'exécution du programme, et il est
possible de faire référence à la variable \scheme{fib10}.\\

\begin{figure}[htb!]
  \begin{schemecode}
(define-macro (define-fib n)
    (letrec ((fib (lambda (n) (if (< n 3) 1 (+ (fib (- n 1)) (fib (- n 2)))))))
      `(define ,(string->symbol (string-append "fib" (number->string n)))
         ,(fib n))))
(define-fib 10)
  \end{schemecode}
  \caption{Exemple simple de macro Scheme.}
  \label{Scheme:macro-ex1}
\end{figure}

\begin{figure}[htb!]
  \begin{schemecode}
(define fib10 55)
  \end{schemecode}
  \caption{Résultat de l'expansion de la macro présentée dans la
    figure \ref{Scheme:macro-ex1} avec 10 comme paramètre.}
  \label{Scheme:macro-ex1-exp}
\end{figure}

Cet exemple très simple n'a pas utilisé le passage de paramètre par
nom dont disposent les macros Scheme, \ie que la macro de la figure
\ref{Scheme:macro-ex1} n'a pas utiliser le fait que le code passé en
paramètre est une donnée Scheme, puisqu'un nombre s'évalue en lui même
en Scheme. Il est intéressant de noter qu'un appel à cette macro comme
\scheme{define-fib (+ 1 2))}, est une erreur. En effet, puisque la
macro s'attend à avoir un nombre en paramètre, mais elle reçoit plutôt
de ce cas ci la liste \scheme{(+ 1 2)}, puisque l'évaluation de
l'addition ne sera fait que durant l'exécution du programme.

Un exemple simple de macro tirant profit du fait que l'argument est
passé par nom est illustré dans la figure \ref{Scheme:macro-ex2}.\\

\begin{figure}[htb!]
  \begin{schemecode}
(define-macro (inc! var) `(set! ,var (+ ,var 1)))
(let ((x 1))
    (inc! x)
    x)
  \end{schemecode}
  \schemeresult{2}
  \caption{Exemple simple de macro utilisant le passage par nom à profit.}
  \label{Scheme:macro-ex2}
\end{figure}

Cette macro très simple utilise le passage par nom pour permettre
d'incrémenter la valeur d'une variable. Un exemple plus complexe de
macro utilisant le passage par nom est donné dans la figure
\ref{Sceme:macro-ex3}. Cette macro permet d'augmenter le langage
Scheme d'une nouvelle forme spéciale qui correspond à une forme simple
d'itération. \\

\begin{figure}[htb!]
  \begin{schemecode}
(define-macro (for var init limit . body)
  `(let loop ((,var ,init))
     (if (< ,var ,limit)
         (begin ,@body
                (loop (+ ,var 1))))))
(let ((v (make-vector 5)))
  (for x 0 5 (vector-set! v x x))
  v)
  \end{schemecode}
  \schemeresult{\#(0 1 2 3 4)}
  \caption{Exemple de macro ajoutant une nouvelle forme spéciale au langage.}
  \label{Scheme:macro-ex3}
\end{figure}

Cette macro comporte, par contre plusieurs problèmes. L'un d'entre eux
est relié à l'introduction de la variable \scheme{loop}. L'ajout de
cette variable peut causer le problème connu sous le nom de
\emph{Capture de Variables}. En effet, la macro n'aura pas le
comportement escompté si l'un de ses paramètres possède une référence
à une variable déjà existante nommée \scheme{loop}. Le problème de
capture de variables était tout aussi présent dans les macro à la C et
constituait pour ce type de macro un problème insolvable. Par contre,
il est possible d'éviter ce problème en Scheme en générant un nom de
variable pour \scheme{loop} qui est assurément unique. L'implantation
Gambit-C offre la fonction \scheme{gensym} pour ces besoins.

Le problème de capture de nom est associé au phénomène appelé hygiène
des macros. Ce problème peut être résolu manuellement comme suggéré,
mais il existe aussi d'autres expansées de macro assurant l'hygiène
des macros, dont entre autres la forme spéciale
\scheme{syntax-rules}~\cite{SCHEME_HYG_MACRO}. La réécriture de la
macro \scheme{for} en utilisant un système de macro hygiénique est
donnée dans la figure \ref{Scheme:macro-ex4}. Cette figure donne aussi
un exemple d'utilisation de la macro mettant à l'épreuve l'hygiène de
celle-ci. On constate que malgré le fait qu'aucun effort n'a dû être
mis en place pour éviter les collisions de noms pour la variable
\scheme{loop} introduite, la macro réalise le comportement attendu
d'elle dans des conditions potentiellement problématiques.

\begin{figure}[htb!]
  \begin{schemecode}
(define-syntax for
    (syntax-rules ()
      ((for var init limit body ...)
       (let loop ((var init))
         (if (< var limit)
             (begin body ...
                    (loop (+ var 1))))))))
(let ((v (make-vector 5)))
    (for loop 0 5 (vector-set! v loop loop))
    v)
  \end{schemecode}
  \schemeresult{\#(0 1 2 3 4)}
  \caption{Macro \scheme{for} hygiénique}
  \label{Scheme:macro-ex4}
\end{figure}

Malgré le fait que l'expansion de macro faite avec
\scheme{define-macro} puisse impliquer des collisions de variables,
elle permet une plus grande liberté d'écriture. En effet, parfois la
collision de nom peut, par exemple, être intentionnelle. Aussi, le
problème est facilement résolu avec l'utilisation de symboles uniques.



\section{Continuations}

L'état d'un calcul en cours d'exécution est souvent implanté ou
illustré par une pile d'exécution. C'est le modèle d'implantation
utilisé en C et dans la plupart des langages de programmation. Ainsi,
l'exécution d'un appel de fonction empile l'adresses de retour et
utilise le dessus de la pile pour les variables locales à la
fonction. Lorsque la fonction termine, l'adresse de retour est dépilée
et le contrôle revient à l'endroit de l'appel de
fonction. L'environnement d'exécution de cet appel est contenu
partiellement dans l'état de la pile et devient donc perdu lorsque
l'appel se termine.

En Scheme, le modèle d'exécution, quoi que similaire, est sensiblement
différent. L'évolution de l'exécution d'un programme est implanté par
des continuations. Ces dernières sont des fermetures qui représentent
le reste du calcul à faire à un moment du calcul donné. La
continuation initiale d'un programme est la terminaison de ce dernier,
puisque après avoir exécuter le programme, il ne restera plus rien à
faire.

Les figures \ref{Scheme:cont-ex1} et \ref{Scheme:cont-ex2} illustrent
la continuation d'un appel de fonction dans un calcul très
simple. Ainsi, après avoir exécuté l'appel de la fonction \scheme{f},
le reste du calcul à effectuer peut être représenté par une fermeture
attendant le résultat de l'appel de fonction en entrée. \\

\begin{figure}[htb!]
  \begin{schemecode}
(+ a (- [f x y] 2))
  \end{schemecode}
  \caption{Exemple simple de calcul en Scheme}
  \label{Scheme:cont-ex1}
\end{figure}

\begin{figure}[htb!]
  \begin{schemecode}
(lambda (res-f) (+ a (- res-f 2)))
  \end{schemecode}
  \caption{Continuation de l'appel de la fonction \scheme{f} présenté
    dans la figure \ref{Scheme:cont-ex1}}
  \label{Scheme:cont-ex2}
\end{figure}

Le langage Scheme offre la possibilité de réifier la continuation d'un
calcul donné par l'entremise de la forme spéciale
\scheme{call-with-current-continuation} souvent disponible aussi via
\scheme{call/cc}. La figure \ref{Scheme:cont-ex3} donne un exemple de
la réification d'un calcul similaire à celui présenté dans la figure
\ref{Scheme:cont-ex1}. La mutation de la variable \scheme{k} est
utilisée afin de permettre une sauvegarde de la continuation et dans
le but de la réutiliser plus tard.

\begin{figure}[htb!]
  \begin{schemecode}
(define k \#f)
(define f (lambda (x y) (* x y)))
(+ 3 (- (call/cc (lambda (cont) (set! k cont) [f 5 6])) 2))
  \end{schemecode}
  \schemeresult{31}
  \begin{schemecode}
(k 10)
  \end{schemecode}
  \schemeresult{11}
  \caption{Réification d'une continuation à l'aide \scheme{call/cc}}
  \label{Scheme:cont-ex3}
\end{figure}

Ainsi, la sauvegarde d'une continuation permet de conserver l'état du
calcul et la réutilisation de celui-ci.

\subsection{Exemples d'utilisations}
L'utilisation de continuations ajoute beaucoup de puissance au niveau
de la programmation en Scheme, si elle est habilement exécutée. Cette
section présente quelques utilisations intéressantes permettant
d'entrevoir les possibilités qu'offre cet aspect de Scheme.

\subsubsection{Échappement au flux de contrôle}
Un exemple simple d'utilisation de continuation est pour l'échappement
au contrôle d'une fonction. Bien sûr, un programmeur a toujours le
contrôle du programme qu'il écrit, mais il peut y avoir des situation
qui exigent l'utilisation de fonctions externes dont on ne peut pas
modifier le contenu. De telles situations peuvent mener à des
inefficacités algorithmiques. La figure \ref{Scheme:bad-fold} illustre
une utilisation de la fonction d'ordre supérieur \scheme{foldl}
présentée dans la figure \ref{Scheme:foldl} afin d'implanter un
algorithme permettant de déterminer s'il existe au moins une valeur
supérieure à 10 dans une liste. En utilisant la fonctionnalité de
traces qu'offre Gambit-C, on constate que malgré le fait que
l'utilisation d'une fonction d'ordre supérieur permet d'implanter
facilement cet algorithme, il en résulte en du code inefficace,
puisque l'appel à \scheme{foldl} va analyser tous les éléments de la
lite, même après avoir trouvé une valeur supérieure à 10.

\begin{figure}[htb!]
  \begin{schemecode}
(trace foldl)
(define (exists-greater-than val lst)
    (foldl (lambda (false x) (if (> x val) x false))
           \#f
           lst))
(exists-greater-than 100 (list 1 102 3 2 7 12))
  \end{schemecode}
  {{\it
\textbar \textgreater (foldl proc \#f '(1 102 3 2 7 12))\\
\textbar \textgreater (foldl proc \#f '(102 3 2 7 12))\\
\textbar \textgreater (foldl proc 102 '(3 2 7 12))\\
\textbar \textgreater (foldl proc 102 '(2 7 12))\\
\textbar \textgreater (foldl proc 102 '(7 12))\\
\textbar \textgreater (foldl proc 102 '(12))\\
\textbar \textgreater (foldl proc 102 '())\\
\textbar 102\\
102
}}
  \caption{Utilisation non efficace de \scheme{foldl}.}
  \label{Scheme:bad-fold}
\end{figure}

On doit donc ré-écrire le méta comportement offert par \scheme{foldl}
afin de pouvoir arrêter la recherche aussitôt qu'une valeur supérieure
à 10 est trouvée. Cela vient à l'encontre du principe d'abstraction
mène à une mauvaise maintenabilité du code. 

Les continuations nous offres par contre la possibilité d'utiliser la
méta fonction \scheme{foldl}, sans perte de performances. La figure
\ref{Scheme:better-foldl} indique comment s'y prendre. En réifiant la
continuation au début du calcul de la fonction
\scheme{exists-greater-than}, cette continuation capture le reste du
calcul à faire après cet appel de fonction et donc, lorsque cette
continuation, liée à la variable \scheme{return}, est appelée, il en
résulte que le flot de contrôle branche vers la suite du calcul en
prenant comme valeur de retour la valeur trouvée.

\begin{figure}[htb!]
\begin{schemecode}
(trace foldl)
(define (exists-greater-than val lst)
    (call/cc
     (lambda (return)
       (foldl (lambda (retval x) (if (> x val)
                                     (return x)
                                     retval))
              \#f
              lst))))
(exists-greater-than 100 (list 1 102 3 2 7 12))
\end{schemecode}
    {{\it
\textbar \textgreater (foldl proc \#f '(1 102 3 2 7 12))\\
\textbar \textgreater (foldl proc \#f '(102 3 2 7 12))\\
102
    }}
  \caption{Utilisation d'une continuation pour échapper au flot de
    contrôle.}
  \label{Scheme:better-foldl}
\end{figure}

\subsubsection{Recherche par retour sur trace}
Un autre exemple d'utilisation intéressant de continuations est dans
la création d'un système de recherche par retour sur trace
(\textit{backtracking}). La figure \ref{Scheme:backtrack} illustre un
exemple simple de recherche d'un triplet de nombres entiers tel que
$x^2 = y^2+z^2$.

\begin{figure}[htb!]
  \begin{schemecode}
(define fail (lambda () (error "can't backtrack")))
(define (in-range a b)
  (call/cc (lambda (cont) (enumerate a b cont))))
(define (enumerate a b cont)
  (if (> a b)
      (fail)
      (let ((save fail))
         (set! fail (lambda () (set! fail save)
                               (enumerate (+ a 1) b cont)))
         (cont a))))
(let ((x  (in-range 1 9))
      (y  (in-range 1 9))
      (z  (in-range 1 9)))
  (if (= (* x x) (+ (* y y) (* z z)))
      (list x y z)
      (fail)))
  \end{schemecode}
  \schemeresult{(5 3 4)}
  \caption{Exemple de recherche par retour sur trace}
  \label{Scheme:backtrack}
\end{figure}

Dans cet exemple simple, la fonction \scheme{fail} représente une
liste chaînée de retour arrières permettant de revenir à une étape de
décision précédente et de poursuivre le calcul en prenant une nouvelle
décision à cet endroit. Cet exemple illustre bien l'élégance qui peut
résulter de l'utilisation judicieuse de la forme spéciale
\scheme{call/cc}.

\subsection{Forme d'écriture de code en CPS}

En Scheme, on distingue deux types d'appels de fonction, les appels
terminaux et les appels non-terminaux. Un appel terminal est un appel
dont la continuation est la même que la continuation de la fonction
dans laquelle il se trouve, sinon, il s'agit d'un appel
non-terminal. La figure \ref{Scheme:fact} illustre l'implantation
traditionnelle de la fonction factoriel en Scheme. On constate que
cette fonction contient un seul appel terminal: l'appel à la fonction
\scheme{*}. Cet appel possède la même continuation que celle de la
fonction \scheme{fact} puisque le calcul qui reste après cet appel est
en fait la suite du calcul à l'appel original de \scheme{fact}.

\begin{figure}[htb!]
  \begin{schemecode}
(define (fact n)
  (if (< n 2)
      1
      (* n (fact (- n 1)))))
(fact 10)
  \end{schemecode}
  \schemeresult{3628800}
  \caption{Exemple de fonction contenant des appels terminaux et
    non-terminaux.}
  \label{Scheme:fact}
\end{figure}

Les appels terminaux sont sujet à une optimisation
intéressante. L'optimisation d'appels terminaux consiste à changer la
continuation d'un appel terminal directement par la continuation de la
fonction dans laquelle se trouve cet appel. Dans le cadre de l'exemple
de la fonction \scheme{fact} la continuation de l'appel à \scheme{*}
dans la figure \ref{Scheme:fact} est la même que celle de la fonction
factoriel. Supposons que nous appelons cette continuation
\scheme{k}. Ainsi, la continuation de \scheme{*} pourrait être
représentée par la fonction \scheme{(lambda (r) (k r))}.
L'optimisation d'appels terminaux revient à utiliser directement
\scheme{k} comme continuation à la multiplication. Ainsi, le flot de
contrôle du calcul n'a plus besoin de revenir dans \scheme{fact}
lorsque la multiplication est terminée, mais peut continuer
directement le calcul. Cette optimisation est requise pour toute
implantation de Scheme par la spécification du langage.

Il existe un style d'écriture de code appelé \textit{Continuation
  Passing Style} ou style en forme CPS qui consiste à expliciter
toutes les continuations dans un programme. Une propriété intéressante
de ce style d'écriture est que tous les appels sont des appels
terminaux. La figure \ref{Scheme:cps-fact} contient la réécriture de
la fonction factoriel présentée dans la figure \ref{Scheme:fact}. On
peut constater que cette réécriture a appliqué l'optimisation d'appels
terminaux.

\begin{figure}[htb!]
  \begin{schemecode}
(define (minusk n1 n2 k) (k (- n1 n2)))
(define (timesk n1 n2 k) (k (* n1 n2)))
(define (factk n k)
  (if (< n 2)
      (k 1)
      (minusk n 1 (lambda (r)
                    (fact r (lambda (r2)
                              (timesk n r2 k)))))))
(factk 10 (lambda (x) x))
  \end{schemecode}
  \schemeresult{3628800}
  \caption{Forme CPS de la fonction factoriel}
  \label{Scheme:cps-fact}
\end{figure}

Cette transformation est souvent utilisée par les implantations de
Scheme car elle facilite l'implantation de l'optimisation d'appels
terminaux en rendant tous les appels comme terminaux. Ce style de
programmation permet aussi d'utiliser de manière élégantes la
puissance d'abstraction des langages fonctionnels en permettant de
diviser le calcul en petites parties facilement interchangeable et
modulaires.





\section{Gestion mémoire automatique}
\subsection{Motivation}
\todo{Gestion mémoire manuelle ou semi-automatique causent énormément
  de problèmes de fuites de mémoire (ou de pointeurs fous).}

\todo{En connaissant les racines, on peut automatiser la récupérations
  de mémoire, au coût d'un certain temps de calcul.}

\todo{Date des premières version de LISP.}



\subsection{Survol des techniques}
\todo{Mark and sweep}

\todo{Stop and copy}

\todo{GC générationnels}

\todo{GC temps réels ou incrémentaux}



\section{Dynamisme du langage}

Le langage Scheme est un langage à typage dynamique, faisant ainsi
contraste aux langages fonctionnels de la famille \textit{ML}. Un
typage dynamique se distingue par des vérifications de types
effectuées durant l'exécution d'un programme. Un typage statique,
quant à lui, effectuera les vérifications de types durant la
compilation. Ainsi, la principale différence entre les deux approches
est le moment où les erreurs de programmation apparaissent. 

Un typage statique fournira des erreurs de types beaucoup plus tôt
dans le processus de développement et permettent de pouvoir exécuter
un code libre de toutes vérification de types. Une particularité des
systèmes typés statiquement consiste à avoir des structures de code
plus rigides, demandant possiblement beaucoup d'efforts pour être
modifié. 

Pour un typage dynamique, les erreurs ne surviendront que durant
l'exécution du programme et, pourraient ne jamais se produire, ou
difficilement se produire. De plus, un typage dynamique implique de
légères pertes de performances puisque les vérifications de effectuées
pendant l'exécution du programme. Par contre, des erreurs apparaissant
durant l'exécution peuvent être beaucoup plus faciles à corriger, si
le système est muni de bon système de déboggage. Aussi, un typage
dynamique permet au langage de pouvoir être interprété en plus de
pouvoir être compilé. L'interprétation permet un développement rapide
et facilite le prototypage grâce à la possibilité de faire de la
programmation en direct (\textit{live coding}). 

Les deux systèmes de typages peuvent être comparés à l'aide de
métaphores simples. Des programmes écrits dans des langages typés
statiquement peuvent être considérés comme des murs de briques. Les
types agissent comme du ciment entre les fonctions et donc la
modification de la structure nécessite des efforts pour la
refaire. Par contre, lorsque ces bases sont stables et solides, le
typage statique assure un adhération parfaite entre les blocs.  En
opposition, le typage dynamique peut être vu comme un système de
plantes vivantes, où les feuilles sont des fonctions ou des
modules. Le système permet une grande flexibilité d'évolution en
s'adaptant plus facilement aux changements et permet de pouvoir être
facilement modifié en cours de route pour donner le résultat
escompté. Un entretient régulier doit être par contre fait par la
suite pour éviter une évolution qui pourrait aller dans une mauvaise
direction.


\subsection{Interprétation et débuggage}


\todo{Possibilité de pouvoir exécuter du code arbitraire lors d'un
  crash}

\todo{Possibilité de pouvoir inspecter chacune des frames de la pile
  de continuactions afin de pouvoir obtenir de l'info sur
  l'environnement de celui-ci, l'endroit dans le code source où la
  continuation se trouve et même de pouvoir exécuter du code dans
  l'environnement d'une continuation de la pile choisie.}

\todo{Possibilité de faire le déboggage à distance (ex: iPhone)}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation orientée objet}

\todo{Parler des define-type de Gambit-C et du SRFI-9}

\todo{Approche traditionnelle de la prog OO: Surdéfinition de méthodes de
  classe, héritage simple, polymorphisme, etc...}

\todo{Parler de CLOS: intégré à Common LISP, fonctions génériques, héritage
  multiple}

\todo{Besoins pour jeux vidéo}

\section{Description du langage}
\todo{Langage orienté objet qui a pour but d'être efficace tout en
  apportant l'expressivité offerte par la programmation orientée
  object à la CLOS.}

Résumé des fonctionnalités:
\begin{itemize}
\item Accès aux membres rapide
\item Héritage multiple
\item Polymorphisme
\item Fonctions génériques à \og dispatch \fg multiple
\end{itemize}

\subsection{Définition de classes}
\todo{Compatibilité avec les define-type}

\todo{Définitions simples (instance slots et class slots)}

\todo{Héritages des membres}

\todo{Utilisation de hook sur les slots}

\todo{Constructeurs}


\subsection{Définition de fonctions génériques}
\todo{Dispatch simple}

\todo{Dispatch multiple (avec les problèmes reliés à la résolution de la méthode à choisir)}

\todo{call-next-method}

\todo{Type '*'}

\subsection{Fonctions et formes spéciales utilitaires}

\todo{Vérifications manuelles de typages et introspections
  (instance-object?, instance-of?, find-class?, get-class-id,
  is-subclass?, get-supers)}




\section{Implantation}
\todo{Apercu global: Utilisation de macros scheme pour effectuer la
  génération de code nécessaire au fonctionnement du système.}

\todo{Séparation entre le travail fait durant l'expantion macro et
  l'exécution}

\todo{Passage d'informations entre le moment de l'expansion et
  l'exécution (informations sur les classes, les fonctions génériques,
  etc...)}

\subsection{Implantation de define-class}
\todo{Structures de données (descripteurs de classes, format des
  instances, etc..)}

\todo{Polymorphisme: chaque index dans les descripteurs de classes
  sont orthogonaux (implique que les descripteurs grossissent
  linéairement en fonction du nombre de classes) et passage aux
  classes enfants des indexes utilisés par les parents.}

\todo{Constructeurs et describe comme fonctions génériques}

\subsection{Implantation de define-generic}
\todo{Registre des méthode: Conservations d'informations sur les
  fonctions génériques et leurs instances }

\todo{Implantation du polymorphisme des fonctions génériques}

\todo{Implantation du call-next-method faite avec l'utilisation de
  variables à portée dynamique}

\todo{Coût de l'utilisation des fonctions génériques}

\subsection{Implantation de define-method}
\todo{Stockages des fermetures durant l'expansion macro et l'exécution}




\section{Conclusion}
\todo{Ouverture sur le fait qu'un meta-protocole serait très intéressant à
  ajouter, mais à quel prix?}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Système de coroutines}
\todo{Système de threads offerts ne sont pas toujours
  satisfaisant. Mentalité Scheme: au lieu de contraindre ce qu'on veut
  faire en fonction de ce qui nous est offert, étendre le langage pour
  nous permettre de faire ce que l'on veut et surtout de la manière
  désirée.}

\todo{Implantation de son propre système: contrôle fin du comportement
  de threads}

\todo{Parler de Termite: Calcul distribué sur plusieurs
  noeuds. Synchronisation par passage de message. Communication via
  TCP/IP.}

\todo{Motivation de l'utilisation de coroutines (contrôle exact sur le
  flot de contrôle == système toujours dans un état consistant).}

\section{Description du langage}
\todo{Idée sur nos coroutines}

\todo{Systèmes récursifs}

\todo{Timers: abstraction du temps écoulé permettant l'accélération ou
  le ralentissement de l'exécution d'une simulation.}

\subsection{Création de coroutines}
\todo{Création d'une coroutine détachée du système: (new corout <id>
  <thunk>)}

\todo{intégrée au système via le démarrage (boot) ou via une autre
  coroutine (spawn-brother)}

\subsection{Manipulation du flot de contrôle}
\subsubsection{yield} 
\todo{Transfert à la prochaine coroutine}

\subsubsection{super-yield} 
\todo{Transfert au prochain système de coroutine (frère du système courant).}

\subsubsection{terminate-corout, kill-all!, super-kill-all!}
\todo{Terminaison de coroutines. }

\subsubsection{sleep-for}
\todo{Sommeil pour un temps prédéterminé.}

\subsubsection{continue-with}
\todo{Continuation de la coroutine.}

\subsubsection{spawn-brother, spawn-brother-thunk}
\todo{Démarrage de nouvelles coroutines.}

\subsubsection{Composition of coroutines}
\todo{Compositions ou séquençage de coroutine}

\subsection{Système de communication inter coroutines}
\subsubsection{!} 
\todo{Envoi de message à une coroutine}

\subsubsection{?}
\todo{Réception d'un message bloquante (avec possibilité de timeout)}

\subsubsection{??}
\todo{Réception sélective de message bloquante (avec possibilité de timeout)}

\subsubsection{recv, dynamic msg handlers}
\todo{Forme spéciale permettant la réception sélective de messages via
  un \og pattern matching \fg qui permet une notation concise et
  l'utilisation aisée du contenu des messages reçus.}

\subsubsection{Messaging lists}
\todo{Système permettant de regrouper des coroutines et de leurs
  diffuser des messages. }

\subsection{Démarrage du système}
\subsubsection{simple-boot}
\todo{Démarrage rapide du système.}

\subsubsection{boot}
\todo{Démarrage permettant de spécifier un timer spécifique à
  l'utilisation et une fonction personnalisée effectuant la gestion
  des valeurs de retour des coroutines.}

\todo{Systèmes cascadés?}


\section{Implantation}

\subsection{Implantation des coroutines}

\todo{Structure de données}

\todo{États d'une coroutines}

\subsection{Scheduler}
\todo{Abstraction du temps via timer}

\todo{États du scheduler}

\todo{Algorithme de scheduling}

\subsection{Système de messagerie}
\todo{Structures de données}

\todo{Envoi de messages}

\todo{Réception de messages}

\todo{Macro recv}


\section{Conclusion}
\todo{Ouverture sur le profilage des coroutine}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Évaluation et expériences}

Développement de jeu fait ayant comme but de trouver les problèmes
rencontrés durant la création de jeux vidéo et de proposer des
méthodes pour résoudre ces problèmes.

Aussi, on cherche à identifier les avantages que nous a fourni Scheme
et à identifier les incovénients que pose l'utilisant du langage
Scheme pour le développement de ces jeux.

Débute par un jeu simple afin de trouver les problèmes de base et
trouve des solutions à ces problèmes.

Ensuite, un deuxième jeu a été écrit afin de consolider les solutions
trouvées précédemment et de potentiellement trouver d'autres problèmes
reliés aux nouvelles complexité présentent dans ce deuxième jeu.

\section{Développement de \og Space Invaders \fg}

\subsection{Objectifs}
\todo{Expérimentation avec un jeu très simple}

\todo{Trouver les problèmes fondamentaux pour le développement de jeux}

\todo{Tenter de les résoudre}

\subsection{Version initiale}
\todo{Premier jet dans le but de trouver des problèmes potitiels}

\begin{itemize}
\item Comment faire des animations? => CPS
\item Comment concevoir une partie a 2 joueurs? => coroutines
\item Difficulté à décrire la résolution de collision de manière
  efficace 
\item Est-il possible d'écrire le comportement d'une entité de manière
  indépendante, \ie que le code soit centralisé dans une même
  fonction?
\end{itemize}

\subsection{Version orientée objet}
\todo{Motivation: Utilisation de fonctions génériques}

\todo{Hierarchie de classe}

\todo{Code Highlight: Résolution de collisions}


\subsection{Version avec système de co-routine}
\todo{Motivation: Intégrer les coroutines a chaque objet de manière à
  ce que chaque instance soit une entité à part entière qui doit régir
  son propre comportement.}

\todo{Difficultés: synchronisation des entités}

\todo{Code Highlight: synchronisation des invaders}


\subsection{Conclusion}
\todo{Trouvé plusieurs problèmes et pu résoudres ces derniers}

\todo{Utilisation d'un système object a grandement contribué à
  améliorer le code du jeu.}

L'intégration du système de coroutines aux objets du jeu a causé plus
de problème qu'elle en a résolu. L'utilisation des coroutines serait
mieux d'être limité à l'implantation du jeu multijoueur.

\todo{ouverture: Essayer ces techniques dans un jeu plus complexe pour
  voir si elles sont toujours valides}


\section{Développement de \og Lode Runner \fg}
\subsection{Objectifs}
\todo{Jeux plus complexe: plus d'interaction du joueur, intelligence
  artivicielle, niveaux, schema d'animations plus complexe, etc...}

\todo{Utiliser ce qui semblait de meilleur dans space-invaders de
  manière a non seulement confirmer la pertinance de ces methodes,
  mais aussi a potentiellement en developper de nouvelles dû aux
  nouvelles contraintes de ce jeu.}

\subsection{Synchronisation}
\todo{Utilisation du concept de frame pour faire la synchro. (manière
  traditionnelle) Réduit de beaucoup la complexité.}

\todo{Danger si le framerate varie, la vitesse du jeu varie.}

\subsection{Machines à états}
\todo{Utiliation des fonctions génériques}

\todo{Utilisez un LSD pour ca??? Des idées?}

\subsection{Intelligence Artificielle}
\subsubsection{À venir...}

\subsection{Conclusion}
\subsubsection{À venir...}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\chapter{Mesures de performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Travaux reliés}

Dans un premier temps, il serait intéressant de comparer les
différents langages utilisés dans l'industrie du jeu vidéo avec Scheme
afin d'en faire ressortir les différences. Ces différences mènent
directement à une méthode de développement qui seront complètement
différentes.

Scheme a déjà été utilisé pour produire des jeux vidéo commerciaux de
très bonne qualité. Certains seront cités et une revue de l'expérience
acquise par les développeurs sera exposée.

\section{Comparaison de langages}

\subsection{Lua}
Langage utilisé très fréquemment pour effectuer le \og scripting \fg
dans les jeu vidéo.

Differences entre lua et Scheme
\begin{itemize}
\item Lua est de petite taille en mem
\item ..
\end{itemize}

\subsection{C++}
Langage principal de développement de jeu vidéo en industrie.

Differences entre Scheme et C++
\begin{itemize}
\item Gestion memoire manuelle vs GC
\item méthode surdéfinies vs fonctions génériques
\item ...
\end{itemize}


\section{Jeux en Lisp}

\subsection{QuantZ}
Jeu de type \og casual \fg de très bonne qualité écrit presque
entièrement en Scheme.

À voir avec Robert

FRP?

Techniques anti-gc

Delegation de fermetures

\subsection{Naughty Dogz}
Compagnie très connue associée à Sony qui utilisent Scheme pour
produire leurs jeux vidéo.

\subsubsection{GOAL}
Compilateur Scheme utilisé pour produire les jeux sur PlayStation 2

%% http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
%% http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\begin{itemize}
\item http://en.wikipedia.org/wiki/Game\_Oriented\_Assembly\_Lisp
\item http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\end{itemize}

\subsubsection{Drake's uncharted Fortune}

%%http://bc.tech.coop/blog/060118.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}


L'expérience d'écriture de ces jeux aura permis de faire le point sur
les avantages et les inconvénients de l'utilisation d'un langage tel
que Scheme pour le développement de jeu vidéo.


\begin{itemize}
  \item[+] puissance d'expression / d'abstraction
  \item[+] langage dynamique (développement en-direct, malléabilités)
  \item[+] création de langages spécifiques au domaine

  \item[-] Garbage Collection et sur-allocation
  \item[-] Profilage plus difficile avec des LSD (pour Gambit-C et statprof)
  \item[-] Balance entre abstraction et efficacité
\end{itemize}


%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chapter{Bibliographie}

\setstretch{1}
\bibliographystyle{unsrt} %% or maybe plain or abbrv
\bibliography{memoire}

%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
% TODO: ce compteur doit être ajusté à la main 
% \setcounter{page}{99}

%% \chapter{Code des exemples}

%% \section{Compte de banque}

%% \subsection{Compte de banque en Java}\label{account_java}

%% \subsubsection{Classe Account}
%% \codeinput{bank/Account.java}

%% \subsubsection{Interface RemoteAccount}
%% \codeinput{bank/RemoteAccount.java}

%% \subsubsection{Classe LogRecord}
%% \codeinput{bank/LogRecord.java}

%% \subsubsection{Classe AccountServer}
%% \codeinput{bank/AccountServer.java}

%% \subsubsection{Classe AccountClient}
%% \codeinput{bank/AccountClient.java}

%% %% \subsection{Compte de banque en Termite}\label{account_termite}
%% %% \schemeinput{bank/account.scm}

%% \newpage 

%% \section{Serveur générique: genserver.scm}
%% \schemeinput{genserver.scm}

%% %% \section{Superviseur générique: supervisor.scm}
%% %% 
%% %% \schemeinput{supervisor.scm}

%% \newpage

%% \section{Définition de type}\label{define_termite_type}
%% \schemeinput{deftype.scm}

%% \newpage
%% \chapter{Code des tests de performance}

%% \section{Fibonacci}

%% \subsection{Scheme}\codeinput{bench/fib.scm}
%% \subsection{Erlang}\codeinput{bench/fib.erl}

%% \newpage
%% \section{Takeuchi}

%% \subsection{Scheme}\codeinput{bench/tak.scm}
%% \subsection{Erlang}\codeinput{bench/tak.erl}

%% \newpage
%% \section{Inversion naïve}
%% \subsection{Scheme}\codeinput{bench/nrev.scm}
%% \subsection{Erlang}\codeinput{bench/nrev.erl}

%% \newpage
%% \section{Quick Sort}
%% \subsection{Scheme}\codeinput{bench/qsort.scm}
%% \subsection{Erlang}\codeinput{bench/qsort.erl}


%% \newpage
%% \section{Smith Waterman}
%% \subsection{Scheme}\codeinput{bench/smith.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/smith.erl}

%% \newpage
%% \section{Self}
%% \subsection{Termite}\codeinput{bench/self.scm}
%% \subsection{Gambit}\codeinput{bench/self_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/self.erl}

%% \newpage
%% \section{Spawn}
%% \subsection{Termite}\codeinput{bench/spawn.scm}
%% \subsection{Gambit}\codeinput{bench/spawn_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/spawn.erl}

%% \newpage
%% \section{Ring}

%% \subsection{Termite}\codeinput{bench/ring.scm}
%% \newpage
%% \subsection{Gambit}\codeinput{bench/ring_gambit.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/ring.erl}

%% \newpage
%% \section{Ping-pong}

%% \subsection{Termite}\codeinput{bench/pingpong.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/pingpong.erl}


%% \newpage
%% \section{``Migration''}

%% \subsection{Termite}\codeinput{bench/migrate.scm}

\end{document}
