\documentclass[12pt,oneside,letterpaper,francais]{book}

%% \documentclass[12pt]{report}

\usepackage[french, english]{babel}
%\usepackage{isolatin1}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{setspace}
\usepackage{verbatim}

\usepackage{udem_these_fr}

\newcommand{\todo}[1]{[TODO: {\it #1}]}

%\newcommand{\object}[1]{$\#<#1 \ldots>$}
\newcommand{\object}[1]{{\it #1}}

\input{r5rscommands.tex}

\newcommand{\codeinput}[1]{\begin{singlespace}\verbatiminput{#1}\end{singlespace}}
\newcommand{\schemeinput}[1]{\begin{schemecode}\input{#1}\end{schemecode}}

\newcommand{\scheme}[1]{\selectlanguage{english}{\tt #1}\selectlanguage{french}}
\newcommand{\schemeresult}[1]{{\tt #1}}

%% \hyphenation{ex-écu-tion} %% marche pas a cause de l'accent

\title{Développement de jeux vidéo en Scheme}

% remplir les champs...
\Auteur{David}{St-Hilaire}

\President{M.}{Mostapha}{Aboulhamid}{Ph.D.}

\Directeur{M.}{Marc}{Feeley}{Ph.D.}

\Membres{1}{M.}{Yann-Gaël}{Guéhéneuc}{Ph.D.}

%pour le doctorat seulement

%examinateur externe
%\Membres{2}{M.}{Membre}{deux}{Ph.D.}
%
%%representant du doyen de la FES
%\Membres{3}{M.}{Membre}{trois}{Ph.D.}

%Pour un doctorat, changer simplement \MSc par \PhD
%titre: 15 mots, max. 175 caractère
\MSc{Dévelopment de jeux vidéo en Scheme}
    {}
    {d'informatique et de recherche op\'{e}rationnelle}
    {informatique}
    {Décembre}
    {2009}

\setstretch{2}
\begin{document}

\setcounter{page}{1}
 \PagesCouverture

\resume


\vspace{2em}

\noindent {\bf Mots clés}: Language de programmation fonctionnels,
Scheme, jeux vidéo, programmation orientée objet.

\abstract

\selectlanguage{english}


\vspace{2em}

\noindent {\bf Keywords}: Functional programming languages, Scheme,
video games, object oriented programming.


\selectlanguage{french}

%% \maketitle
 
\tabledesmatieres

% \listedestableaux

\listedesfigures

% \listedesannexes

\remerciements

blablabla

% \preface
% 
% Préface...

\debutchapitres

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

L'industrie du jeu vidéo devient de plus en plus importante dans le
domaine de l'informatique. Cette croissance est bien reflétée par
l'augmentation de 28\% des revenus provenant de la vente de jeux vidéo
aux États-Unis durant l'année 2007~\cite{NPD_Games_2007}. La place
occupée par l'industrie du jeu vidéo durant cette même année s'estime
à 76\% du marché de tous les logiciels vendus~\cite{NPD_Soft_2008}. 

L'engouement du marché du jeu vidéo ouvre les portes aux compagnies
oeuvrant dans le domaine à repousser les limites de l'état de l'art du
développement de jeux. La compétition est féroce et donc beaucoup
d'efforts doivent être appliqués à la création d'un jeu afin qu'il se
démarque de la masse et devienne un nouveau \og Blockbuster Hit
\fg. Le président de la compagnie Française UbiSoft estime que le coût
moyen de développement d'un jeu sur une console moderne se situe entre
20 et 30 millions de dollars~\cite{cbc_ubisoft}. Si l'on estime le
salaire moyen d'un artiste ou d'un développeur de jeu vidéo à 60
000\$/année, cela reviendrait à un travail d'environ 300 à 500
hommes/année.

Puisque la création d'un jeu vidéo peu nécessiter autant d'efforts, il
semble très intéressant de vouloir tenter de faciliter le
développement de ces derniers. Avec autants d'efforts mis en place,
même une petite amélioration sur le cycle de développement peu
engendrer une diminution énorme des coûts de production et aussi
améliorer la qualité des environnements utilisés par les développeurs.

Jusqu'à ce jour, la grande majorité des jeux vidéo sont écrit dans des
langages de relativement bas niveau, comme par exemple en C, C++ ou
encore C\#~\cite{CSHARP_SPEC}. Ces langages sont généralement utilisés
parce que la main d'oeuvre est facilement accessible et sont déjà des
langages bien établis. 

Les langages de haut niveaux sont généralement caractérisés par le
fait qu'ils font une bonne abstraction du système utilisé et
permettent d'utiliser ces abstraction de manière naturelle et donc
facilitent le travail de programmation. Le coût de ces abstractions se
répercute généralement en un coût de performance du programme. Dans le
passé, la performance était critique dans les jeux vidéo, mais les
consoles modernes sont devenues plus performantes que la plus part des
ordinateurs personnels et donc, actuellement la performance n'est plus
aussi important de nos jours. Aussi, les améliorations de le domaine
de la compilation de langages de haut niveaux font en sorte que les
performances de ces systèmes sont comparables à l'utilisation de
langages de plus bas niveaux.

Ainsi, l'utilisation de langages de plus haut niveaux pourrait
potentiellement améliorer les délais occasionnés par les cycles de
développement des jeux en permettant aux programmeurs et designers de
s'exprimer plus facilement. Le langage de programmation
Scheme~\cite{R5RS} semble être un bon candidat en tant que langage de
haut niveau. En effet, le langage Scheme offre les fonctionnalités de
haut niveau suivantes:

\begin{itemize}
\item Typage dynamique
\item Fonctions de premier ordre
\item Système de macros évolué
\item Accès direct aux continuations du calcul
\item Un système de déboggage très efficace
\end{itemize}

Les particularités du langages Scheme sont discutées plus en détail
dans le chapitre \ref{Chap:Scheme}. 

\todo{introduire Gambit-C}

Il semble donc qu'une utilisation judicieuse de ce langage de
programmation pourrait faire bénéficier des projets aussi complexes
que le sont les productions de jeux vidéo.

\section{Problématique}
Ce mémoire de maîtrise vise à répondre à la problématique suivante:

\begin{quote}
  Quelles sont les forces et les faiblesses du langages de
  programmation Scheme pour le développement de jeux vidéo.
\end{quote}

\section{Méthodologie}

%% Afin de pouvoir répondre à la problématique posée, nous avons utilisé
%% l'approche

%% \begin{itemize}
%% \item Dev 1er jeu simple pour determiner les besoins pour Scheme
%% \item Augmenter Scheme pour repondre a ces besoins
%% \item Ecrire un nouveau jeu utilisant les techniques developpees pour le 1er jeu
%% \end{itemize}

Afin de pouvoir répondre à la problématique posée, nous avons étudié
les caractéristiques de Scheme et du compilateur Gambit-C, ainsi que
les besoins au niveau du développement de jeux vidéo. Concurremment, 2
jeux ont été développés pour raffiner nos approches et les évaluer
dans un contexte réel.

Le premier jeux a servi de platforme d'exploration permettant
d'élaborer une méthodologie qui semble efficace pour le développement
de jeux. Afin d'obtenir une telle méthodologie, plusieurs itérations
de développement ont été effectuées, chacune permettant d'explorer de
nouveaux aspects sur la manière de résoudre les problématiques
associées à la création de jeux, comme par exemple comment arriver à
synchroniser des entités dans le jeux ou comment arriver à décrire
efficacement un système de détection et de résolution de collisions.

Suite à l'écriture de ce jeu, un deuxième jeu, plus complexe, a été
développé afin de consolider les techniques précédemment utilisées et
étendre ces techniques dans le cadre de se nouveau jeu comportant de
nouveaux défi, comme l'implantation d'une intelligence artificielle.



\section{Aperçu du mémoire}
Ce mémoire est composé de quatre parties. La première partie est une
introduction qui traite de programmation fonctionnelle, du langage de
programmation Scheme et des outils de développement disponibles, en
particulier le compilateur Gambit-C. Ce chapitre donne un aperçu
général de ces langages et permet de saisir les concepts fondamentaux
du langage Scheme. Une présentation de l'industrie des jeux vidéo et
des défis découlant du développement suit ce chapitre.

La deuxième partie du mémoire porte sur des extensions faites au
langage Scheme qui ont été utilisées dans le but d'améliorer le
développement de jeux vidéo. On y présente la programmation orientée
objet et un système d'objets conçu pour répondre aux besoins de la
programmation de jeux vidéo. Un système de coroutines conçu dans les
mêmes optiques est également présenté.

La troisième partie du mémoire porte sur l'expérience acquise par
l'auteur en effectuant l'écriture de 2 jeux vidéo simples, mais
possédant suffisamment de complexité pour exposer les problèmes
associés à la création de jeux vidéo et comment tirer profit du
langage de programmation Scheme pour résoudre ces problèmes. Une
présentation des travaux reliés aux résultats présentés suit ce
dernier chapitre. On y parle de l'utilisation de d'autres langages
pour le développement de jeux vidéo et cite des exemple d'utilisation
du langage Scheme dans des jeux vidéo commerciaux et de l'expérience
tirée de cette utilisation par les développeurs.

Finalement, une conclusion apporte la lumière sur la problématique
exposée dans ce mémoire. Le point sur l'expérience acquise pour le
développement de jeux vidéo en Scheme y est fait et les avantages et
inconvénients ou problèmes obtenus seront exposés.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Développement de jeux vidéo}

Importance du marche des JV

Diversite des jeux (genres, plates-formes)

Charactéristiques de jeux modernes

Les jeux vidéo font parti d'un domaine de l'informatique en pleine
effervescence grâce à une demande constante de nouveaux produits. Ces
produits possèdent plusieurs caractéristiques de qualité auxquelles
les consommateurs s'attendent à obtenir en effectuant l'acquisition
d'un nouveau titre. Ces attentes du consommateur peuvent se traduire
par les besoins suivant:

mettre ici une liste des attentes pour un jeu moderne

\section{Historique}

%% http://en.wikipedia.org/wiki/History_of_video_games

\subsection{préhistoire 1948-1970}
CRT games, Mainframe games

\subsection{Système arcade 1970-1985}
Pong, Space Invaders, Pac-Man

\subsection{Premières consoles 1972-1984}
Magnavox Odyssey, Atari XX00 et ColecoVision

\subsection{Ordinateurs personnels 1977-...}
Évolution parallèle constante

Toujours été jusqu'à la venu des console modernes la plateforme offrant les meilleurs performances.

\subsection{Consoles portables 1980-...}
GameBoy etc...

\subsection{Consoles intermédiaires 1984-2006}
NES, SNES, N64, GameCube

\subsection{Consoles modernes 2005-...}
Interfaces plus 'casual' = Wii

Consoles très performantes




\section{Contraintes de programmation}

\subsection{fluidité}

\subsubsection{Taux de rafraîchissement}
\subsubsection{Réponse quasi temps réelle}

\subsection{Modularité}

\subsubsection{Complexité des jeux ... gros logiciels}
\subsubsection{Développement itératif ... plusieurs modifications du système}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Le langage Scheme}
\label{Chap:Scheme}

Choix du langage influence beaucoup la structure du code, le manière
de développer le logiciel, etc...

Scheme est un langage qui semble être peu utilisé dans des produits
commerciaux.

d'autres idées?

Référence temporaire pour pas faire planter le makefile\cite{SICP}

\section{Héritage de LISP}
\subsection{Histoire de LISP}
McCarthy, GC, List Processing, AI...

Common LISP = Grosse Bébitte

\subsection{Avènement de Scheme}
Épuration de LISP à l'essence du langage

évolution du langage via RNRS, SRFIs

simplicité du langage, beaucoup d'extension disponibles 

\subsection{Langages inspirés de Scheme}
Javascript, Ruby: lang de scripting. Concept de fermetures

Java??

\section{Programmation fonctionnelle}
\subsection{Distinction}
 Fonctions sont des données de premier ordre

 Fonctions d'ordres supérieures (avec exemples)

\subsection{Programmation fonctionnelle pure}
Pas de mutation. Comme des blocs lego

Haskell, ML

Exemple en Scheme


\subsection{Effets de bords dans Scheme}
Entrees sorties (variables à portée dynamique)
Mutations de variables


\section{Macros}
\subsection{Introduction}
Discussion sur les macros de C et leurs limitations: permet de faire
des abstractions dans le code résultant une modification du code
source avant la compilation, mais uniquement limité à du remplacement
de code.

Explication des macros scheme: Code source == données scheme, dispose
d'une pré-évaluation permettant de prendre du code source en entré et
de généré du code source (toujours sous forme de listes (données
Scheme)). Revient a faire une manipulation d'ASA.

Dispose de toute la puissance de calcul durant l'expansion :)

\subsection{Exemples simples}

macro inc

macro while

\subsection{Problème de l'hygiène des macros}

Capture de nom intentionnelle, ou non intentionnelle. 

Différentes formes spéciales (define-macro, define-syntax)



\section{Continuations}
\subsection{Introductions du sujet et explications}
En C, continuation equiv au code situé à l'adresse de retour de la
fonction exécutée.

Explication de l'ordre dévaluation en Scheme.

Continuation d'un programme simple en Scheme. (+ 1 (- [f x y] 2)) :
continuation de l'appel à f est la soustraction du résultat par deux,
puis l'on ajoute à 1 se résultat. Eq à (lambda (res-f) (+ 1 (- res-f 2))).

\subsection{Réification de continuations}
Explication de call-with-current-continuation permettant de faire
surfacer une continuation.

\subsection{Exemples d'utilisations}
\subsubsection{Échappement au flux de contrôle}
Utilisation comme un return

\subsubsection{Système de coroutine}
Exemple du cours de Marc

\subsection{Forme d'écriture de code en CPS}
Expliquer la différence entre un appel terminal et un appel
non-terminal. Expliquer comment les appels terminaux peuvent être
optimisés (requis en Scheme).

Écrire le code de manière à rendre explicite le passage et les appels
de continuations. Toujours des appels terminaux. Transformation
souvent utilisée par les compilateurs pour implanter l'optimisation
d'appels terminaux.

\subsection{Exemple d'implantation}
Exemple du cours de Marc

blabla


\section{Dynamisme du langage}
Typage dynamique vs typage statique

Exemple de code utilisant le typage dynamique.

Evaluation dynamique de code avec load ou eval. idées?

Langages comme C++ favorisent bcp de focuser sur la conceptions des
classes. Implique une structure rigide qui se doit d'être bien conçu
depuis le départ.

Langages plus dynamiques permettent des cycles de prototypage rapide
en apportant beaucoup de flexibilité aux développeurs.


\section{Gestion mémoire automatique}
\subsection{Motivation}
Gestion mémoire manuelle ou semi-automatique causent énormément de
problèmes de fuites de mémoire (ou de pointeurs fous).

En connaissant les racines, on peut automatiser la récupérations de
mémoire, au coût d'un certain temps de calcul.

Date des premières version de LISP.



\subsection{Survol des techniques}
Mark and sweep

Stop and copy

GC générationnels

GC temps réels ou incrémentaux



\section{Débuggage}
Possibilité de pouvoir exécuter du code arbitraire lors d'un crash

Possibilité de pouvoir inspecter chacune des frames de la pile de
continuactions afin de pouvoir obtenir de l'info sur l'environnement
de celui-ci, l'endroit dans le code source où la continuation se
trouve et même de pouvoir exécuter du code dans l'environnement d'une
continuation de la pile choisie.

Possibilité de faire le déboggage à distance (ex: iPhone)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation orientée objet}

Parler des define-type de Gambit-C et du SRFI-9

Approche traditionnelle de la prog OO: Surdéfinition de méthodes de
classe, héritage simple, polymorphisme, etc...

Parler de CLOS: intégré à Common LISP, fonctions génériques, héritage
multiple

Besoins pour jeux vidéo

\section{Description du langage}
Langage orienté objet qui a pour but d'être efficace tout en apportant
l'expressivité offerte par la programmation orientée object à la CLOS.

Résumé des fonctionnalités
\begin{itemize}
\item Accès aux membres rapide
\item Héritage multiple
\item Polymorphisme
\item Fonctions génériques à \og dispatch \fg multiple
\end{itemize}

\subsection{Définition de classes}
Compatibilité avec les define-type

Définitions simples (instance slots et class slots)

Héritages des membres

Utilisation de hook sur les slots

Constructeurs


\subsection{Définition de fonctions génériques}
Dispatch simple

Dispatch multiple (avec les problèmes reliés à la résolution de la méthode à choisir)

call-next-method

Type '*'

\subsection{Fonctions et formes spéciales utilitaires}

Vérifications manuelles de typages et introspections
(instance-object?, instance-of?, find-class?, get-class-id,
is-subclass?, get-supers)




\section{Implantation}
Apercu global: Utilisation de macros scheme pour effectuer la
génération de code nécessaire au fonctionnement du système.

Séparation entre le travail fait durant l'expantion macro et l'exécution

Passage d'informations entre le moment de l'expansion et l'exécution
(informations sur les classes, les fonctions génériques, etc...)

\subsection{Implantation de define-class}
Structures de données (descripteurs de classes, format des instances, etc..)

Polymorphisme: chaque index dans les descripteurs de classes sont
orthogonaux (implique que les descripteurs grossissent linéairement en
fonction du nombre de classes) et passage aux classes enfants des
indexes utilisés par les parents.

Constructeurs et describe comme fonctions génériques

\subsection{Implantation de define-generic}
Registre des méthode: Conservations d'informations sur les fonctions
génériques et leurs instances 

Implantation du polymorphisme des fonctions génériques

Implantation du call-next-method faite avec l'utilisation de variables
à portée dynamique

Coût de l'utilisation des fonctions génériques

\subsection{Implantation de define-method}
Stockages des fermetures durant l'expansion macro et l'exécution




\section{Conclusion}
Ouverture sur le fait qu'un meta-protocole serait très intéressant à
ajouter, mais à quel prix?



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Système de coroutines}
Système de threads offerts ne sont pas toujours
satisfaisant. Mentalité Scheme: au lieu de contraindre ce qu'on veut
faire en fonction de ce qui nous est offert, étendre le langage pour
nous permettre de faire ce que l'on veut et surtout de la manière
désirée.

Implantation de son propre système: contrôle fin du comportement de
threads

Parler de Termite: Calcul distribué sur plusieurs
noeuds. Synchronisation par passage de message. Communication via
TCP/IP.

Motivation de l'utilisation de coroutines (contrôle exact sur le flot
de contrôle == système toujours dans un état consistant).

\section{Description du langage}
Idée sur nos coroutines

Systèmes récursifs

Timers: abstraction du temps écoulé permettant l'accélération ou le
ralentissement de l'exécution d'une simulation.

\subsection{Création de coroutines}
Création d'une coroutine détachée du système:
(new corout <id> <thunk>)

intégrée au système via le démarrage (boot) ou via une autre coroutine
(spawn-brother)

\subsection{Manipulation du flot de contrôle}
\subsubsection{yield} 
Transfert à la prochaine coroutine

\subsubsection{super-yield} 
Transfert au prochain système de coroutine (frère du système courant).

\subsubsection{terminate-corout, kill-all!, super-kill-all!}
Terminaison de coroutines. 

\subsubsection{sleep-for}
Sommeil pour un temps prédéterminé.

\subsubsection{continue-with}
Continuation de la coroutine.

\subsubsection{spawn-brother, spawn-brother-thunk}
Démarrage de nouvelles coroutines.

\subsubsection{Composition of coroutines}
Compositions ou séquençage de coroutine

\subsection{Système de communication inter coroutines}
\subsubsection{!} 
Envoi de message à une coroutine

\subsubsection{?}
Réception d'un message bloquante (avec possibilité de timeout)

\subsubsection{??}
Réception sélective de message bloquante (avec possibilité de timeout)

\subsubsection{recv, dynamic msg handlers}
Forme spéciale permettant la réception sélective de messages via un
\og pattern matching \fg qui permet une notation concise et
l'utilisation aisée du contenu des messages reçus.

\subsubsection{Messaging lists}
Système permettant de regrouper des coroutines et de leurs diffuser
des messages. 

\subsection{Démarrage du système}
\subsubsection{simple-boot}
Démarrage rapide du système.

\subsubsection{boot}
Démarrage permettant de spécifier un timer spécifique à l'utilisation
et une fonction personnalisée effectuant la gestion des valeurs de
retour des coroutines.

Systèmes cascadés?


\section{Implantation}

\subsection{Implantation des coroutines}

Structure de données

États d'une coroutines

\subsection{Scheduler}
Abstraction du temps via timer

États du scheduler

Algorithme de scheduling

\subsection{Système de messagerie}
Structures de données

Envoi de messages

Réception de messages

Macro recv


\section{Conclusion}
Ouverture sur le profilage des coroutine


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Évaluation et expériences}

Développement de jeu fait ayant comme but de trouver les problèmes
rencontrés durant la création de jeux vidéo et de proposer des
méthodes pour résoudre ces problèmes.

Aussi, on cherche à identifier les avantages que nous a fourni Scheme
et à identifier les incovénients que pose l'utilisant du langage
Scheme pour le développement de ces jeux.

Débute par un jeu simple afin de trouver les problèmes de base et
trouve des solutions à ces problèmes.

Ensuite, un deuxième jeu a été écrit afin de consolider les solutions
trouvées précédemment et de potentiellement trouver d'autres problèmes
reliés aux nouvelles complexité présentent dans ce deuxième jeu.

\section{Développement de \og Space Invaders \fg}

\subsection{Objectifs}
Expérimentation avec un jeu très simple

Trouver les problèmes fondamentaux pour le développement de jeux

Tenter de les résoudre

\subsection{Version initiale}
Premier jet dans le but de trouver des problèmes potitiels

\begin{itemize}
\item Comment faire des animations? => CPS
\item Comment concevoir une partie a 2 joueurs? => coroutines
\item Difficulté à décrire la résolution de collision de manière
  efficace 
\item Est-il possible d'écrire le comportement d'une entité de manière
  indépendante, i.e. que le code soit centralisé dans une même
  fonction?
\end{itemize}

\subsection{Version orientée objet}
Motivation: Utilisation de fonctions génériques

Hierarchie de classe

Code Highlight: Résolution de collisions


\subsection{Version avec système de co-routine}
Motivation: Intégrer les coroutines a chaque objet de manière à ce que chaque instance soit une entité à part entière qui doit régir son propre comportement.

Difficultés: synchronisation des entités

Code Highlight: synchronisation des invaders


\subsection{Conclusion}
Trouvé plusieurs problèmes et pu résoudres ces derniers

Utilisation d'un système object a grandement contribué à améliorer le
code du jeu.

L'intégration du système de coroutines aux objets du jeu a causé plus
de problème qu'elle en a résolu. L'utilisation des coroutines serait
mieux d'être limité à l'implantation du jeu multijoueur.

ouverture: Essayer ces techniques dans un jeu plus complexe pour voir
si elles sont toujours valides


\section{Développement de \og Lode Runner \fg}
\subsection{Objectifs}
Jeux plus complexe: plus d'interaction du joueur, intelligence
artivicielle, niveaux, schema d'animations plus complexe, etc...

Utiliser ce qui semblait de meilleur dans space-invaders de manière a non seulement confirmer la pertinance de ces methodes, mais aussi a potentiellement en developper de nouvelles dû aux nouvelles contraintes de ce jeu.

\subsection{Synchronisation}
Utilisation du concept de frame pour faire la synchro. (manière
traditionnelle) Réduit de beaucoup la complexité.

Danger si le framerate varie, la vitesse du jeu varie.

\subsection{Machines à états}
Utiliation des fonctions génériques

Utilisez un LSD pour ca??? Des idées?

\subsection{Intelligence Artificielle}
\subsubsection{À venir...}

\subsection{Conclusion}
\subsubsection{À venir...}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\chapter{Mesures de performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Travaux reliés}

Dans un premier temps, il serait intéressant de comparer les
différents langages utilisés dans l'industrie du jeu vidéo avec Scheme
afin d'en faire ressortir les différences. Ces différences mènent
directement à une méthode de développement qui seront complètement
différentes.

Scheme a déjà été utilisé pour produire des jeux vidéo commerciaux de
très bonne qualité. Certains seront cités et une revue de l'expérience
acquise par les développeurs sera exposée.

\section{Comparaison de langages}

\subsection{Lua}
Langage utilisé très fréquemment pour effectuer le \og scripting \fg
dans les jeu vidéo.

Differences entre lua et Scheme
\begin{itemize}
\item Lua est de petite taille en mem
\item ..
\end{itemize}

\subsection{C++}
Langage principal de développement de jeu vidéo en industrie.

Differences entre Scheme et C++
\begin{itemize}
\item Gestion memoire manuelle vs GC
\item méthode surdéfinies vs fonctions génériques
\item ...
\end{itemize}


\section{Jeux en Lisp}

\subsection{QuantZ}
Jeu de type \og casual \fg de très bonne qualité écrit presque
entièrement en Scheme.

À voir avec Robert

FRP?

Techniques anti-gc

Delegation de fermetures

\subsection{Naughty Dogz}
Compagnie très connue associée à Sony qui utilisent Scheme pour
produire leurs jeux vidéo.

\subsubsection{GOAL}
Compilateur Scheme utilisé pour produire les jeux sur PlayStation 2

%% http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
%% http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\begin{itemize}
\item http://en.wikipedia.org/wiki/Game\_Oriented\_Assembly\_Lisp
\item http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\end{itemize}

\subsubsection{Drake's uncharted Fortune}

%%http://bc.tech.coop/blog/060118.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}


L'expérience d'écriture de ces jeux aura permis de faire le point sur
les avantages et les inconvénients de l'utilisation d'un langage tel
que Scheme pour le développement de jeu vidéo.


\begin{itemize}
  \item[+] puissance d'expression / d'abstraction
  \item[+] langage dynamique (développement en-direct, malléabilités)
  \item[+] création de langages spécifiques au domaine

  \item[-] Garbage Collection et sur-allocation
  \item[-] Profilage plus difficile avec des LSD (pour Gambit-C et statprof)
  \item[-] Balance entre abstraction et efficacité
\end{itemize}


%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chapter{Bibliographie}

\setstretch{1}
\bibliographystyle{unsrt} %% or maybe plain or abbrv
\bibliography{memoire}

%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
% TODO: ce compteur doit être ajusté à la main 
% \setcounter{page}{99}

%% \chapter{Code des exemples}

%% \section{Compte de banque}

%% \subsection{Compte de banque en Java}\label{account_java}

%% \subsubsection{Classe Account}
%% \codeinput{bank/Account.java}

%% \subsubsection{Interface RemoteAccount}
%% \codeinput{bank/RemoteAccount.java}

%% \subsubsection{Classe LogRecord}
%% \codeinput{bank/LogRecord.java}

%% \subsubsection{Classe AccountServer}
%% \codeinput{bank/AccountServer.java}

%% \subsubsection{Classe AccountClient}
%% \codeinput{bank/AccountClient.java}

%% %% \subsection{Compte de banque en Termite}\label{account_termite}
%% %% \schemeinput{bank/account.scm}

%% \newpage 

%% \section{Serveur générique: genserver.scm}
%% \schemeinput{genserver.scm}

%% %% \section{Superviseur générique: supervisor.scm}
%% %% 
%% %% \schemeinput{supervisor.scm}

%% \newpage

%% \section{Définition de type}\label{define_termite_type}
%% \schemeinput{deftype.scm}

%% \newpage
%% \chapter{Code des tests de performance}

%% \section{Fibonacci}

%% \subsection{Scheme}\codeinput{bench/fib.scm}
%% \subsection{Erlang}\codeinput{bench/fib.erl}

%% \newpage
%% \section{Takeuchi}

%% \subsection{Scheme}\codeinput{bench/tak.scm}
%% \subsection{Erlang}\codeinput{bench/tak.erl}

%% \newpage
%% \section{Inversion naïve}
%% \subsection{Scheme}\codeinput{bench/nrev.scm}
%% \subsection{Erlang}\codeinput{bench/nrev.erl}

%% \newpage
%% \section{Quick Sort}
%% \subsection{Scheme}\codeinput{bench/qsort.scm}
%% \subsection{Erlang}\codeinput{bench/qsort.erl}


%% \newpage
%% \section{Smith Waterman}
%% \subsection{Scheme}\codeinput{bench/smith.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/smith.erl}

%% \newpage
%% \section{Self}
%% \subsection{Termite}\codeinput{bench/self.scm}
%% \subsection{Gambit}\codeinput{bench/self_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/self.erl}

%% \newpage
%% \section{Spawn}
%% \subsection{Termite}\codeinput{bench/spawn.scm}
%% \subsection{Gambit}\codeinput{bench/spawn_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/spawn.erl}

%% \newpage
%% \section{Ring}

%% \subsection{Termite}\codeinput{bench/ring.scm}
%% \newpage
%% \subsection{Gambit}\codeinput{bench/ring_gambit.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/ring.erl}

%% \newpage
%% \section{Ping-pong}

%% \subsection{Termite}\codeinput{bench/pingpong.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/pingpong.erl}


%% \newpage
%% \section{``Migration''}

%% \subsection{Termite}\codeinput{bench/migrate.scm}

\end{document}
