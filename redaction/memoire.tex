\documentclass[12pt,oneside,letterpaper,francais]{book}

%% \documentclass[12pt]{report}

\usepackage[french, english]{babel}
%\usepackage{isolatin1}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{setspace}
\usepackage{verbatim}

\usepackage{udem_these_fr}

\newcommand{\todo}[1]{[TODO: {\it #1}]}

%\newcommand{\object}[1]{$\#<#1 \ldots>$}
\newcommand{\object}[1]{{\it #1}}

\input{r5rscommands.tex}

\newcommand{\codeinput}[1]{\begin{singlespace}\verbatiminput{#1}\end{singlespace}}
\newcommand{\schemeinput}[1]{\begin{schemecode}\input{#1}\end{schemecode}}

\newcommand{\scheme}[1]{\selectlanguage{english}{\tt #1}\selectlanguage{french}}
\newcommand{\schemeresult}[1]{{\tt #1}}

%% \hyphenation{ex-écu-tion} %% marche pas a cause de l'accent

\title{Développement de jeux vidéo en Scheme}

% remplir les champs...
\Auteur{David}{St-Hilaire}

\President{M.}{Mostapha}{Aboulhamid}{Ph.D.}

\Directeur{M.}{Marc}{Feeley}{Ph.D.}

\Membres{1}{M.}{Yann-Gaël}{Guéhéneuc}{Ph.D.}

%pour le doctorat seulement

%examinateur externe
%\Membres{2}{M.}{Membre}{deux}{Ph.D.}
%
%%representant du doyen de la FES
%\Membres{3}{M.}{Membre}{trois}{Ph.D.}

%Pour un doctorat, changer simplement \MSc par \PhD
%titre: 15 mots, max. 175 caractère
\MSc{Dévelopment de jeux vidéo en Scheme}
    {}
    {d'informatique et de recherche op\'{e}rationnelle}
    {informatique}
    {Décembre}
    {2009}

\setstretch{2}
\begin{document}

\setcounter{page}{1}
 \PagesCouverture

\resume


\vspace{2em}

\noindent {\bf Mots clés}: Language de programmation fonctionnels,
Scheme, jeux vidéo, programmation orientée objet.

\abstract

\selectlanguage{english}


\vspace{2em}

\noindent {\bf Keywords}: Functional programming languages, Scheme,
video games, object oriented programming.


\selectlanguage{french}

%% \maketitle
 
\tabledesmatieres

% \listedestableaux

\listedesfigures

% \listedesannexes

\remerciements

blablabla

% \preface
% 
% Préface...

\debutchapitres

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{Chap:Intro}

L'industrie du jeu vidéo devient de plus en plus importante dans le
domaine de l'informatique. Cette croissance est bien reflétée par
l'augmentation de 28\% des revenus provenant de la vente de jeux vidéo
aux États-Unis durant l'année 2007~\cite{NPD_Games_2007}. La place
occupée par l'industrie du jeu vidéo durant cette même année s'estime
à 76\% du marché de tous les logiciels vendus~\cite{NPD_Soft_2008}. 

L'engouement du marché du jeu vidéo incite les compagnies oeuvrant
dans le domaine à repousser les limites de l'état de l'art du
développement de jeux. La compétition est féroce et donc beaucoup
d'efforts doivent être investis dans la création d'un jeu afin qu'il
se démarque de la masse et devienne un nouveau \og Blockbuster Hit
\fg. Le président de la compagnie Française UbiSoft estime que le coût
moyen de développement d'un jeu sur une console moderne se situe entre
20 et 30 millions de dollars~\cite{cbc_ubisoft}. Si l'on estime le
salaire moyen d'un artiste ou d'un développeur de jeu vidéo à 60
000\$ par année, cela reviendrait à un travail d'environ 300 à 500
hommes par année.

Puisque la création d'un jeu vidéo peu nécessiter autant d'efforts, il
semble très intéressant de vouloir tenter de faciliter le
développement de ces derniers. Avec autant d'efforts mis en place,
même une petite amélioration sur le cycle de développement peu
engendrer une diminution énorme des coûts de production et aussi
améliorer la qualité des environnements utilisés par les développeurs.

Jusqu'à ce jour, la grande majorité des jeux vidéo sont écrits à
l'aide de langages de relativement bas niveau, par exemple en C, C++
ou encore C\#~\cite{CSHARP_SPEC}. Ces langages sont généralement
utilisés parce qu'ils sont déjà bien établis et que la main d'oeuvre
est facilement accessible.

\todo{expliquer haut niveau / bas niveau}

Les langages de haut niveau sont généralement caractérisés par le fait
qu'ils font une bonne abstraction du système utilisé et permettent
d'utiliser celles-ci de manière naturelle. Elles facilitent donc le
travail de programmation. Le coût de ces abstractions se répercute
généralement en un coût de performance du programme. Dans le passé, la
performance était critique dans les jeux vidéo, mais les consoles
modernes sont devenues plus performantes que la plupart des
ordinateurs personnels. Actuellement la performance n'est donc plus
aussi important. Aussi, les améliorations du domaine de la compilation
de langages de haut niveau font en sorte que les performances de ces
systèmes sont comparables à l'utilisation de langages de plus bas
niveau.

Ainsi, l'utilisation de langages de plus haut niveau pourrait
potentiellement améliorer les délais occasionnés par les cycles de
développement des jeux en permettant aux programmeurs et designers de
s'exprimer plus facilement. Le langage de programmation
Scheme~\cite{R5RS} semble être un bon candidat en tant que langage de
haut niveau. En effet, le langage Scheme offre les fonctionnalités de
haut niveau suivantes:

\todo{Gardes les bullets ou changer en texte??}

\begin{itemize}
\item Typage dynamique
\item Fonctions de premier ordre
\item Système de macros évolué
\item Accès direct aux continuations du calcul
\item Un système de déboggage très efficace
\end{itemize}

Ces particularités du langage Scheme sont discutées plus en détail
dans le chapitre \ref{Chap:Scheme}.

Le système Gambit-C, l'une des implantations de Scheme les plus
performantes~\cite{GAMBIT_BENCHMARKS} sera utilisée pour effectuer les
expériences pratiques. Ce système comporte de nombreuses extensions
pouvant être très utiles au développement de jeux vidéo. On y retrouve
entre autres des tables de hachages ou des \textit{threads} (processus
légers).

Il semble donc qu'une utilisation judicieuse de ce système pourrait
faire bénéficier des projets aussi complexes que le sont les
productions de jeux vidéo.

\section{Problématique}
Ce mémoire de maîtrise vise à répondre à la problématique suivante:

\todo{Inserer dans un texte ou garder en quotation?}

\begin{quote}
  Quelles sont les forces et les faiblesses du langages de
  programmation Scheme pour le développement de jeux vidéo.
\end{quote}

\section{Méthodologie}

%% Afin de pouvoir répondre à la problématique posée, nous avons utilisé
%% l'approche

%% \begin{itemize}
%% \item Dev 1er jeu simple pour determiner les besoins pour Scheme
%% \item Augmenter Scheme pour repondre a ces besoins
%% \item Ecrire un nouveau jeu utilisant les techniques developpees pour le 1er jeu
%% \end{itemize}

Afin de pouvoir répondre à la problématique posée, nous avons étudié
les caractéristiques de Scheme et du compilateur Gambit-C, ainsi que
les besoins au niveau du développement de jeux vidéo. Concurremment, 2
jeux ont été développés pour raffiner nos approches et les évaluer
dans un contexte réel.

Le premier jeux a servi de plate-forme d'exploration permettant
d'élaborer une méthodologie qui semble efficace pour le développement
de jeux. Afin d'obtenir une telle méthodologie, plusieurs itérations
de développement ont été effectuées, chacune permettant d'explorer de
nouveaux aspects sur la manière de résoudre les problématiques
associées à la création de jeux, par exemple comment arriver à
synchroniser des entités dans le jeux ou comment arriver à décrire
efficacement un système de détection et de résolution de collisions.

Suite à l'écriture de ce jeu, un deuxième jeu, plus complexe, a été
développé afin de consolider les techniques précédemment utilisées et
étendre ces techniques dans le cadre de ce nouveau jeu comportant de
nouveaux défi, comme l'implantation d'une intelligence artificielle.



\section{Aperçu du mémoire}
Ce mémoire est composé de quatre parties. La première partie est une
introduction qui traite de programmation fonctionnelle, du langage de
programmation Scheme et des outils de développement disponibles, en
particulier le compilateur Gambit-C. Ce chapitre donne un aperçu
général de ces langages et permet de saisir les concepts fondamentaux
du langage Scheme. Une présentation de l'industrie des jeux vidéo et
des défis découlant du développement suit ce chapitre.

La deuxième partie du mémoire porte sur des extensions faites au
langage Scheme qui ont été utilisées dans le but d'améliorer le
développement de jeux vidéo. On y présente la programmation orientée
objet et un système d'objets conçu pour répondre aux besoins de la
programmation de jeux vidéo. Un système de coroutines conçu dans les
mêmes optiques est également présenté.

La troisième partie du mémoire porte sur l'expérience acquise par
l'auteur en effectuant l'écriture de 2 jeux vidéo simples, mais
possédant suffisamment de complexité pour exposer les problèmes
associés à la création de jeux vidéo et comment tirer profit du
langage de programmation Scheme pour résoudre ces problèmes. Une
présentation des travaux reliés aux résultats présentés suit ce
dernier chapitre. On y parle de l'utilisation d'autres langages
pour le développement de jeux vidéo et cite des exemple d'utilisation
du langage Scheme dans des jeux vidéo commerciaux et de l'expérience
tirée de cette utilisation par les développeurs.

Finalement, une conclusion apporte la lumière sur la problématique
exposée dans ce mémoire. Le point sur l'expérience acquise pour le
développement de jeux vidéo en Scheme y est fait et les avantages et
inconvénients ou problèmes obtenus seront exposés.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Développement de jeux vidéo}
\label{Chap:JV}

Les jeux vidéo font parti d'un domaine de l'informatique en pleine
effervescence grâce à une demande constante de nouveaux
produits. 

L'histoire des jeux vidéo possède déjà un demi-siècle de créations de
tout genres qui ont contribué à générer l'engouement actuel pour ces
derniers. Une brève historique des jeux vidéo sera présentée dans ce
chapitre afin de pouvoir illustrer l'évolution des jeux vidéo et de
permettre de situer dans le temps où se situent les jeux développés
pour ce mémoire.

L'industrie du jeu vidéo actuelle est le moteur qui permet aux jeux
vidéo de continuer à évoluer et se raffiner. Un aperçu global de
l'industrie du jeu vidéo est ainsi donné dans ce chapitre.

Finalement, les besoins aux niveau de la programmation exprimés par
les jeux vidéo sont énoncées afin de permettre de pouvoir cerner les
composantes importantes pour un langage de programmation utilisé pour
le développement de jeux.


\section{Historique}

L'histoire des jeux vidéo s'étale sur environ un demi-siècle et
renferme une mine d'informations importante qui permet d'exposer la
manière avec laquelle les jeux vidéo évoluent. Seulement un bref
résumé de cette histoire est présenté afin de donner présenter les
grandes ligne de l'évolution des jeux au cours des cinquante dernières
années~\cite{VIDEOGAMES_history}~\cite{HISCORE}.

\todo{Mettre des references partout, ou bien ne pas en mettre du tout?}

%% http://en.wikipedia.org/wiki/History_of_video_games

\subsection{Préhistoire 1948-1970}
Les jeux vidéo ont fait leurs apparitions avant même les premiers
ordinateurs. En effet, le \textit{Cathode Ray Amusement
  Device}~\cite{CRTAD} fit sont apparition en 1948. Il s'agissait d'un
jeu rendu sur un tube cathodique simulant le lancement de missiles sur
des cibles. 

Vers le début des années 1960, quelques jeux ont fait leurs apparition
sur les premiers ordinateurs universitaires, notamment au \textit{MIT}
et à l'université de Cambridge. On y retrouve notamment le jeu
\textit{Spacewar!} qui est l'un des premier jeu multi-joueurs mettant
les joueurs en adversité dans leurs vaisseaux spatiaux pouvant lancer
des missiles. 

Avec un intérêt stimulé envers le potentiel de divertissement
qu'offrait les jeux vidéo de l'époque, le développement de machines
dédiées aux jeux vidéo a ainsi débuté.

\subsection{Système arcade 1970-1985}
En 1971, des étudiants de l'université de Standford ont porté le jeu
\textit{Spacewar!} sur une machine fonctionnant avec de l'argent (de
la monnaie). Ce fut la première machine arcade.

Par la suite, le développement de telles machines est devenu très
répandu. En 1972, la compagnie \textit{Atari} fut fondé et démarra
l'industrie du jeu vidéo sur arcade avec le jeu \textit{Pong}, un jeu
de tennis de table permettant à un joueur de jouer contre une
intelligence artificielle ou bien de se mesurer à un autre joueur.

Ce fut alors l'âge d'or des machines d'arcade où l'on a créé beaucoup
de jeu au contenu diversifié. Parmi ceux-ci, \textit{Space
  Invaders}(1978) et \textit{PacMan}(1980) furent extrêmement
populaires. 

Malgré que les jeux d'arcades étaient très simple, ils étaient
beaucoup appréciés pour l'amusement qu'ils procuraient aux joueurs qui
tentaient toujours de se surpasser.

\todo{Marc, quelles genre de machines est-ce que c'etait? Processeur
  8bit?}

On retrouve toujours des salles d'arcades de nos jours, mais celles-ci
sont devenues beaucoup moins populaire que les consoles de jeu qui se
retrouvent dans nos salons.

\subsection{Premières consoles 1972-1984}

La première console de jeu vidéo, le \textit{Magnavox Odyssey} fut son
apparition en Amérique du Nord en 1972. Cette console permettant aux
joueurs de jouer sur le télévision assis confortablement dans leurs
salon. Elle permettait aussi d'insérer des jeux sous forme de
cartouches. Un total de 28 jeux ont été disponible pour cette console,
qui malgré l'absence de périphérique audio, a été vendu pour environ
300 000 exemplaires.

Plusieurs autres consoles ont par la suite été créées. Allant d'une
version console de \textit{Pong} jusqu'à des consoles plus puissante
comme le \textit{ColecoVision} qui démarrèrent l'ère des consoles
8-bit. La vocation principale de ces consoles n'étaient pas d'innover
dans le développement de jeu, mais plutôt de porter les jeux
d'arcades populaires sur leurs consoles.

\subsection{Ordinateurs personnels 1977-...}
Les premiers ordinateurs personnels furent leurs apparition vers la
fin des années 1970, dont notamment l'ordinateur \textit{Apple II}
produit par \textit{Apple Inc.}. Ces ordinateurs personnels offraient
plus de puissance que les consoles de l'époque et offraient la
possibilité aux amateurs de créer leurs propres jeux.

Les jeux d'ordinateurs étaient distribués sur beaucoup de média
différents. La distribution allait de cassettes, aux disquette, en
passant bien sur par des échanges postaux de code sources.

En 1982, le jeux \textit{Lode Runner} fut développé pour les
ordinateurs \textit{Apple II}. Ce jeux d'action fut l'un des premiers
jeu comprenant un éditeur de niveaux.

Aussi, le jeu \textit{Rogue} fut créé durant les années 1980, pour les
premiers système Unix. Il fut le pionnier d'un nouveau genre de jeu
(surnommé \textit{Roguelike}) qui différait beaucoup des jeux
d'actions retrouvés en sales d'arcades ou sur consoles. Il présentait
une interface visuelle très minimaliste. La narration, qui était un
point central du jeu, était effectuée de manière textuelle et le
joueur interagissait aussi de manière textuelle avec le jeu.

Les jeux d'ordinateurs ont longtemps été supérieurs aux jeux de
consoles puisque les ordinateurs étaient toujours à la fine pointe de
la technologie, et les consoles traînaient un peu derrière en terme de
technologies. Ainsi, on retrouvait des jeux ayant de meilleurs
graphique ou utilisant des périphériques plus variés sur les
ordinateurs personnels. Ainsi, les jeux d'ordinateurs existait dans un
monde parallèle à celui des consoles, ne se livrant pas de compétition
réelle.

Par contre, avec l'avènement des consoles modernes qui sont plus
performantes que la plupart des ordinateurs personnels, cet énoncé
n'est plus valide. Ainsi, les jeux sur des consoles actuelles
rivalisent avec les jeux d'ordinateurs.


\subsection{Consoles portables 1980-...}
Les toutes premières consoles portables furent développées par la
compagnie \textit{Mattel Toys} qui créèrent les jeux \textit{Auto
  Race} et \textit{Football} qui étaient distribués sur des consoles
de la taille d'une calculatrice, ne nécessitant pas de téléviseurs
externes à la console et étaient dédiées à un seul jeu. Ces consoles
furent un succès rapportant plusieurs centaines de millions de dollars
à leurs créateurs.

Par la suite, les grandes compagnie du jeu vidéo comme
\textit{Nintendo} et \textit{Bandai} se sont intéressée à de telles
consoles et en produisirent plusieurs exemplaires des consoles
\textit{Game \& Watch} qui contenaient des succès d'arcades tel
\textit{Mario's Cement Factory} et \textit{Donkey Kong Jr.}.

Le même concepteur de ces consoles à par la suite fusionner ces
dernière avec le contrôleur du \textit{Nintendo Entertainement
  System}(NES) pour obtenir la première console à grand succès: le
\textit{GameBoy}. Cette console qui offrait un écran monochrome fut
vendue à 118 million d'exemplaire dans le monde. Le jeu le plus vendu
sur cette console fut nulle autre que le jeu \textit{Tetris} qui a
vendu environ 33 millions d'unités.

Les consoles ont continuées d'évoluer grandement et elles sont
actuellement équivalente aux consoles de une ou deux génération
précédente. Par exemple, le Sony \textit{PlayStation Portable}
rivalise en matière de puissance de matériel à la précédente console
de Sony, le \textit{PlayStation 2}. On peut donc développer des jeux
très complexe sur ces consoles portables, mais ils ne peuvent toujours
pas rivaliser avec les jeux sur consoles ou d'ordinateurs.

\subsection{Consoles intermédiaires 1984-2006}
Au début des années 1980, plusieurs consoles étaient disponibles sur
le marché, mais une saturation de mauvais jeux et des problèmes de
mauvaises gestions ont fait en sorte que l'industrie du jeux vidéo à
connu une grande dépression vers en 1983. Par exemple, il y a eu une
plus grande production d'unités du jeu \textit{PacMan} qu'il n'y avait
eu de console d'Atari vendues.

Cette dépression a pris subitement fin avec la sortie de la console
produite par \textit{Nintendo}, le \textit{Nintendo Entertainement
  System} (NES) qui connu un succès fulgurant en vendant 62 millions
de consoles dans le monde. La grande qualité des jeux produits ont
certainement favorisé l'adoption de cette nouvelle console. On
retrouve entre autre des jeux de tout genre comme le jeu de
plate-forme \textit{Super Mario Bros}, le jeux d'aventure \textit{The
  Legend of Zelda} et le jeu d'action aventure \textit{Metroid}.

Par la suite, la compagnie SEGA sortit un compétiteur sérieux au NES,
le \textit{Master System}, qui rivalisait en terme de puissance
matérielle et de prix. Depuis ce temps, c'est la guerre des consoles
qui se livre où lorsqu'une compagnie développe un nouveau jeu ou une
nouvelle console, les compétiteurs ne tardent pas à produire un jeu ou
console équivalent pour les utilisateurs de leurs produits.

\subsection{Consoles modernes 2005-...}
Les consoles modernes sont généralement conçues avec du matériel à la
fine pointe de la technologie et tentent de séduire un certain public
cible.

Au moment de l'écriture de ce mémoire, on retrouve la console
\textit{Wii} de Nintendo conçu pour un publique constitué de joueurs
occasionnels grâce au contrôleur révolutionnaire de cette console
permettant de jouer en effectuant des mouvement plus naturels.

D'un autre côté compétionnent le \textit{PlayStation 3} de Sony et le
\textit{XBox 360} de Microsoft qui cherchent à convaincre les joueurs
plus sérieux d'utiliser leur système en offrant des consoles à la fine
pointe de la technologie et à prix très raisonnable en comparaison aux
prix des ordinateurs de jeu équivalents. 



\section{Industrie du jeu vidéo}
Comme mentionné dans le chapitre \ref{Chap:Intro}, l'industrie du jeu
vidéo est très importante et génère des milliards de dollars de
revenus par années. Ce profit provient d'une grande diversité de
joueurs, allant de jeunes enfants jusqu'à leurs grands-parents avec
une population féminine presque aussi importante que celle
masculine. Il en résulte donc qu'une grande diversité de jeux et de
plates-formes de jeux se retrouvent sur le marché.

Ces produits possèdent plusieurs caractéristiques de qualité communes
auxquelles les consommateurs s'attendent à obtenir en effectuant
l'acquisition d'un nouveau titre. Ces attentes du consommateur peuvent
se traduire essentiellement par les besoins suivant:

\begin{itemize}
\item Exposer un \textit{gameplay} amusant
\item Offrir de beaux rendus graphiques et un affichage visuel
  agréable
\item Avoir une composante multi-joueurs
\item Optionnellement contenir une narration 
\end{itemize}

Ces besoins semblent simple, \textit{a priori}, mais impliquent
beaucoup de travail et imposent des contraintes sévères au
développeurs de jeux vidéo.

Afin qu'un jeu puisse offrir un \textit{gameplay} intéressant au
joueurs, une étroite collaboration entre les développeurs et les
designers doit être établie. Cela implique aussi de faire beaucoup
d'essaies de possibilités en testant sur des prototypes et en
effectuant de nombreux cycles de développement du jeu.

En ce qui concerne le rendu graphique du jeu, en plus des designers du
jeu, c'est aussi avec les artistes que les développeurs doivent
s'accorder dans le but de concevoir un moteur de rendu répondant bien
aux besoins de leurs créations et, leurs créations doivent être bien
sûr faites en respectant les contraintes imposées par le matériel ou
sera déployé le produit. Ainsi, le moteur de rendu doit pouvoir être
facilement extensible afin de pouvoir accommoder facilement les
nouvelles idées et les nouveaux concepts à intégrer.

Une composante multi-joueur, tout dépendant si elle implique des
parties faites sur le réseau ou non, pourrait nécessiter une grande
rigeur de programmation afin d'assurer une stabilité de connections et
empêcher les joueurs de tricher. Ces sujets ne sont pas discuter dans
ce mémoire.

La diversité des jeux développés a mené à une caractérisation des jeux
et une classification de ceux-ci. Les principaux genres de jeux sont:

\begin{itemize}
\item Action: Jeux rapides demandant souvent de l'habileté de la part
  des joueurs.
\item Stratégie: Jeux à rythme plus lent, exigeant une réflection plus
  profonde de la part des joueurs.
\item Jeux de Rôles: Jeu où la narration de l'histoire occupe une
  place importante et où les personnages de l'histoire subissent une
  évolution graduelle en fonction du temps.
\item Simulation: Jeux qui tentent de représenter fidèlement des
  phénomène réels comme la conduite automobile, des sports, etc...
\item \textit{Casual}: Jeux simples visant à être utilisés par des
  joueurs occasionnels. Le jeu \textit{Tetris} est considéré comme
  appartenant à ce genre.
\end{itemize}

Il existe d'innombrables autres genres et genres hybrides de ces
catégories, mais celles-ci donnent une idée de la diversité du contenu
des jeux vidéo produits.

\todo{Ajouter du texte liant a la prochaine section?}



\section{Contraintes de programmation}

Le développement de jeu vidéo implique une programmation sous des
contraints sévères afin que le jeu respecte les normes de l'industrie
et respecte les attentes des joueurs.

Une contrainte importante portant sur les jeux vidéo est relié à
l'efficacité algorithmique résultant du programme développé. En effet,
la fluidité d'un jeu est critique face à l'immersion du joueur dans
l'univers créé par le jeu. Les jeux doivent donc être des programmes
très efficaces de manière à inviter le joueur à entrer le plus
possible dans la narration du jeu.

Une autre contrainte importante relié au développement de jeu est la
modularité du code produit. En effet, afin que les efforts placés dans
la production d'un jeu vidéo puissent être réutilisés dans les
productions subséquentes, des abstractions doivent être bien faites
afin de faciliter la réutilisation de ces dernières.

\todo{Autres choses?}

\subsection{Fluidité}


\subsubsection{Taux de rafraîchissement}
Une contrainte très importante dans le développement d'un jeu vidéo
est la fluidité de celui-ci. Lorsqu'un film est projeté sur un écran
de cinéma le taux de rafraîchissement de l'image est d'environ 30
trames par secondes. Par contre, les images captées par les caméra
contiennent du \og flou de mouvement \fg, effet créé par le mouvement
s'étant produit durant la capture de cette image. Ce flou permet à
notre cerveau d'estimer ou de faire l'extrapolation du mouvement dans
une trame et donc de croire l'illusion créée par la projection des
images.

Par contre, dans un jeu vidéo, les images rendues sur l'écran sont
parfaitement nettes et ne contiennent donc pas ce flou de mouvement,
ce qui vient réduire la crédibilité de l'illusion faite par la
succession des images à l'écran. Il faut donc augmenter le taux de
rafraîchissement à environ 60 trames par secondes pour obtenir le
niveau de crédibilité du projection cinématographique.

\todo{references necessaire?}

Ceci étant dit, un taux de rafraîchissement de 60 trames par secondes
n'est pas nécessaire pour tout les jeux. Cela varie grandement avec la
nature des jeux. Par exemple, un jeu de stratégie où les joueurs
jouent à tours de rôles possède peu d'animations et donc pourrait très
probablement être satisfaisant avec un taux de rafraîchissement de 30
trames par secondes.

Aussi, il est possible que les designers du jeu acceptent de réduire
volontairement le taux de rafraîchissement afin d'avoir plus de temps
pour rendre une image. Un jeu possédant un taux de rafraîchissement de
60 trames par secondes implique que les images sont rafraîchies tous
les 16 millisecondes, ce qui ne laisse pas beaucoup de temps pour
effectuer le calcul du moteur du jeu en plus du rendu de
l'image. Heureusement, les cartes vidéo modernes sont capables de
faire une bonne partie du rendu laissant ainsi le ou les processeurs
principaux libres pour exécuter le moteur du jeu.

Il n'en demeure pas moins que toute la logique du jeu doit être aussi
optimisée que possible afin que le processus de rendu des trames soit
transparent au joueur.

\subsubsection{Réponse quasi temps réelle}

Une autre implication de la fluidité requise par un jeu vidéo est le
délais de réponse face aux entrées du joueur. Ce délais aussi doit
être aussi faible que possible pour donner l'impression que le
personnage dans le jeu ne soit qu'une extension de la volonté du
joueur. Ainsi le traitement des entrées du joueurs se doit aussi
d'être très efficace afin de ne pas encombré le moteur du jeu qui n'a
déjà pas beaucoup de temps pour effectuer son travail.

\subsection{Modularité}

En plus de devoir être efficacement implanté, un jeu vidéo moderne se
doit d'être aussi modulaire que possible. Pour y arriver, le couplage
entre les différentes composantes de ce dernières doit être faible. 

Le développement de logiciel favorisant la modularité est une qualité
standard en génie logiciel, mais elle vient très bien se marier avec
le développement de jeu, surtout de jeux modernes, car ce sont de
projets de très grande envergure impliquant beaucoup de
programmeurs. Il en résulte qu'un bon design modulaire permet de bien
séparer les tâches à effectuer de manière parallèles par des équipes
spécialisées. Si le projet est bien géré, cela pourrait certainement
réduire le coût de développement de tels projets.

Aussi, une bonne modularité permet de créer des composantes qui sont
cohésives et donc qui permettent d'être réutilisée par la suite. Une
réutilisation de composantes complexes tel un moteur de physique évite
de faire un travail supplémentaire non trivial pour chaque nouveau
projet. Ainsi, il est clair que l'effort supplémentaire placé pour
bien modulariser les composantes d'un jeu seront retables pour le
développement des prochains jeu.

Bien sûr, toute abstraction possède sont coût, notamment en coût de
performances. Ainsi, il faut bien pouvoir estimer les endroits où
l'utilisation de modules externes n'apportera pas de trop grands
impacts de performances.

Il est clair qu'un langage de programmation ayant un bon potentiel
d'abstraction, comme c'est généralement le cas pour les langages de
haut niveau, facilite cette tâche. Un système orienté objet ou un bon
système de module permettraient certainement aussi à bien modulariser
les composantes d'un jeu.

\subsection{Malléabilité}

Puisque le développement d'un jeu implique généralement de faire
beaucoup de prototypage, le code d'un jeu se doit d'être très
malléable afin d'aider à faire des changements rapidement au moteur du
jeu pour tester de nouvelles idées, sans ajouter un trop grand coût
pour le faire.

La modularité du jeu aura un effet positif sur la malléabilité en
permettant de modifier les mécanismes internes des composantes sans
trop affecter le reste du programme. Par contre, un langage de
programmation offrant une bonne puissance d'abstraction serait tout
aussi efficace, car il permet de pouvoir ajouter facilement de
nouvelles abstractions où les besoins de changement apparaissent.


\section{Conclusion}
Dans ce chapitre, l'industrie du jeu vidéo, avec son histoire, ont été
mis en lumière afin d'exposer l'évolution des jeux vidéo et de motiver
l'intérêt de travailler à améliorer le développement de ceux-ci.

Les jeux vidéo sont passés rapidement d'idées farfelues comme ce fut
le cas pour le \textit{Cathode Ray Amusement Device} à une industrie
complète générant des milliards de dollars annuellement. Il y a un
grand intérêt à vouloir diminuer le coût de développement de
ceux-ci. 

Les coûts de développement de jeux modernes sont de l'ordre des
millions de dollars et impliquent des dizaines voir des centaines
d'artistes, de programmeurs et de designers. Ainsi, mêmes de toutes
petites accélérations d'un cycle de développement, pourrait avoir de
l'impacte sur le travail de beaucoup de gens et ainsi se traduire en
de grandes économies sur les coûts de développement.

Les contraintes impliqués au niveau de la programmation par le
développement de jeux vidéo ont été étudiés. Ces derniers se résument
par les concepts de fluidité, modularité et de malléabilité du jeu
vidéo. Le respect de la contrainte de fluidité résulte en une bonne
immersion pour le joueur, qui est nécessaire afin que le jeu soit
considéré comme \og jouable \fg. La modularité facilite le
développement collaboratif et parallèle tout en permettant d'améliorer
la réutilisation des composantes communes à plusieurs jeux. L'aspect
de la malléabilité du code permet d'accélérer le prototypage du jeu.

Il semble donc que le choix d'un langage permettant de pouvoir
facilement répondre à ces contraintes pourrait certainement faciliter
le développement de jeux vidéo et ainsi, engendrer des économies
substantielles aux compagnies de l'industrie et rendant plus
accessible le développement de jeu aux plus petites compagnies
possédant des budgets moins importants.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Le langage Scheme}
\label{Chap:Scheme}

Dans le cadre d'un projet donné, le choix d'un langage de
programmation a beaucoup d'influence sur la structure du code écrit
pour la réalisation de celui-ci. Plusieurs facteurs influencent ces
différences. Par exemple, un langage à typage statique résultera en du
code qui se doit d'être bien structuré, mais qui sera beaucoup moins
malléable par la suite. Ainsi, afin d'optimiser les efforts
développement pour un projet, une bonne analyse des besoins exprimés
par le projet est de rigeur pour pouvoir faire le choix d'un langage
répondant le mieux possible à ceux-ci.

En se basant sur les besoins et les contraintes énoncées dans le
chapitre \ref{Chap:JV}, nous proposons l'utilisation du langage de
programmation Scheme comme outil principal de développement de jeux
vidéo. Il s'agit d'un langage de très haut niveau qui semble être un
candidat idéal afin de permettre un développement efficace de jeux
vidéo. 

Ce chapitre donne une historique du langage Scheme afin de mettre en
situation le langage et donné un aperçu de son origine. Par la suite,
une brève explications de concepts de bases du langage est
donnée. Finalement, les particularités du langages sont mise en
lumière dans le but de faire comprendre au lecteur quelle est
l'ampleur de celles-ci.

\todo{d'autres idées?}

\section{Héritage LISP}
Le langage Scheme est une forme épurée du tout premier langage de
programmation de haut niveau, le langage LISP. Ainsi, pour illustrer
les origines de Scheme, une courte histoire du langage LISP est
présentée. Par la suite, les langages de programmation qui furent
inspirés du langage Scheme sont mentionnés en expliquant brièvement
les racines commune à Scheme est les principales disparités.

\subsection{Histoire de LISP}
\todo{McCarthy, GC, List Processing, AI...}

\todo{Common LISP = Grosse Bébitte}

\subsection{Avènement de Scheme}
\todo{Épuration de LISP à l'essence du langage}

\todo{évolution du langage via RNRS, SRFIs}

\todo{simplicité du langage, beaucoup d'extension disponibles }

\subsection{Langages inspirés de Scheme}
\todo{Javascript, Ruby: lang de scripting. Concept de fermetures}

\todo{Java??}


\section{Introduction au langage}
Tout en bénéficiant du riche héritage des langages LISP, Scheme
demeure un langage épuré et très simple à la base. Cette section vise
à présenter les bases du langages Scheme et de son implantation dans
le système Gambit-C afin de familiariser le lecteur avec non seulement
la syntaxe du langage, mais aussi les fonctionnalités de base et les
extensions au langages fournies par Gambit-C.

\subsection{Syntaxe}
La syntaxe de Scheme est une des caractéristique qui distingue le
distingue le plus des autres langages de programmation. En effet, la
syntaxe utilisée est extrêmement simple. À la base, toute expression
Scheme est une expression symbolique, nommée aussi \textit{S
  expression}. Une S expression est une forme de donnée structurée
récursive qui doit débuter par une parenthèse ouvrante, contient un
nombre arbitraire de données qui sont soit des atomes ou des S
expressions et qui doit se terminer par une parenthèse fermante. Les
atomes sont des symboles, des nombres, des valeurs booléennes,
etc.. La figure \ref{FIG:sexp} donne un exemple très simple de S
expression contenant des informations sur les prix de la nourriture
dans une épicerie.

\begin{figure}[htb!]
  \center
  \begin{schemecode}
    ((bananes 1.52)(bonbons 1/100))
  \end{schemecode}
  \caption{Exemple simple de S expression}
  \label{FIG:sexp}
\end{figure}

En Scheme, ces S expressions sont considérées comme étant des listes
chaînées. Chacune des case de la liste chaînée contient dans son
premier élément la valeur contenu dans cet élément et sont deuxième
élément est un pointeur vers le prochain élément. En Scheme, le point
(\scheme{.}) est utiliser pour dénoter le dernier élément d'une
liste. La figure \ref{FIG:sexp->list} explicite la structure de liste
de l'exemple de S expression provenant de la figure \ref{FIG:sexp}.


\begin{figure}[htb!]
  \center
  \begin{schemecode}
    ((bananes . (1.52 . ())) . 
     ((bonbons . (1/100 . ())) . 
      ()))
  \end{schemecode}
  \caption{Équivalence de la S expression de la figure \ref{FIG:sexp}
    sous forme explicite de liste}
  \label{FIG:sexp->list}
\end{figure}

Cette forme est strictement équivalente à celle donnée précédemment et
correspond à la structure de donnée de base employé en Scheme, les
listes.

Un programme Scheme est aussi une S expression qui correspond à un
appel de fonction (ou à une forme spéciale du langage). Le premier
élément de la liste doit être un symbole qui correspond à cette
fonction ou cette forme spéciale et le restes des éléments sont les
argument qui sont eux aussi des programmes Scheme sous forme de S
expressions. Il en résulte donc qu'une notation préfixe est utilisée
en Scheme.

La distinction entre une fonction et une forme spéciale est l'ordre
d'évaluation des paramètres. Pour un appel de fonction, chacun des
paramètres passés sont d'abord évalués et ensuite, la valeurs
correspondante à leurs évaluation est donnée à la fonction appelée. Il
s'agit donc d'un passage par valeur. En opposition, les formes
spéciales possèdent des règles d'évaluation propres à elles. Les
formes spéciales de bases de Scheme peuvent être étendu par des macros
qui utilisent un passage de valeur par nom, où les paramètres sont
passés directement à la macro comme étant des données Scheme. Le
fonctionnement des macros Scheme est détaillé dans la section
\ref{SEC:Macros}.

Il existe également quelques exception syntaxiques aux S expressions
qui sont utilisées pour construire des données constantes. On utilise
le caractère \scheme{'} (\textit{quote}) pour signifier que la S
expression subséquente est constante, \textit{i.e.} qu'elle ne doit
pas être considérée comme un programme Scheme, mais bien comme une
valeur. L'utilisation du caractère \textit{quote} est strictement
équivalente à l'utilisation de la forme spéciale correspondante. Une
exemple d'utilisation est illustré dans la figure \ref{FIG:quote}.

\begin{figure}[htb!]
  \center
  \begin{schemecode}
'((bananes 1.52)(bonbons 1/100)) 
(quote ((bananes 1.52)(bonbons 1/100)))
  \end{schemecode}
  \caption{Exemples d'utilisation de la syntaxe \textit{quote} et de
    la forme spéciale correspondante.}
  \label{FIG:quote}
\end{figure}

Après évaluation, ces deux morceaux de code retournent tous deux la
valeur \scheme{((bananes 1.52)(bonbons 1/100))}.

On retrouve une forme altéré du \textit{quote} nommée
\textit{quasiquote} qui permet des évaluations partielles à
l'intérieur d'une forme \textit{quote} en utilisant le caractère
\scheme{,} équivalent à la forme spéciale \scheme{unquote}. La figure
\ref{FIG:quasiquote} illustre un exemple d'utilisation.

\begin{figure}[htb!]
  \center
  \begin{schemecode}
`((bananes ,(+ 1.0 52/100)) (bonbons 1/100))
(quasiquote ((bananes (unquote (+ 1.0 52/100))) (bonbons 1/100)))
  \end{schemecode}
  \caption{Exemple d'utilisation des formes spéciales
    \scheme{quasiquote} et \scheme{unquote}}
  \label{FIG:quasiquote}
\end{figure}



\todo{Notation prefixe clean et sans ambiguite}

\subsection{Aperçu des fonctionnalités requise par le standard}

\todo{Exemple de construction de '((bananes 1.52)(bonbons 1/100)) avec
  list et cons}

\subsection{Extensions présentées par Gambit-C}

\section{Programmation fonctionnelle}
\subsection{Distinction}
\todo{Fonctions sont des données de premier ordre}
\todo{Fonctions d'ordres supérieures (avec exemples)}

\subsection{Programmation fonctionnelle pure}
\todo{Pas de mutation. Comme des blocs lego}

\todo{Haskell, ML}

\todo{Exemple en Scheme}


\subsection{Effets de bords dans Scheme}
\todo{Entrees sorties (variables à portée dynamique)}
\todo{Mutations de variables}


\section{Macros}
\label{SEC:Macros}

\subsection{Introduction}
\todo{Discussion sur les macros de C et leurs limitations: permet de
  faire des abstractions dans le code résultant une modification du
  code source avant la compilation, mais uniquement limité à du
  remplacement de code.}

\todo{Explication des macros scheme: Code source == données scheme,
  dispose d'une pré-évaluation permettant de prendre du code source en
  entré et de généré du code source (toujours sous forme de listes
  (données Scheme)). Revient a faire une manipulation d'ASA.}

\todo{Dispose de toute la puissance de calcul durant l'expansion :)}

\subsection{Exemples simples}

\todo{macro inc}

\todo{macro while}

\subsection{Problème de l'hygiène des macros}

\todo{Capture de nom intentionnelle, ou non intentionnelle. }

\todo{Différentes formes spéciales (define-macro, define-syntax)}



\section{Continuations}
\subsection{Introductions du sujet et explications}
\todo{En C, continuation equiv au code situé à l'adresse de retour de
  la fonction exécutée.}

\todo{Explication de l'ordre dévaluation en Scheme.}

\todo{Continuation d'un programme simple en Scheme. (+ 1 (- [f x y]
  2)) : continuation de l'appel à f est la soustraction du résultat
  par deux, puis l'on ajoute à 1 se résultat. Eq à (lambda (res-f) (+
  1 (- res-f 2))).}

\subsection{Réification de continuations}
\todo{Explication de call-with-current-continuation permettant de faire}
\todo{surfacer une continuation.}

\subsection{Exemples d'utilisations}
\subsubsection{Échappement au flux de contrôle}
\todo{Utilisation comme un return}

\subsubsection{Système de coroutine}
\todo{Exemple du cours de Marc}

\subsection{Forme d'écriture de code en CPS}
\todo{Expliquer la différence entre un appel terminal et un appel
  non-terminal. Expliquer comment les appels terminaux peuvent être
  optimisés (requis en Scheme).}

\todo{Écrire le code de manière à rendre explicite le passage et les
  appels de continuations. Toujours des appels
  terminaux. Transformation souvent utilisée par les compilateurs pour
  implanter l'optimisation d'appels terminaux.}

\subsection{Exemple d'implantation}
\todo{Exemple du cours de Marc}


\section{Dynamisme du langage}
\todo{Typage dynamique vs typage statique}

\todo{Exemple de code utilisant le typage dynamique.}

\todo{Evaluation dynamique de code avec load ou eval. idées?}

\todo{Langages comme C++ favorisent bcp de focuser sur la conceptions des
  classes. Implique une structure rigide qui se doit d'être bien conçu
  depuis le départ.}

\todo{Langages plus dynamiques permettent des cycles de prototypage
  rapide en apportant beaucoup de flexibilité aux développeurs.}


\section{Gestion mémoire automatique}
\subsection{Motivation}
\todo{Gestion mémoire manuelle ou semi-automatique causent énormément
  de problèmes de fuites de mémoire (ou de pointeurs fous).}

\todo{En connaissant les racines, on peut automatiser la récupérations
  de mémoire, au coût d'un certain temps de calcul.}

\todo{Date des premières version de LISP.}



\subsection{Survol des techniques}
\todo{Mark and sweep}

\todo{Stop and copy}

\todo{GC générationnels}

\todo{GC temps réels ou incrémentaux}



\section{Débuggage}
\todo{Possibilité de pouvoir exécuter du code arbitraire lors d'un
  crash}

\todo{Possibilité de pouvoir inspecter chacune des frames de la pile
  de continuactions afin de pouvoir obtenir de l'info sur
  l'environnement de celui-ci, l'endroit dans le code source où la
  continuation se trouve et même de pouvoir exécuter du code dans
  l'environnement d'une continuation de la pile choisie.}

\todo{Possibilité de faire le déboggage à distance (ex: iPhone)}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation orientée objet}

\todo{Parler des define-type de Gambit-C et du SRFI-9}

\todo{Approche traditionnelle de la prog OO: Surdéfinition de méthodes de
  classe, héritage simple, polymorphisme, etc...}

\todo{Parler de CLOS: intégré à Common LISP, fonctions génériques, héritage
  multiple}

\todo{Besoins pour jeux vidéo}

\section{Description du langage}
\todo{Langage orienté objet qui a pour but d'être efficace tout en
  apportant l'expressivité offerte par la programmation orientée
  object à la CLOS.}

Résumé des fonctionnalités:
\begin{itemize}
\item Accès aux membres rapide
\item Héritage multiple
\item Polymorphisme
\item Fonctions génériques à \og dispatch \fg multiple
\end{itemize}

\subsection{Définition de classes}
\todo{Compatibilité avec les define-type}

\todo{Définitions simples (instance slots et class slots)}

\todo{Héritages des membres}

\todo{Utilisation de hook sur les slots}

\todo{Constructeurs}


\subsection{Définition de fonctions génériques}
\todo{Dispatch simple}

\todo{Dispatch multiple (avec les problèmes reliés à la résolution de la méthode à choisir)}

\todo{call-next-method}

\todo{Type '*'}

\subsection{Fonctions et formes spéciales utilitaires}

\todo{Vérifications manuelles de typages et introspections
  (instance-object?, instance-of?, find-class?, get-class-id,
  is-subclass?, get-supers)}




\section{Implantation}
\todo{Apercu global: Utilisation de macros scheme pour effectuer la
  génération de code nécessaire au fonctionnement du système.}

\todo{Séparation entre le travail fait durant l'expantion macro et
  l'exécution}

\todo{Passage d'informations entre le moment de l'expansion et
  l'exécution (informations sur les classes, les fonctions génériques,
  etc...)}

\subsection{Implantation de define-class}
\todo{Structures de données (descripteurs de classes, format des
  instances, etc..)}

\todo{Polymorphisme: chaque index dans les descripteurs de classes
  sont orthogonaux (implique que les descripteurs grossissent
  linéairement en fonction du nombre de classes) et passage aux
  classes enfants des indexes utilisés par les parents.}

\todo{Constructeurs et describe comme fonctions génériques}

\subsection{Implantation de define-generic}
\todo{Registre des méthode: Conservations d'informations sur les
  fonctions génériques et leurs instances }

\todo{Implantation du polymorphisme des fonctions génériques}

\todo{Implantation du call-next-method faite avec l'utilisation de
  variables à portée dynamique}

\todo{Coût de l'utilisation des fonctions génériques}

\subsection{Implantation de define-method}
\todo{Stockages des fermetures durant l'expansion macro et l'exécution}




\section{Conclusion}
\todo{Ouverture sur le fait qu'un meta-protocole serait très intéressant à
  ajouter, mais à quel prix?}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Système de coroutines}
\todo{Système de threads offerts ne sont pas toujours
  satisfaisant. Mentalité Scheme: au lieu de contraindre ce qu'on veut
  faire en fonction de ce qui nous est offert, étendre le langage pour
  nous permettre de faire ce que l'on veut et surtout de la manière
  désirée.}

\todo{Implantation de son propre système: contrôle fin du comportement
  de threads}

\todo{Parler de Termite: Calcul distribué sur plusieurs
  noeuds. Synchronisation par passage de message. Communication via
  TCP/IP.}

\todo{Motivation de l'utilisation de coroutines (contrôle exact sur le
  flot de contrôle == système toujours dans un état consistant).}

\section{Description du langage}
\todo{Idée sur nos coroutines}

\todo{Systèmes récursifs}

\todo{Timers: abstraction du temps écoulé permettant l'accélération ou
  le ralentissement de l'exécution d'une simulation.}

\subsection{Création de coroutines}
\todo{Création d'une coroutine détachée du système: (new corout <id>
  <thunk>)}

\todo{intégrée au système via le démarrage (boot) ou via une autre
  coroutine (spawn-brother)}

\subsection{Manipulation du flot de contrôle}
\subsubsection{yield} 
\todo{Transfert à la prochaine coroutine}

\subsubsection{super-yield} 
\todo{Transfert au prochain système de coroutine (frère du système courant).}

\subsubsection{terminate-corout, kill-all!, super-kill-all!}
\todo{Terminaison de coroutines. }

\subsubsection{sleep-for}
\todo{Sommeil pour un temps prédéterminé.}

\subsubsection{continue-with}
\todo{Continuation de la coroutine.}

\subsubsection{spawn-brother, spawn-brother-thunk}
\todo{Démarrage de nouvelles coroutines.}

\subsubsection{Composition of coroutines}
\todo{Compositions ou séquençage de coroutine}

\subsection{Système de communication inter coroutines}
\subsubsection{!} 
\todo{Envoi de message à une coroutine}

\subsubsection{?}
\todo{Réception d'un message bloquante (avec possibilité de timeout)}

\subsubsection{??}
\todo{Réception sélective de message bloquante (avec possibilité de timeout)}

\subsubsection{recv, dynamic msg handlers}
\todo{Forme spéciale permettant la réception sélective de messages via
  un \og pattern matching \fg qui permet une notation concise et
  l'utilisation aisée du contenu des messages reçus.}

\subsubsection{Messaging lists}
\todo{Système permettant de regrouper des coroutines et de leurs
  diffuser des messages. }

\subsection{Démarrage du système}
\subsubsection{simple-boot}
\todo{Démarrage rapide du système.}

\subsubsection{boot}
\todo{Démarrage permettant de spécifier un timer spécifique à
  l'utilisation et une fonction personnalisée effectuant la gestion
  des valeurs de retour des coroutines.}

\todo{Systèmes cascadés?}


\section{Implantation}

\subsection{Implantation des coroutines}

\todo{Structure de données}

\todo{États d'une coroutines}

\subsection{Scheduler}
\todo{Abstraction du temps via timer}

\todo{États du scheduler}

\todo{Algorithme de scheduling}

\subsection{Système de messagerie}
\todo{Structures de données}

\todo{Envoi de messages}

\todo{Réception de messages}

\todo{Macro recv}


\section{Conclusion}
\todo{Ouverture sur le profilage des coroutine}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Évaluation et expériences}

Développement de jeu fait ayant comme but de trouver les problèmes
rencontrés durant la création de jeux vidéo et de proposer des
méthodes pour résoudre ces problèmes.

Aussi, on cherche à identifier les avantages que nous a fourni Scheme
et à identifier les incovénients que pose l'utilisant du langage
Scheme pour le développement de ces jeux.

Débute par un jeu simple afin de trouver les problèmes de base et
trouve des solutions à ces problèmes.

Ensuite, un deuxième jeu a été écrit afin de consolider les solutions
trouvées précédemment et de potentiellement trouver d'autres problèmes
reliés aux nouvelles complexité présentent dans ce deuxième jeu.

\section{Développement de \og Space Invaders \fg}

\subsection{Objectifs}
\todo{Expérimentation avec un jeu très simple}

\todo{Trouver les problèmes fondamentaux pour le développement de jeux}

\todo{Tenter de les résoudre}

\subsection{Version initiale}
\todo{Premier jet dans le but de trouver des problèmes potitiels}

\begin{itemize}
\item Comment faire des animations? => CPS
\item Comment concevoir une partie a 2 joueurs? => coroutines
\item Difficulté à décrire la résolution de collision de manière
  efficace 
\item Est-il possible d'écrire le comportement d'une entité de manière
  indépendante, i.e. que le code soit centralisé dans une même
  fonction?
\end{itemize}

\subsection{Version orientée objet}
\todo{Motivation: Utilisation de fonctions génériques}

\todo{Hierarchie de classe}

\todo{Code Highlight: Résolution de collisions}


\subsection{Version avec système de co-routine}
\todo{Motivation: Intégrer les coroutines a chaque objet de manière à
  ce que chaque instance soit une entité à part entière qui doit régir
  son propre comportement.}

\todo{Difficultés: synchronisation des entités}

\todo{Code Highlight: synchronisation des invaders}


\subsection{Conclusion}
\todo{Trouvé plusieurs problèmes et pu résoudres ces derniers}

\todo{Utilisation d'un système object a grandement contribué à
  améliorer le code du jeu.}

L'intégration du système de coroutines aux objets du jeu a causé plus
de problème qu'elle en a résolu. L'utilisation des coroutines serait
mieux d'être limité à l'implantation du jeu multijoueur.

\todo{ouverture: Essayer ces techniques dans un jeu plus complexe pour
  voir si elles sont toujours valides}


\section{Développement de \og Lode Runner \fg}
\subsection{Objectifs}
\todo{Jeux plus complexe: plus d'interaction du joueur, intelligence
  artivicielle, niveaux, schema d'animations plus complexe, etc...}

\todo{Utiliser ce qui semblait de meilleur dans space-invaders de
  manière a non seulement confirmer la pertinance de ces methodes,
  mais aussi a potentiellement en developper de nouvelles dû aux
  nouvelles contraintes de ce jeu.}

\subsection{Synchronisation}
\todo{Utilisation du concept de frame pour faire la synchro. (manière
  traditionnelle) Réduit de beaucoup la complexité.}

\todo{Danger si le framerate varie, la vitesse du jeu varie.}

\subsection{Machines à états}
\todo{Utiliation des fonctions génériques}

\todo{Utilisez un LSD pour ca??? Des idées?}

\subsection{Intelligence Artificielle}
\subsubsection{À venir...}

\subsection{Conclusion}
\subsubsection{À venir...}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\chapter{Mesures de performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Travaux reliés}

Dans un premier temps, il serait intéressant de comparer les
différents langages utilisés dans l'industrie du jeu vidéo avec Scheme
afin d'en faire ressortir les différences. Ces différences mènent
directement à une méthode de développement qui seront complètement
différentes.

Scheme a déjà été utilisé pour produire des jeux vidéo commerciaux de
très bonne qualité. Certains seront cités et une revue de l'expérience
acquise par les développeurs sera exposée.

\section{Comparaison de langages}

\subsection{Lua}
Langage utilisé très fréquemment pour effectuer le \og scripting \fg
dans les jeu vidéo.

Differences entre lua et Scheme
\begin{itemize}
\item Lua est de petite taille en mem
\item ..
\end{itemize}

\subsection{C++}
Langage principal de développement de jeu vidéo en industrie.

Differences entre Scheme et C++
\begin{itemize}
\item Gestion memoire manuelle vs GC
\item méthode surdéfinies vs fonctions génériques
\item ...
\end{itemize}


\section{Jeux en Lisp}

\subsection{QuantZ}
Jeu de type \og casual \fg de très bonne qualité écrit presque
entièrement en Scheme.

À voir avec Robert

FRP?

Techniques anti-gc

Delegation de fermetures

\subsection{Naughty Dogz}
Compagnie très connue associée à Sony qui utilisent Scheme pour
produire leurs jeux vidéo.

\subsubsection{GOAL}
Compilateur Scheme utilisé pour produire les jeux sur PlayStation 2

%% http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
%% http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\begin{itemize}
\item http://en.wikipedia.org/wiki/Game\_Oriented\_Assembly\_Lisp
\item http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\end{itemize}

\subsubsection{Drake's uncharted Fortune}

%%http://bc.tech.coop/blog/060118.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}


L'expérience d'écriture de ces jeux aura permis de faire le point sur
les avantages et les inconvénients de l'utilisation d'un langage tel
que Scheme pour le développement de jeu vidéo.


\begin{itemize}
  \item[+] puissance d'expression / d'abstraction
  \item[+] langage dynamique (développement en-direct, malléabilités)
  \item[+] création de langages spécifiques au domaine

  \item[-] Garbage Collection et sur-allocation
  \item[-] Profilage plus difficile avec des LSD (pour Gambit-C et statprof)
  \item[-] Balance entre abstraction et efficacité
\end{itemize}


%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chapter{Bibliographie}

\setstretch{1}
\bibliographystyle{unsrt} %% or maybe plain or abbrv
\bibliography{memoire}

%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
% TODO: ce compteur doit être ajusté à la main 
% \setcounter{page}{99}

%% \chapter{Code des exemples}

%% \section{Compte de banque}

%% \subsection{Compte de banque en Java}\label{account_java}

%% \subsubsection{Classe Account}
%% \codeinput{bank/Account.java}

%% \subsubsection{Interface RemoteAccount}
%% \codeinput{bank/RemoteAccount.java}

%% \subsubsection{Classe LogRecord}
%% \codeinput{bank/LogRecord.java}

%% \subsubsection{Classe AccountServer}
%% \codeinput{bank/AccountServer.java}

%% \subsubsection{Classe AccountClient}
%% \codeinput{bank/AccountClient.java}

%% %% \subsection{Compte de banque en Termite}\label{account_termite}
%% %% \schemeinput{bank/account.scm}

%% \newpage 

%% \section{Serveur générique: genserver.scm}
%% \schemeinput{genserver.scm}

%% %% \section{Superviseur générique: supervisor.scm}
%% %% 
%% %% \schemeinput{supervisor.scm}

%% \newpage

%% \section{Définition de type}\label{define_termite_type}
%% \schemeinput{deftype.scm}

%% \newpage
%% \chapter{Code des tests de performance}

%% \section{Fibonacci}

%% \subsection{Scheme}\codeinput{bench/fib.scm}
%% \subsection{Erlang}\codeinput{bench/fib.erl}

%% \newpage
%% \section{Takeuchi}

%% \subsection{Scheme}\codeinput{bench/tak.scm}
%% \subsection{Erlang}\codeinput{bench/tak.erl}

%% \newpage
%% \section{Inversion naïve}
%% \subsection{Scheme}\codeinput{bench/nrev.scm}
%% \subsection{Erlang}\codeinput{bench/nrev.erl}

%% \newpage
%% \section{Quick Sort}
%% \subsection{Scheme}\codeinput{bench/qsort.scm}
%% \subsection{Erlang}\codeinput{bench/qsort.erl}


%% \newpage
%% \section{Smith Waterman}
%% \subsection{Scheme}\codeinput{bench/smith.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/smith.erl}

%% \newpage
%% \section{Self}
%% \subsection{Termite}\codeinput{bench/self.scm}
%% \subsection{Gambit}\codeinput{bench/self_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/self.erl}

%% \newpage
%% \section{Spawn}
%% \subsection{Termite}\codeinput{bench/spawn.scm}
%% \subsection{Gambit}\codeinput{bench/spawn_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/spawn.erl}

%% \newpage
%% \section{Ring}

%% \subsection{Termite}\codeinput{bench/ring.scm}
%% \newpage
%% \subsection{Gambit}\codeinput{bench/ring_gambit.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/ring.erl}

%% \newpage
%% \section{Ping-pong}

%% \subsection{Termite}\codeinput{bench/pingpong.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/pingpong.erl}


%% \newpage
%% \section{``Migration''}

%% \subsection{Termite}\codeinput{bench/migrate.scm}

\end{document}
