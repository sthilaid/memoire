\documentclass[12pt,oneside,letterpaper,francais]{book}

%% \documentclass[12pt]{report}

\usepackage[french, english]{babel}
%\usepackage{isolatin1}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{setspace}
\usepackage{verbatim}

\usepackage{udem_these_fr}

\newcommand{\todo}[1]{[TODO: {\it #1}]}

%\newcommand{\object}[1]{$\#<#1 \ldots>$}
\newcommand{\object}[1]{{\it #1}}

\input{r5rscommands.tex}

\newcommand{\codeinput}[1]{\begin{singlespace}\verbatiminput{#1}\end{singlespace}}
\newcommand{\schemeinput}[1]{\begin{schemecode}\input{#1}\end{schemecode}}

\newcommand{\scheme}[1]{\selectlanguage{english}{\tt #1}\selectlanguage{french}}
\newcommand{\schemeresult}[1]{{\tt #1}}

%% \hyphenation{ex-écu-tion} %% marche pas a cause de l'accent

\title{Development de jeux vidéo en Scheme}

% remplir les champs...
\Auteur{David}{St-Hilaire}

\President{M.}{Mostapha}{Aboulhamid}{Ph.D.}

\Directeur{M.}{Marc}{Feeley}{Ph.D.}

\Membres{1}{M.}{Yann-Gaël}{Guéhéneuc}{Ph.D.}

%pour le doctorat seulement

%examinateur externe
%\Membres{2}{M.}{Membre}{deux}{Ph.D.}
%
%%representant du doyen de la FES
%\Membres{3}{M.}{Membre}{trois}{Ph.D.}

%Pour un doctorat, changer simplement \MSc par \PhD
%titre: 15 mots, max. 175 caractère
\MSc{Dévelopment de jeux vidéo en Scheme}
    {}
    {d'informatique et de recherche op\'{e}rationnelle}
    {informatique}
    {Décembre}
    {2009}

\setstretch{2}
\begin{document}

\setcounter{page}{1}
 \PagesCouverture

\resume


\vspace{2em}

\noindent {\bf Mots clés}: Language de programmation fonctionnels,
Scheme, jeux vidéo, programmation orientée objet.

\abstract

\selectlanguage{english}


\vspace{2em}

\noindent {\bf Keywords}: Functional programming languages, Scheme,
video games, object oriented programming.


\selectlanguage{french}

%% \maketitle
 
\tabledesmatieres

% \listedestableaux

\listedesfigures

% \listedesannexes

\remerciements

blablabla

% \preface
% 
% Préface...

\debutchapitres

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

\section{Contexte}
\subsection{jeu video -> \$\$}
\subsection{prog de jeu complexe: bcp années/hommes de travail}

\section{Motivation}
\subsection{Comment faciliter le dév?}
\subsection{Prog haut niveau vs bas niveau}
\subsection{Scheme}

\section{Problématique}
Ce mémoire de maîtrise vise à répondre à la problématique suivante:

\begin{quote}
  Est-ce possible ou envisageable de concevoir et développer des jeux
  vidéo en Scheme? Quels en sont les avantages et les inconvénients?
\end{quote}


\section{Méthodologie}

\subsection{Dev 1er jeu simple pour determiner les besoins pour Scheme}
\subsection{Augmenter Scheme pour repondre a ces besoins}
\subsection{Ecrire un nouveau jeu utilisant les techniques developpees pour le 1er jeu}

Afin de pouvoir répondre à ces questions, 2 jeux vidéo ont été
developpés en utilisant le langage de programmation Scheme. Le premier
jeux a servi de platforme d'exploration permettant d'élaborer une
méthodologie qui semble efficace pour le développement de jeux. Afin
d'obtenir une telle méthodologie, plusieurs itérations de
développement ont été effectuées, chacune permettant d'explorer de
nouveaux aspects sur la manière de résoudre les problématiques
associées à la création de jeux, comme par exemple comment arriver à
synchroniser des entités dans le jeux ou comment arriver à décrire
efficacement un système de détection et de résolution de collisions.

Suite à l'écriture de ce premier jeu, un autre jeu plus complexe que
le premier a été écrit afin de consolider les méthodologies
précédemment utilisées.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Développement de jeux vidéo}

\section{Contexte (intro?)}

\subsection{Grosseur du marche des JV}
\subsection{Diversite des jeux (genres, plates-formes)}
\subsection{Charactéristiques de jeux modernes}

Les jeux vidéo font parti d'un domaine de l'informatique en pleine
effervescence grâce à une demande constante de nouveaux produits. Ces
produits possèdent plusieurs caractéristiques de qualité auxquelles
les consommateurs s'attendent à obtenir en effectuant l'acquisition
d'un nouveau titre. Ces attentes du consommateur peuvent se traduire
par les besoins suivant:

mettre ici une liste des attentes pour un jeu moderne

\section{Historique}

%% http://en.wikipedia.org/wiki/History_of_video_games

\subsection{préhistoire 1948-1970}
\subsubsection{CRT games}
\subsubsection{Mainframe games}

\subsection{Système arcade 1970-1985}
\subsubsection{Pong}
\subsubsection{Space Invaders}
\subsubsection{Pac-Man}

\subsection{Premières consoles 1972-1984}
\subsubsection{Magnavox Odyssey}
\subsubsection{Atari XX00 et ColecoVision}

\subsection{Consoles intermédiaires 1984-2006}
\subsubsection{NES, SNES, N64, GameCube}

\subsection{Consoles récentes 2005-...}


\subsection{Ordinateurs personnels 1977-...}
\subsubsection{Évolution parallèle constante}


\subsection{Consoles portables}

\section{Contraintes de programmation}

\subsection{fluidité}

\subsubsection{Taux de rafraîchissement}
\subsubsection{Réponse quasi temps réelle}

\subsection{Modularité}

\subsubsection{Complexité des jeux ... gros logiciels}
\subsubsection{Développement itératif ... plusieurs modifications du système}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Le langage Scheme}

\cite{SICP}


\section{Programmation fonctionnelle}

\section{Continuations}

\section{Gestion mémoire automatique}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation orientée objet}

\section{Description du langage}

\section{Implantation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Système de coroutines}

\section{Description du langage}

\section{Implantation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Évaluation et expériences}

\section{Développement de \og Space Invaders \fg}

\subsection{Objectifs}

\subsection{Développement itératif}

\subsubsection{Version initiale}

\subsubsection{Version orientée objet}

\subsubsection{Version avec système de co-routine}



\section{Développement de \og Lode Runner \fg}

\subsection{Objectifs}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\chapter{Mesures de performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Travaux reliés}

\section{Comparaison de langages}

\subsection{Lua}

\subsection{C++}


\section{Jeux en Lisp}

\subsection{QuantZ}

\subsection{Naughty Dogz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}


L'expérience d'écriture de ces jeux aura permis de faire le point sur
les avantages et les inconvénients de l'utilisation d'un langage tel
que Scheme pour le développement de jeu vidéo.


\begin{itemize}
  \item[+] puissance d'expression / d'abstraction
  \item[+] langage dynamique (développement en-direct, malléabilités)
  \item[+] création de langages spécifiques au domaine

  \item[-] Garbage Collection et sur-allocation
  \item[-] Profilage plus difficile avec des LSD (pour Gambit-C et statprof)
  \item[-] Balance entre abstraction et efficacité
\end{itemize}


%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chapter{Bibliographie}

\setstretch{1}
\bibliographystyle{unsrt} %% or maybe plain or abbrv
\bibliography{memoire}

%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
% TODO: ce compteur doit être ajusté à la main 
% \setcounter{page}{99}

%% \chapter{Code des exemples}

%% \section{Compte de banque}

%% \subsection{Compte de banque en Java}\label{account_java}

%% \subsubsection{Classe Account}
%% \codeinput{bank/Account.java}

%% \subsubsection{Interface RemoteAccount}
%% \codeinput{bank/RemoteAccount.java}

%% \subsubsection{Classe LogRecord}
%% \codeinput{bank/LogRecord.java}

%% \subsubsection{Classe AccountServer}
%% \codeinput{bank/AccountServer.java}

%% \subsubsection{Classe AccountClient}
%% \codeinput{bank/AccountClient.java}

%% %% \subsection{Compte de banque en Termite}\label{account_termite}
%% %% \schemeinput{bank/account.scm}

%% \newpage 

%% \section{Serveur générique: genserver.scm}
%% \schemeinput{genserver.scm}

%% %% \section{Superviseur générique: supervisor.scm}
%% %% 
%% %% \schemeinput{supervisor.scm}

%% \newpage

%% \section{Définition de type}\label{define_termite_type}
%% \schemeinput{deftype.scm}

%% \newpage
%% \chapter{Code des tests de performance}

%% \section{Fibonacci}

%% \subsection{Scheme}\codeinput{bench/fib.scm}
%% \subsection{Erlang}\codeinput{bench/fib.erl}

%% \newpage
%% \section{Takeuchi}

%% \subsection{Scheme}\codeinput{bench/tak.scm}
%% \subsection{Erlang}\codeinput{bench/tak.erl}

%% \newpage
%% \section{Inversion naïve}
%% \subsection{Scheme}\codeinput{bench/nrev.scm}
%% \subsection{Erlang}\codeinput{bench/nrev.erl}

%% \newpage
%% \section{Quick Sort}
%% \subsection{Scheme}\codeinput{bench/qsort.scm}
%% \subsection{Erlang}\codeinput{bench/qsort.erl}


%% \newpage
%% \section{Smith Waterman}
%% \subsection{Scheme}\codeinput{bench/smith.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/smith.erl}

%% \newpage
%% \section{Self}
%% \subsection{Termite}\codeinput{bench/self.scm}
%% \subsection{Gambit}\codeinput{bench/self_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/self.erl}

%% \newpage
%% \section{Spawn}
%% \subsection{Termite}\codeinput{bench/spawn.scm}
%% \subsection{Gambit}\codeinput{bench/spawn_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/spawn.erl}

%% \newpage
%% \section{Ring}

%% \subsection{Termite}\codeinput{bench/ring.scm}
%% \newpage
%% \subsection{Gambit}\codeinput{bench/ring_gambit.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/ring.erl}

%% \newpage
%% \section{Ping-pong}

%% \subsection{Termite}\codeinput{bench/pingpong.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/pingpong.erl}


%% \newpage
%% \section{``Migration''}

%% \subsection{Termite}\codeinput{bench/migrate.scm}

\end{document}
