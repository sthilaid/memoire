\documentclass[12pt,oneside,letterpaper,francais]{book}

%% \documentclass[12pt]{report}

\usepackage[french, english]{babel}
%\usepackage{isolatin1}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{setspace}
\usepackage{verbatim}

\usepackage{udem_these_fr}

\newcommand{\todo}[1]{[TODO: {\it #1}]}

%\newcommand{\object}[1]{$\#<#1 \ldots>$}
\newcommand{\object}[1]{{\it #1}}

\input{r5rscommands.tex}

\newcommand{\codeinput}[1]{\begin{singlespace}\verbatiminput{#1}\end{singlespace}}
\newcommand{\schemeinput}[1]{\begin{schemecode}\input{#1}\end{schemecode}}

\newcommand{\scheme}[1]{\selectlanguage{english}{\tt #1}\selectlanguage{french}}
\newcommand{\schemeresult}[1]{{\tt #1}}

%% \hyphenation{ex-écu-tion} %% marche pas a cause de l'accent

\title{Développement de jeux vidéo en Scheme}

% remplir les champs...
\Auteur{David}{St-Hilaire}

\President{M.}{Mostapha}{Aboulhamid}{Ph.D.}

\Directeur{M.}{Marc}{Feeley}{Ph.D.}

\Membres{1}{M.}{Yann-Gaël}{Guéhéneuc}{Ph.D.}

%pour le doctorat seulement

%examinateur externe
%\Membres{2}{M.}{Membre}{deux}{Ph.D.}
%
%%representant du doyen de la FES
%\Membres{3}{M.}{Membre}{trois}{Ph.D.}

%Pour un doctorat, changer simplement \MSc par \PhD
%titre: 15 mots, max. 175 caractère
\MSc{Dévelopment de jeux vidéo en Scheme}
    {}
    {d'informatique et de recherche op\'{e}rationnelle}
    {informatique}
    {Décembre}
    {2009}

\setstretch{2}
\begin{document}

\setcounter{page}{1}
 \PagesCouverture

\resume


\vspace{2em}

\noindent {\bf Mots clés}: Language de programmation fonctionnels,
Scheme, jeux vidéo, programmation orientée objet.

\abstract

\selectlanguage{english}


\vspace{2em}

\noindent {\bf Keywords}: Functional programming languages, Scheme,
video games, object oriented programming.


\selectlanguage{french}

%% \maketitle
 
\tabledesmatieres

% \listedestableaux

\listedesfigures

% \listedesannexes

\remerciements

blablabla

% \preface
% 
% Préface...

\debutchapitres

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

L'industrie du jeu vidéo devient de plus en plus importante dans le
domaine de l'informatique. Cette croissance est bien reflétée par
l'augmentation de 28\% des revenus provenant de la vente de jeux vidéo
aux États-Unis durant l'année 2007~\cite{NPD_Games_2007}. La place
occupée par l'industrie du jeu vidéo durant cette même année s'estime
à 76\% du marché de tous les logiciels vendus~\cite{NPD_Soft_2008}. 

L'engouement du marché du jeu vidéo ouvre les portes aux compagnies
oeuvrant dans le domaine à repousser les limites de l'état de l'art du
développement de jeux. La compétition est féroce et donc beaucoup
d'efforts doivent être appliqués à la création d'un jeu afin qu'il se
démarque de la masse et devienne un nouveau \og Blockbuster Hit
\fg. Le président de la compagnie Française UbiSoft estime que le coût
moyen de développement d'un jeu sur une console moderne se situe entre
20 et 30 millions de dollars~\cite{cbc_ubisoft}. Si l'on estime le
salaire moyen d'un artiste ou d'un développeur de jeu vidéo à 60
000\$/année, cela reviendrait à un travail d'environ 300 à 500
hommes/année.

Puisque la création d'un jeu vidéo peu nécessiter autant d'efforts, il
semble très intéressant de vouloir tenter de faciliter le
développement de ces derniers. Avec autants d'efforts mis en place,
même une petite amélioration sur le cycle de développement peu
engendrer une diminution énorme des coûts de production et aussi
améliorer la qualité des environnements utilisés par les développeurs.

Jusqu'à ce jour, la grande majorité des jeux vidéo sont écrit dans des
langages de relativement bas niveau, comme par exemple en C, C++ ou
encore C\#~\cite{CSHARP_SPEC}. Ces langages sont généralement utilisés
parce que la main d'oeuvre est facilement accessible et sont déjà des
langages bien établis. 

Les langages de haut niveaux sont généralement caractérisés par le
fait qu'ils font une bonne abstraction du système utilisé et
permettent d'utiliser ces abstraction de manière naturelle et donc
facilitent le travail de programmation. Le coût de ces abstractions se
répercute généralement en un coût de performance du programme. Dans le
passé, la performance était critique dans les jeux vidéo, mais les
consoles modernes sont devenues plus performantes que la plus part des
ordinateurs personnels et donc, actuellement la performance n'est plus
aussi important de nos jours. Aussi, les améliorations de le domaine
de la compilation de langages de haut niveaux font en sorte que les
performances de ces systèmes sont comparables à l'utilisation de
langages de plus bas niveaux.

Ainsi, l'utilisation de langages de plus haut niveaux pourrait
potentiellement améliorer les délais occasionnés par les cycles de
développement des jeux en permettant aux programmeurs et designers de
s'exprimer plus facilement. Le langage de programmation
Scheme~\cite{R5RS} semble être un bon candidat en tant que langage de
haut niveau. En effet, le langage Scheme offre les fonctionnalités de
haut niveau suivantes:

\begin{itemize}
\item Typage dynamique
\item Fonctions de premier ordre
\item Système de macros évolué
\item Accès direct aux continuations du calcul
\item Un système de déboggage très efficace
\end{itemize}

Ces particularités du langages Scheme sont discutées plus en détail
dans le chapitre \ref{Chap:Scheme}. 

Le système Gambit-C, l'une des implantations de Scheme les plus
performantes~\cite{GAMBIT_BENCHMARKS} sera utilisée pour effectuer les
expérience pratiques. Ce système comporte de nombreuses extensions
pouvant être très utiles au développement de jeux vidéo. On y retrouve
entre autres des tables de hachages ou des \textit{threads} (processus
légers).

Il semble donc qu'une utilisation judicieuse de ce système pourrait
faire bénéficier des projets aussi complexes que le sont les
productions de jeux vidéo.

\section{Problématique}
Ce mémoire de maîtrise vise à répondre à la problématique suivante:

\begin{quote}
  Quelles sont les forces et les faiblesses du langages de
  programmation Scheme pour le développement de jeux vidéo.
\end{quote}

\section{Méthodologie}

%% Afin de pouvoir répondre à la problématique posée, nous avons utilisé
%% l'approche

%% \begin{itemize}
%% \item Dev 1er jeu simple pour determiner les besoins pour Scheme
%% \item Augmenter Scheme pour repondre a ces besoins
%% \item Ecrire un nouveau jeu utilisant les techniques developpees pour le 1er jeu
%% \end{itemize}

Afin de pouvoir répondre à la problématique posée, nous avons étudié
les caractéristiques de Scheme et du compilateur Gambit-C, ainsi que
les besoins au niveau du développement de jeux vidéo. Concurremment, 2
jeux ont été développés pour raffiner nos approches et les évaluer
dans un contexte réel.

Le premier jeux a servi de plate-forme d'exploration permettant
d'élaborer une méthodologie qui semble efficace pour le développement
de jeux. Afin d'obtenir une telle méthodologie, plusieurs itérations
de développement ont été effectuées, chacune permettant d'explorer de
nouveaux aspects sur la manière de résoudre les problématiques
associées à la création de jeux, comme par exemple comment arriver à
synchroniser des entités dans le jeux ou comment arriver à décrire
efficacement un système de détection et de résolution de collisions.

Suite à l'écriture de ce jeu, un deuxième jeu, plus complexe, a été
développé afin de consolider les techniques précédemment utilisées et
étendre ces techniques dans le cadre de se nouveau jeu comportant de
nouveaux défi, comme l'implantation d'une intelligence artificielle.



\section{Aperçu du mémoire}
Ce mémoire est composé de quatre parties. La première partie est une
introduction qui traite de programmation fonctionnelle, du langage de
programmation Scheme et des outils de développement disponibles, en
particulier le compilateur Gambit-C. Ce chapitre donne un aperçu
général de ces langages et permet de saisir les concepts fondamentaux
du langage Scheme. Une présentation de l'industrie des jeux vidéo et
des défis découlant du développement suit ce chapitre.

La deuxième partie du mémoire porte sur des extensions faites au
langage Scheme qui ont été utilisées dans le but d'améliorer le
développement de jeux vidéo. On y présente la programmation orientée
objet et un système d'objets conçu pour répondre aux besoins de la
programmation de jeux vidéo. Un système de coroutines conçu dans les
mêmes optiques est également présenté.

La troisième partie du mémoire porte sur l'expérience acquise par
l'auteur en effectuant l'écriture de 2 jeux vidéo simples, mais
possédant suffisamment de complexité pour exposer les problèmes
associés à la création de jeux vidéo et comment tirer profit du
langage de programmation Scheme pour résoudre ces problèmes. Une
présentation des travaux reliés aux résultats présentés suit ce
dernier chapitre. On y parle de l'utilisation de d'autres langages
pour le développement de jeux vidéo et cite des exemple d'utilisation
du langage Scheme dans des jeux vidéo commerciaux et de l'expérience
tirée de cette utilisation par les développeurs.

Finalement, une conclusion apporte la lumière sur la problématique
exposée dans ce mémoire. Le point sur l'expérience acquise pour le
développement de jeux vidéo en Scheme y est fait et les avantages et
inconvénients ou problèmes obtenus seront exposés.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Développement de jeux vidéo}

\todo{Importance du marche des JV}

\todo{Diversite des jeux (genres, plates-formes)}

\todo{Charactéristiques de jeux modernes}

Les jeux vidéo font parti d'un domaine de l'informatique en pleine
effervescence grâce à une demande constante de nouveaux produits. Ces
produits possèdent plusieurs caractéristiques de qualité auxquelles
les consommateurs s'attendent à obtenir en effectuant l'acquisition
d'un nouveau titre. Ces attentes du consommateur peuvent se traduire
par les besoins suivant:

\todo{mettre ici une liste des attentes pour un jeu moderne}

\section{Historique}

%% http://en.wikipedia.org/wiki/History_of_video_games

\subsection{préhistoire 1948-1970}
\todo{CRT games, Mainframe games}

\subsection{Système arcade 1970-1985}
\todo{Pong, Space Invaders, Pac-Man}

\subsection{Premières consoles 1972-1984}
\todo{Magnavox Odyssey, Atari XX00 et ColecoVision}

\subsection{Ordinateurs personnels 1977-...}
\todo{Évolution parallèle constante}

\todo{Toujours été jusqu'à la venu des console modernes la plate-forme
  offrant les meilleurs performances.}

\subsection{Consoles portables 1980-...}
\todo{GameBoy etc...}

\subsection{Consoles intermédiaires 1984-2006}
\todo{NES, SNES, N64, GameCube}

\subsection{Consoles modernes 2005-...}
\todo{Interfaces plus 'casual' = Wii}

\todo{Consoles très performantes}




\section{Contraintes de programmation}

\subsection{fluidité}

\subsubsection{Taux de rafraîchissement}
\subsubsection{Réponse quasi temps réelle}

\subsection{Modularité}

\subsubsection{Complexité des jeux ... gros logiciels}
\subsubsection{Développement itératif ... plusieurs modifications du système}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Le langage Scheme}
\label{Chap:Scheme}

\todo{Choix du langage influence beaucoup la structure du code, le manière
  de développer le logiciel, etc...}

\todo{Scheme est un langage qui semble être peu utilisé dans des
  produits commerciaux.}

\todo{d'autres idées?}

\todo{Référence temporaire pour pas faire planter le makefile\cite{SICP}}

\section{Héritage de LISP}
\subsection{Histoire de LISP}
\todo{McCarthy, GC, List Processing, AI...}

\todo{Common LISP = Grosse Bébitte}

\subsection{Avènement de Scheme}
\todo{Épuration de LISP à l'essence du langage}

\todo{évolution du langage via RNRS, SRFIs}

\todo{simplicité du langage, beaucoup d'extension disponibles }

\subsection{Langages inspirés de Scheme}
\todo{Javascript, Ruby: lang de scripting. Concept de fermetures}

\todo{Java??}

\section{Programmation fonctionnelle}
\subsection{Distinction}
\todo{Fonctions sont des données de premier ordre}
\todo{Fonctions d'ordres supérieures (avec exemples)}

\subsection{Programmation fonctionnelle pure}
\todo{Pas de mutation. Comme des blocs lego}

\todo{Haskell, ML}

\todo{Exemple en Scheme}


\subsection{Effets de bords dans Scheme}
\todo{Entrees sorties (variables à portée dynamique)}
\todo{Mutations de variables}


\section{Macros}
\subsection{Introduction}
\todo{Discussion sur les macros de C et leurs limitations: permet de
  faire des abstractions dans le code résultant une modification du
  code source avant la compilation, mais uniquement limité à du
  remplacement de code.}

\todo{Explication des macros scheme: Code source == données scheme,
  dispose d'une pré-évaluation permettant de prendre du code source en
  entré et de généré du code source (toujours sous forme de listes
  (données Scheme)). Revient a faire une manipulation d'ASA.}

\todo{Dispose de toute la puissance de calcul durant l'expansion :)}

\subsection{Exemples simples}

\todo{macro inc}

\todo{macro while}

\subsection{Problème de l'hygiène des macros}

\todo{Capture de nom intentionnelle, ou non intentionnelle. }

\todo{Différentes formes spéciales (define-macro, define-syntax)}



\section{Continuations}
\subsection{Introductions du sujet et explications}
\todo{En C, continuation equiv au code situé à l'adresse de retour de
  la fonction exécutée.}

\todo{Explication de l'ordre dévaluation en Scheme.}

\todo{Continuation d'un programme simple en Scheme. (+ 1 (- [f x y]
  2)) : continuation de l'appel à f est la soustraction du résultat
  par deux, puis l'on ajoute à 1 se résultat. Eq à (lambda (res-f) (+
  1 (- res-f 2))).}

\subsection{Réification de continuations}
\todo{Explication de call-with-current-continuation permettant de faire}
\todo{surfacer une continuation.}

\subsection{Exemples d'utilisations}
\subsubsection{Échappement au flux de contrôle}
\todo{Utilisation comme un return}

\subsubsection{Système de coroutine}
\todo{Exemple du cours de Marc}

\subsection{Forme d'écriture de code en CPS}
\todo{Expliquer la différence entre un appel terminal et un appel
  non-terminal. Expliquer comment les appels terminaux peuvent être
  optimisés (requis en Scheme).}

\todo{Écrire le code de manière à rendre explicite le passage et les
  appels de continuations. Toujours des appels
  terminaux. Transformation souvent utilisée par les compilateurs pour
  implanter l'optimisation d'appels terminaux.}

\subsection{Exemple d'implantation}
\todo{Exemple du cours de Marc}


\section{Dynamisme du langage}
\todo{Typage dynamique vs typage statique}

\todo{Exemple de code utilisant le typage dynamique.}

\todo{Evaluation dynamique de code avec load ou eval. idées?}

\todo{Langages comme C++ favorisent bcp de focuser sur la conceptions des
  classes. Implique une structure rigide qui se doit d'être bien conçu
  depuis le départ.}

\todo{Langages plus dynamiques permettent des cycles de prototypage
  rapide en apportant beaucoup de flexibilité aux développeurs.}


\section{Gestion mémoire automatique}
\subsection{Motivation}
\todo{Gestion mémoire manuelle ou semi-automatique causent énormément
  de problèmes de fuites de mémoire (ou de pointeurs fous).}

\todo{En connaissant les racines, on peut automatiser la récupérations
  de mémoire, au coût d'un certain temps de calcul.}

\todo{Date des premières version de LISP.}



\subsection{Survol des techniques}
\todo{Mark and sweep}

\todo{Stop and copy}

\todo{GC générationnels}

\todo{GC temps réels ou incrémentaux}



\section{Débuggage}
\todo{Possibilité de pouvoir exécuter du code arbitraire lors d'un
  crash}

\todo{Possibilité de pouvoir inspecter chacune des frames de la pile
  de continuactions afin de pouvoir obtenir de l'info sur
  l'environnement de celui-ci, l'endroit dans le code source où la
  continuation se trouve et même de pouvoir exécuter du code dans
  l'environnement d'une continuation de la pile choisie.}

\todo{Possibilité de faire le déboggage à distance (ex: iPhone)}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Programmation orientée objet}

\todo{Parler des define-type de Gambit-C et du SRFI-9}

\todo{Approche traditionnelle de la prog OO: Surdéfinition de méthodes de
  classe, héritage simple, polymorphisme, etc...}

\todo{Parler de CLOS: intégré à Common LISP, fonctions génériques, héritage
  multiple}

\todo{Besoins pour jeux vidéo}

\section{Description du langage}
\todo{Langage orienté objet qui a pour but d'être efficace tout en
  apportant l'expressivité offerte par la programmation orientée
  object à la CLOS.}

Résumé des fonctionnalités:
\begin{itemize}
\item Accès aux membres rapide
\item Héritage multiple
\item Polymorphisme
\item Fonctions génériques à \og dispatch \fg multiple
\end{itemize}

\subsection{Définition de classes}
\todo{Compatibilité avec les define-type}

\todo{Définitions simples (instance slots et class slots)}

\todo{Héritages des membres}

\todo{Utilisation de hook sur les slots}

\todo{Constructeurs}


\subsection{Définition de fonctions génériques}
\todo{Dispatch simple}

\todo{Dispatch multiple (avec les problèmes reliés à la résolution de la méthode à choisir)}

\todo{call-next-method}

\todo{Type '*'}

\subsection{Fonctions et formes spéciales utilitaires}

\todo{Vérifications manuelles de typages et introspections
  (instance-object?, instance-of?, find-class?, get-class-id,
  is-subclass?, get-supers)}




\section{Implantation}
\todo{Apercu global: Utilisation de macros scheme pour effectuer la
  génération de code nécessaire au fonctionnement du système.}

\todo{Séparation entre le travail fait durant l'expantion macro et
  l'exécution}

\todo{Passage d'informations entre le moment de l'expansion et
  l'exécution (informations sur les classes, les fonctions génériques,
  etc...)}

\subsection{Implantation de define-class}
\todo{Structures de données (descripteurs de classes, format des
  instances, etc..)}

\todo{Polymorphisme: chaque index dans les descripteurs de classes
  sont orthogonaux (implique que les descripteurs grossissent
  linéairement en fonction du nombre de classes) et passage aux
  classes enfants des indexes utilisés par les parents.}

\todo{Constructeurs et describe comme fonctions génériques}

\subsection{Implantation de define-generic}
\todo{Registre des méthode: Conservations d'informations sur les
  fonctions génériques et leurs instances }

\todo{Implantation du polymorphisme des fonctions génériques}

\todo{Implantation du call-next-method faite avec l'utilisation de
  variables à portée dynamique}

\todo{Coût de l'utilisation des fonctions génériques}

\subsection{Implantation de define-method}
\todo{Stockages des fermetures durant l'expansion macro et l'exécution}




\section{Conclusion}
\todo{Ouverture sur le fait qu'un meta-protocole serait très intéressant à
  ajouter, mais à quel prix?}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Système de coroutines}
\todo{Système de threads offerts ne sont pas toujours
  satisfaisant. Mentalité Scheme: au lieu de contraindre ce qu'on veut
  faire en fonction de ce qui nous est offert, étendre le langage pour
  nous permettre de faire ce que l'on veut et surtout de la manière
  désirée.}

\todo{Implantation de son propre système: contrôle fin du comportement
  de threads}

\todo{Parler de Termite: Calcul distribué sur plusieurs
  noeuds. Synchronisation par passage de message. Communication via
  TCP/IP.}

\todo{Motivation de l'utilisation de coroutines (contrôle exact sur le
  flot de contrôle == système toujours dans un état consistant).}

\section{Description du langage}
\todo{Idée sur nos coroutines}

\todo{Systèmes récursifs}

\todo{Timers: abstraction du temps écoulé permettant l'accélération ou
  le ralentissement de l'exécution d'une simulation.}

\subsection{Création de coroutines}
\todo{Création d'une coroutine détachée du système: (new corout <id>
  <thunk>)}

\todo{intégrée au système via le démarrage (boot) ou via une autre
  coroutine (spawn-brother)}

\subsection{Manipulation du flot de contrôle}
\subsubsection{yield} 
\todo{Transfert à la prochaine coroutine}

\subsubsection{super-yield} 
\todo{Transfert au prochain système de coroutine (frère du système courant).}

\subsubsection{terminate-corout, kill-all!, super-kill-all!}
\todo{Terminaison de coroutines. }

\subsubsection{sleep-for}
\todo{Sommeil pour un temps prédéterminé.}

\subsubsection{continue-with}
\todo{Continuation de la coroutine.}

\subsubsection{spawn-brother, spawn-brother-thunk}
\todo{Démarrage de nouvelles coroutines.}

\subsubsection{Composition of coroutines}
\todo{Compositions ou séquençage de coroutine}

\subsection{Système de communication inter coroutines}
\subsubsection{!} 
\todo{Envoi de message à une coroutine}

\subsubsection{?}
\todo{Réception d'un message bloquante (avec possibilité de timeout)}

\subsubsection{??}
\todo{Réception sélective de message bloquante (avec possibilité de timeout)}

\subsubsection{recv, dynamic msg handlers}
\todo{Forme spéciale permettant la réception sélective de messages via
  un \og pattern matching \fg qui permet une notation concise et
  l'utilisation aisée du contenu des messages reçus.}

\subsubsection{Messaging lists}
\todo{Système permettant de regrouper des coroutines et de leurs
  diffuser des messages. }

\subsection{Démarrage du système}
\subsubsection{simple-boot}
\todo{Démarrage rapide du système.}

\subsubsection{boot}
\todo{Démarrage permettant de spécifier un timer spécifique à
  l'utilisation et une fonction personnalisée effectuant la gestion
  des valeurs de retour des coroutines.}

\todo{Systèmes cascadés?}


\section{Implantation}

\subsection{Implantation des coroutines}

\todo{Structure de données}

\todo{États d'une coroutines}

\subsection{Scheduler}
\todo{Abstraction du temps via timer}

\todo{États du scheduler}

\todo{Algorithme de scheduling}

\subsection{Système de messagerie}
\todo{Structures de données}

\todo{Envoi de messages}

\todo{Réception de messages}

\todo{Macro recv}


\section{Conclusion}
\todo{Ouverture sur le profilage des coroutine}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Évaluation et expériences}

Développement de jeu fait ayant comme but de trouver les problèmes
rencontrés durant la création de jeux vidéo et de proposer des
méthodes pour résoudre ces problèmes.

Aussi, on cherche à identifier les avantages que nous a fourni Scheme
et à identifier les incovénients que pose l'utilisant du langage
Scheme pour le développement de ces jeux.

Débute par un jeu simple afin de trouver les problèmes de base et
trouve des solutions à ces problèmes.

Ensuite, un deuxième jeu a été écrit afin de consolider les solutions
trouvées précédemment et de potentiellement trouver d'autres problèmes
reliés aux nouvelles complexité présentent dans ce deuxième jeu.

\section{Développement de \og Space Invaders \fg}

\subsection{Objectifs}
\todo{Expérimentation avec un jeu très simple}

\todo{Trouver les problèmes fondamentaux pour le développement de jeux}

\todo{Tenter de les résoudre}

\subsection{Version initiale}
\todo{Premier jet dans le but de trouver des problèmes potitiels}

\begin{itemize}
\item Comment faire des animations? => CPS
\item Comment concevoir une partie a 2 joueurs? => coroutines
\item Difficulté à décrire la résolution de collision de manière
  efficace 
\item Est-il possible d'écrire le comportement d'une entité de manière
  indépendante, i.e. que le code soit centralisé dans une même
  fonction?
\end{itemize}

\subsection{Version orientée objet}
\todo{Motivation: Utilisation de fonctions génériques}

\todo{Hierarchie de classe}

\todo{Code Highlight: Résolution de collisions}


\subsection{Version avec système de co-routine}
\todo{Motivation: Intégrer les coroutines a chaque objet de manière à
  ce que chaque instance soit une entité à part entière qui doit régir
  son propre comportement.}

\todo{Difficultés: synchronisation des entités}

\todo{Code Highlight: synchronisation des invaders}


\subsection{Conclusion}
\todo{Trouvé plusieurs problèmes et pu résoudres ces derniers}

\todo{Utilisation d'un système object a grandement contribué à
  améliorer le code du jeu.}

L'intégration du système de coroutines aux objets du jeu a causé plus
de problème qu'elle en a résolu. L'utilisation des coroutines serait
mieux d'être limité à l'implantation du jeu multijoueur.

\todo{ouverture: Essayer ces techniques dans un jeu plus complexe pour
  voir si elles sont toujours valides}


\section{Développement de \og Lode Runner \fg}
\subsection{Objectifs}
\todo{Jeux plus complexe: plus d'interaction du joueur, intelligence
  artivicielle, niveaux, schema d'animations plus complexe, etc...}

\todo{Utiliser ce qui semblait de meilleur dans space-invaders de
  manière a non seulement confirmer la pertinance de ces methodes,
  mais aussi a potentiellement en developper de nouvelles dû aux
  nouvelles contraintes de ce jeu.}

\subsection{Synchronisation}
\todo{Utilisation du concept de frame pour faire la synchro. (manière
  traditionnelle) Réduit de beaucoup la complexité.}

\todo{Danger si le framerate varie, la vitesse du jeu varie.}

\subsection{Machines à états}
\todo{Utiliation des fonctions génériques}

\todo{Utilisez un LSD pour ca??? Des idées?}

\subsection{Intelligence Artificielle}
\subsubsection{À venir...}

\subsection{Conclusion}
\subsubsection{À venir...}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\chapter{Mesures de performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Travaux reliés}

Dans un premier temps, il serait intéressant de comparer les
différents langages utilisés dans l'industrie du jeu vidéo avec Scheme
afin d'en faire ressortir les différences. Ces différences mènent
directement à une méthode de développement qui seront complètement
différentes.

Scheme a déjà été utilisé pour produire des jeux vidéo commerciaux de
très bonne qualité. Certains seront cités et une revue de l'expérience
acquise par les développeurs sera exposée.

\section{Comparaison de langages}

\subsection{Lua}
Langage utilisé très fréquemment pour effectuer le \og scripting \fg
dans les jeu vidéo.

Differences entre lua et Scheme
\begin{itemize}
\item Lua est de petite taille en mem
\item ..
\end{itemize}

\subsection{C++}
Langage principal de développement de jeu vidéo en industrie.

Differences entre Scheme et C++
\begin{itemize}
\item Gestion memoire manuelle vs GC
\item méthode surdéfinies vs fonctions génériques
\item ...
\end{itemize}


\section{Jeux en Lisp}

\subsection{QuantZ}
Jeu de type \og casual \fg de très bonne qualité écrit presque
entièrement en Scheme.

À voir avec Robert

FRP?

Techniques anti-gc

Delegation de fermetures

\subsection{Naughty Dogz}
Compagnie très connue associée à Sony qui utilisent Scheme pour
produire leurs jeux vidéo.

\subsubsection{GOAL}
Compilateur Scheme utilisé pour produire les jeux sur PlayStation 2

%% http://en.wikipedia.org/wiki/Game_Oriented_Assembly_Lisp
%% http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\begin{itemize}
\item http://en.wikipedia.org/wiki/Game\_Oriented\_Assembly\_Lisp
\item http://grammerjack.spaces.live.com/blog/cns!F2629C772A178A7C!135.entry
\end{itemize}

\subsubsection{Drake's uncharted Fortune}

%%http://bc.tech.coop/blog/060118.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}


L'expérience d'écriture de ces jeux aura permis de faire le point sur
les avantages et les inconvénients de l'utilisation d'un langage tel
que Scheme pour le développement de jeu vidéo.


\begin{itemize}
  \item[+] puissance d'expression / d'abstraction
  \item[+] langage dynamique (développement en-direct, malléabilités)
  \item[+] création de langages spécifiques au domaine

  \item[-] Garbage Collection et sur-allocation
  \item[-] Profilage plus difficile avec des LSD (pour Gambit-C et statprof)
  \item[-] Balance entre abstraction et efficacité
\end{itemize}


%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%chapter{Bibliographie}

\setstretch{1}
\bibliographystyle{unsrt} %% or maybe plain or abbrv
\bibliography{memoire}

%%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
% TODO: ce compteur doit être ajusté à la main 
% \setcounter{page}{99}

%% \chapter{Code des exemples}

%% \section{Compte de banque}

%% \subsection{Compte de banque en Java}\label{account_java}

%% \subsubsection{Classe Account}
%% \codeinput{bank/Account.java}

%% \subsubsection{Interface RemoteAccount}
%% \codeinput{bank/RemoteAccount.java}

%% \subsubsection{Classe LogRecord}
%% \codeinput{bank/LogRecord.java}

%% \subsubsection{Classe AccountServer}
%% \codeinput{bank/AccountServer.java}

%% \subsubsection{Classe AccountClient}
%% \codeinput{bank/AccountClient.java}

%% %% \subsection{Compte de banque en Termite}\label{account_termite}
%% %% \schemeinput{bank/account.scm}

%% \newpage 

%% \section{Serveur générique: genserver.scm}
%% \schemeinput{genserver.scm}

%% %% \section{Superviseur générique: supervisor.scm}
%% %% 
%% %% \schemeinput{supervisor.scm}

%% \newpage

%% \section{Définition de type}\label{define_termite_type}
%% \schemeinput{deftype.scm}

%% \newpage
%% \chapter{Code des tests de performance}

%% \section{Fibonacci}

%% \subsection{Scheme}\codeinput{bench/fib.scm}
%% \subsection{Erlang}\codeinput{bench/fib.erl}

%% \newpage
%% \section{Takeuchi}

%% \subsection{Scheme}\codeinput{bench/tak.scm}
%% \subsection{Erlang}\codeinput{bench/tak.erl}

%% \newpage
%% \section{Inversion naïve}
%% \subsection{Scheme}\codeinput{bench/nrev.scm}
%% \subsection{Erlang}\codeinput{bench/nrev.erl}

%% \newpage
%% \section{Quick Sort}
%% \subsection{Scheme}\codeinput{bench/qsort.scm}
%% \subsection{Erlang}\codeinput{bench/qsort.erl}


%% \newpage
%% \section{Smith Waterman}
%% \subsection{Scheme}\codeinput{bench/smith.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/smith.erl}

%% \newpage
%% \section{Self}
%% \subsection{Termite}\codeinput{bench/self.scm}
%% \subsection{Gambit}\codeinput{bench/self_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/self.erl}

%% \newpage
%% \section{Spawn}
%% \subsection{Termite}\codeinput{bench/spawn.scm}
%% \subsection{Gambit}\codeinput{bench/spawn_gambit.scm}
%% \subsection{Erlang}\codeinput{bench/spawn.erl}

%% \newpage
%% \section{Ring}

%% \subsection{Termite}\codeinput{bench/ring.scm}
%% \newpage
%% \subsection{Gambit}\codeinput{bench/ring_gambit.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/ring.erl}

%% \newpage
%% \section{Ping-pong}

%% \subsection{Termite}\codeinput{bench/pingpong.scm}
%% \newpage
%% \subsection{Erlang}\codeinput{bench/pingpong.erl}


%% \newpage
%% \section{``Migration''}

%% \subsection{Termite}\codeinput{bench/migrate.scm}

\end{document}
