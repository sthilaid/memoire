Expansion:

('#<procedure #2 eval>
 '(define-macro (make-meroon-macro-pervasive)
    (list 'eval
          ''(begin
              (define-macro (define-meroon-macro call . body)
                `(begin
                   (eval '(define-macro ,call . ,body))
                   (define-macro ,call . ,body)))
              (define-macro (define-internal-meroon-macro call . body)
                `(define-macro ,call . ,body))
              #t))))

(define *meroon-features*
  '(gambit C 2.7 DSSSL pervasive-meroon-macros inline-predicate))

#t

('#<procedure #2 eval>
 '(define-macro (meroon-define call . body) `(define ,call . ,body)))

#t

#t

#t

('#<procedure #2 eval>
 '(define-macro (define-class . definition)
    (check-and-process-class-definition definition)))

('#<procedure #2 eval>
 '(define-macro (define-generic call . body)
    (process-define-generic-form call body)))

('#<procedure #2 eval>
 '(define-macro (define-method call . body)
    (process-define-method-form call body)))

('#<procedure #2 eval>
 '(define-macro (define-handy-method call . body)
    (process-define-handy-method call body)))

('#<procedure #2 eval>
 '(define-macro (duplicate desc . parms) (process-duplicate-form desc parms)))

('#<procedure #2 eval>
 '(define-macro (instantiate-from desc . parms)
    (process-instantiation-from-form desc parms)))

('#<procedure #2 eval>
 '(define-macro (modify desc . parms) (process-modify-form desc parms)))

('#<procedure #2 eval>
 '(define-macro (instantiate class-name . parms)
    (process-instantiate-form class-name parms)))

('#<procedure #2 eval>
 '(define-macro (co-instantiate . definitions)
    (process-co-instantiate-form definitions 'set!)))

('#<procedure #2 eval>
 '(define-macro (with-co-instantiation definitions . body)
    (process-with-co-instantiation-form definitions body)))

('#<procedure #2 eval>
 '(define-macro (with-access ins-tance specs . body)
    (process-with-access-form ins-tance specs body)))

('#<procedure #2 eval>
 '(define-macro (careless-Generic-dispatcher g) `(instance-ref ,g 3)))

('#<procedure #2 eval>
 '(define-macro (careless-Class-number class) `(instance-ref ,class 1)))

('#<procedure #2 eval>
 '(define-macro (careless-Class-allocator class) `(instance-ref ,class 7)))

('#<procedure #2 eval>
 '(define-macro (careless-Dispatcher-method-finder d) `(instance-ref ,d 0)))

('#<procedure #2 eval>
 '(define-macro (define-view . definition)
    (check-and-process-view-definition definition)))

(define dsssl-optional?
  (lambda (thing) ('#<procedure #3 ##eq?> thing #!optional)))

(define dsssl-rest? (lambda (thing) ('#<procedure #3 ##eq?> thing #!rest)))

(define dsssl-key? (lambda (thing) ('#<procedure #3 ##eq?> thing #!key)))

('#<procedure #2 eval> '(define-macro (subtype-meroon) 6))

('#<procedure #2 eval> '(define-macro (starting-offset) 1))

('#<procedure #2 eval> '(define-macro (meroon-safer-object) #f))

('#<procedure #2 eval>
 '(define-macro (instance-ref o offset)
    `(let ((o ,o) (offset ,offset))
       (declare (standard-bindings) (not safe))
       (meroon-ref o (fx+ (starting-offset) offset)))))

('#<procedure #2 eval>
 '(define-macro (instance-set! o offset value)
    `(let ((o ,o) (offset ,offset) (value ,value))
       (declare (standard-bindings) (not safe))
       (meroon-set! o (fx+ (starting-offset) offset) value))))

('#<procedure #2 eval>
 '(define-macro (object->class-number o) `(let ((o ,o)) (meroon-ref o 0))))

('#<procedure #2 eval>
 '(define-macro (instance cn . args)
    `(let ()
       (declare (extended-bindings) (not safe))
       (##subtype-set! (##vector ,cn ,@args) (subtype-meroon)))))

#t

#t

(define every?
  (lambda (p . args)
    (letrec ((andmap (lambda (p args value)
                       (if (letrec ((any-at-end?
                                     (lambda (ls)
                                       (and ('#<procedure #4 ##pair?> ls)
                                            (or ('#<procedure #5 ##not>
                                                 ('#<procedure #4 ##pair?>
                                                  ('#<procedure #6 ##car> ls)))
                                                (any-at-end?
                                                 ('#<procedure #7 ##cdr>
                                                  ls)))))))
                             (any-at-end? args))
                           value
                           (let ((value ('#<procedure #8 apply>
                                         p
                                         (letrec ((loop2.721
                                                   (lambda (lst2.722)
                                                     (if ('#<procedure #4 ##pair?>
                                                          lst2.722)
                                                         (let ((x.723 ('#<procedure #9 car>
                                                                       ('#<procedure #6 ##car>
                                                                        lst2.722))))
                                                           ('#<procedure #10 ##cons>
                                                            x.723
                                                            (loop2.721
                                                             ('#<procedure #7 ##cdr>
                                                              lst2.722))))
                                                         '()))))
                                           (loop2.721 args)))))
                             (and value
                                  (andmap p
                                          (letrec ((loop2.726
                                                    (lambda (lst2.727)
                                                      (if ('#<procedure #4 ##pair?>
                                                           lst2.727)
                                                          (let ((x.728 ('#<procedure #11 cdr>
                                                                        ('#<procedure #6 ##car>
                                                                         lst2.727))))
                                                            ('#<procedure #10 ##cons>
                                                             x.728
                                                             (loop2.726
                                                              ('#<procedure #7 ##cdr>
                                                               lst2.727))))
                                                          '()))))
                                            (loop2.726 args))
                                          value)))))))
      (andmap p args #t))))

(define any?
  (lambda (p . args)
    (letrec ((ormap (lambda (p args value)
                      (if (letrec ((any-at-end?
                                    (lambda (ls)
                                      (and ('#<procedure #4 ##pair?> ls)
                                           (or ('#<procedure #5 ##not>
                                                ('#<procedure #4 ##pair?>
                                                 ('#<procedure #6 ##car> ls)))
                                               (let ((ls ('#<procedure #7 ##cdr>
                                                          ls)))
                                                 (and ('#<procedure #4 ##pair?>
                                                       ls)
                                                      (or ('#<procedure #5 ##not>
                                                           ('#<procedure #4 ##pair?>
                                                            ('#<procedure #6 ##car>
                                                             ls)))
                                                          (any-at-end?
                                                           ('#<procedure #7 ##cdr>
                                                            ls))))))))))
                            (any-at-end? args))
                          value
                          (let ((value ('#<procedure #8 apply>
                                        p
                                        (letrec ((loop2.731
                                                  (lambda (lst2.732)
                                                    (if ('#<procedure #4 ##pair?>
                                                         lst2.732)
                                                        (let ((x.733 ('#<procedure #9 car>
                                                                      ('#<procedure #6 ##car>
                                                                       lst2.732))))
                                                          ('#<procedure #10 ##cons>
                                                           x.733
                                                           (loop2.731
                                                            ('#<procedure #7 ##cdr>
                                                             lst2.732))))
                                                        '()))))
                                          (loop2.731 args)))))
                            (or value
                                (let ((args (letrec ((loop2.736
                                                      (lambda (lst2.737)
                                                        (if ('#<procedure #4 ##pair?>
                                                             lst2.737)
                                                            (let ((x.738 ('#<procedure #11 cdr>
                                                                          ('#<procedure #6 ##car>
                                                                           lst2.737))))
                                                              ('#<procedure #10 ##cons>
                                                               x.738
                                                               (let ((lst2.737
                                                                      ('#<procedure #7 ##cdr>
                                                                       lst2.737)))
                                                                 (if ('#<procedure #4 ##pair?>
                                                                      lst2.737)
                                                                     (let ((x.738 ('#<procedure #11 cdr>
                                                                                   ('#<procedure #6 ##car>
                                                                                    lst2.737))))
                                                                       ('#<procedure #10 ##cons>
                                                                        x.738
                                                                        (loop2.736
                                                                         ('#<procedure #7 ##cdr>
                                                                          lst2.737))))
                                                                     '()))))
                                                            '()))))
                                              (loop2.736 args))))
                                  (if (letrec ((any-at-end?
                                                (lambda (ls)
                                                  (and ('#<procedure #4 ##pair?>
                                                        ls)
                                                       (or ('#<procedure #5 ##not>
                                                            ('#<procedure #4 ##pair?>
                                                             ('#<procedure #6 ##car>
                                                              ls)))
                                                           (any-at-end?
                                                            ('#<procedure #7 ##cdr>
                                                             ls)))))))
                                        (any-at-end? args))
                                      value
                                      (let ((value ('#<procedure #8 apply>
                                                    p
                                                    (letrec ((loop2.731
                                                              (lambda (lst2.732)
                                                                (if ('#<procedure #4 ##pair?>
                                                                     lst2.732)
                                                                    (let ((x.733 ('#<procedure #9 car>
                                                                                  ('#<procedure #6 ##car>
                                                                                   lst2.732))))
                                                                      ('#<procedure #10 ##cons>
                                                                       x.733
                                                                       (loop2.731
                                                                        ('#<procedure #7 ##cdr>
                                                                         lst2.732))))
                                                                    '()))))
                                                      (loop2.731 args)))))
                                        (or value
                                            (ormap p
                                                   (letrec ((loop2.736
                                                             (lambda (lst2.737)
                                                               (if ('#<procedure #4 ##pair?>
                                                                    lst2.737)
                                                                   (let ((x.738 ('#<procedure #11 cdr>
                                                                                 ('#<procedure #6 ##car>
                                                                                  lst2.737))))
                                                                     ('#<procedure #10 ##cons>
                                                                      x.738
                                                                      (loop2.736
                                                                       ('#<procedure #7 ##cdr>
                                                                        lst2.737))))
                                                                   '()))))
                                                     (loop2.736 args))
                                                   value)))))))))))
      (ormap p args #f))))

#t

(define reverse!
  (lambda (l)
    (letrec ((nreverse
              (lambda (l r)
                (if ('#<procedure #4 ##pair?> l)
                    (let ((cdrl ('#<procedure #7 ##cdr> l)))
                      (let ((begin-temp.0 ('#<procedure #12 ##set-cdr!> l r)))
                        (nreverse cdrl l)))
                    r))))
      (nreverse l '()))))

#t

#t

(define meroon-integer->string '#<procedure #13 number->string>)

(define symbol-concatenate
  (lambda names
    ('#<procedure #14 string->symbol>
     ('#<procedure #8 apply>
      '#<procedure #15 string-append>
      (let ((temp.739
             (lambda (thing)
               (if ('#<procedure #16 ##symbol?> thing)
                   ('#<procedure #17 symbol->string> thing)
                   (if ('#<procedure #18 ##string?> thing)
                       thing
                       (if ('#<procedure #19 ##number?> thing)
                           ('#<procedure #13 number->string> thing)
                           (internal-meroon-error
                            "non coercible to String"
                            thing)))))))
        (letrec ((loop2.741
                  (lambda (lst2.742)
                    (if ('#<procedure #4 ##pair?> lst2.742)
                        (let ((x.743 (temp.739
                                      ('#<procedure #6 ##car> lst2.742))))
                          ('#<procedure #10 ##cons>
                           x.743
                           (loop2.741 ('#<procedure #7 ##cdr> lst2.742))))
                        '()))))
          (loop2.741 names)))))))

(define identity (lambda (x) x))

(define iota
  (lambda (start end)
    (if ('#<procedure #20 ##fx<> start end)
        ('#<procedure #10 ##cons>
         start
         (let ((start ('#<procedure #21 ##fx+> 1 start)))
           (if ('#<procedure #20 ##fx<> start end)
               ('#<procedure #10 ##cons>
                start
                (iota ('#<procedure #21 ##fx+> 1 start) end))
               '())))
        '())))

(define meroon-reduce
  (lambda (f end list . lists)
    (letrec ((reduce1 (lambda (f end l)
                        (if ('#<procedure #4 ##pair?> l)
                            (f (let ((l ('#<procedure #7 ##cdr> l)))
                                 (if ('#<procedure #4 ##pair?> l)
                                     (f (reduce1 f
                                                 end
                                                 ('#<procedure #7 ##cdr> l))
                                        ('#<procedure #6 ##car> l))
                                     end))
                               ('#<procedure #6 ##car> l))
                            end))))
      (letrec ((reduce2 (lambda (f end l1 l2)
                          (if (and ('#<procedure #4 ##pair?> l1)
                                   ('#<procedure #4 ##pair?> l2))
                              (f (let ((l2 ('#<procedure #7 ##cdr> l2))
                                       (l1 ('#<procedure #7 ##cdr> l1)))
                                   (if (and ('#<procedure #4 ##pair?> l1)
                                            ('#<procedure #4 ##pair?> l2))
                                       (f (reduce2 f
                                                   end
                                                   ('#<procedure #7 ##cdr> l1)
                                                   ('#<procedure #7 ##cdr> l2))
                                          ('#<procedure #6 ##car> l1)
                                          ('#<procedure #6 ##car> l2))
                                       end))
                                 ('#<procedure #6 ##car> l1)
                                 ('#<procedure #6 ##car> l2))
                              end))))
        (letrec ((reduceN (lambda (f end lists)
                            (if (every? '#<procedure #22 pair?> lists)
                                ('#<procedure #8 apply>
                                 f
                                 (let ((lists (letrec ((loop2.746
                                                        (lambda (lst2.747)
                                                          (if ('#<procedure #4 ##pair?>
                                                               lst2.747)
                                                              (let ((x.748 ('#<procedure #11 cdr>
                                                                            ('#<procedure #6 ##car>
                                                                             lst2.747))))
                                                                ('#<procedure #10 ##cons>
                                                                 x.748
                                                                 (let ((lst2.747
                                                                        ('#<procedure #7 ##cdr>
                                                                         lst2.747)))
                                                                   (if ('#<procedure #4 ##pair?>
                                                                        lst2.747)
                                                                       (let ((x.748 ('#<procedure #11 cdr>
                                                                                     ('#<procedure #6 ##car>
                                                                                      lst2.747))))
                                                                         ('#<procedure #10 ##cons>
                                                                          x.748
                                                                          (let ((lst2.747
                                                                                 ('#<procedure #7 ##cdr>
                                                                                  lst2.747)))
                                                                            (if ('#<procedure #4 ##pair?>
                                                                                 lst2.747)
                                                                                (let ((x.748 ('#<procedure #11 cdr>
                                                                                              ('#<procedure #6 ##car>
                                                                                               lst2.747))))
                                                                                  ('#<procedure #10 ##cons>
                                                                                   x.748
                                                                                   (loop2.746
                                                                                    ('#<procedure #7 ##cdr>
                                                                                     lst2.747))))
                                                                                '()))))
                                                                       '()))))
                                                              '()))))
                                                (loop2.746 lists))))
                                   (if (every? '#<procedure #22 pair?> lists)
                                       ('#<procedure #8 apply>
                                        f
                                        (reduceN f
                                                 end
                                                 (letrec ((loop2.746
                                                           (lambda (lst2.747)
                                                             (if ('#<procedure #4 ##pair?>
                                                                  lst2.747)
                                                                 (let ((x.748 ('#<procedure #11 cdr>
                                                                               ('#<procedure #6 ##car>
                                                                                lst2.747))))
                                                                   ('#<procedure #10 ##cons>
                                                                    x.748
                                                                    (loop2.746
                                                                     ('#<procedure #7 ##cdr>
                                                                      lst2.747))))
                                                                 '()))))
                                                   (loop2.746 lists)))
                                        (letrec ((loop2.751
                                                  (lambda (lst2.752)
                                                    (if ('#<procedure #4 ##pair?>
                                                         lst2.752)
                                                        (let ((x.753 ('#<procedure #9 car>
                                                                      ('#<procedure #6 ##car>
                                                                       lst2.752))))
                                                          ('#<procedure #10 ##cons>
                                                           x.753
                                                           (loop2.751
                                                            ('#<procedure #7 ##cdr>
                                                             lst2.752))))
                                                        '()))))
                                          (loop2.751 lists)))
                                       end))
                                 (letrec ((loop2.751
                                           (lambda (lst2.752)
                                             (if ('#<procedure #4 ##pair?>
                                                  lst2.752)
                                                 (let ((x.753 ('#<procedure #9 car>
                                                               ('#<procedure #6 ##car>
                                                                lst2.752))))
                                                   ('#<procedure #10 ##cons>
                                                    x.753
                                                    (loop2.751
                                                     ('#<procedure #7 ##cdr>
                                                      lst2.752))))
                                                 '()))))
                                   (loop2.751 lists)))
                                end))))
          (let ((case-temp.1 ('#<procedure #23 length> lists)))
            (if ('#<procedure #3 ##eq?> case-temp.1 0)
                (reduce1 f end list)
                (if ('#<procedure #3 ##eq?> case-temp.1 1)
                    (reduce2 f end list ('#<procedure #6 ##car> lists))
                    (reduceN f
                             end
                             ('#<procedure #10 ##cons> list lists))))))))))

(define append!
  (lambda (l1 l2)
    (if ('#<procedure #4 ##pair?> l1)
        (let ((begin-temp.2
               (if ('#<procedure #4 ##pair?> ('#<procedure #7 ##cdr> l1))
                   (append! ('#<procedure #7 ##cdr> l1) l2)
                   ('#<procedure #12 ##set-cdr!> l1 l2))))
          l1)
        l2)))

(define flat
  (lambda (l)
    (letrec ((flatten (lambda (l r)
                        (if ('#<procedure #4 ##pair?> l)
                            (let ((r (flatten ('#<procedure #7 ##cdr> l) r))
                                  (l ('#<procedure #6 ##car> l)))
                              (if ('#<procedure #4 ##pair?> l)
                                  (flatten ('#<procedure #6 ##car> l)
                                           (flatten ('#<procedure #7 ##cdr> l)
                                                    r))
                                  (if ('#<procedure #24 ##null?> l)
                                      r
                                      ('#<procedure #10 ##cons> l r))))
                            (if ('#<procedure #24 ##null?> l)
                                r
                                ('#<procedure #10 ##cons> l r))))))
      (flatten l '()))))

#t

#t

(define remove
  (lambda (item list)
    (if ('#<procedure #4 ##pair?> list)
        (if ('#<procedure #25 equal?> item ('#<procedure #6 ##car> list))
            ('#<procedure #7 ##cdr> list)
            ('#<procedure #10 ##cons>
             ('#<procedure #6 ##car> list)
             (remove item ('#<procedure #7 ##cdr> list))))
        list)))

(define last-pair
  (lambda (l)
    (if ('#<procedure #4 ##pair?> l)
        (letrec ((scan (lambda (cdrl result)
                         (if ('#<procedure #4 ##pair?> cdrl)
                             (let ((cdrl#1 ('#<procedure #7 ##cdr> cdrl)))
                               (if ('#<procedure #4 ##pair?> cdrl#1)
                                   (scan ('#<procedure #7 ##cdr> cdrl#1)
                                         cdrl#1)
                                   cdrl))
                             result))))
          (let ((cdrl ('#<procedure #7 ##cdr> l)))
            (if ('#<procedure #4 ##pair?> cdrl)
                (let ((cdrl#2 ('#<procedure #7 ##cdr> cdrl)))
                  (if ('#<procedure #4 ##pair?> cdrl#2)
                      (scan ('#<procedure #7 ##cdr> cdrl#2) cdrl#2)
                      cdrl))
                l)))
        (oo-error 'last-pair "Not a pair" l))))

(define call/cc '#<procedure #26 call/cc>)

#t

#t

#t

#f

#t

#t

#t

#t

(define oo-error (lambda (within msg . culprits) (error 'Meroon msg)))

#t

#t

#t

#t

#t

#f

#t

#f

#t

#t

#t

#t

#t

#t

(define internal-meroon-error
  (lambda args
    (oo-error 'meroon "Internal error: should never be seen." args)))

(define make-meroon-keyword
  (lambda (symbol)
    ('#<procedure #27 string->keyword>
     ('#<procedure #17 symbol->string> symbol))))

(define string->meroon-keyword '#<procedure #27 string->keyword>)

('#<procedure #2 eval>
 '(begin
    (define-macro (define-meroon-macro call . body)
      `(begin
         (eval '(define-macro ,call . ,body))
         (define-macro ,call . ,body)))
    (define-macro (define-internal-meroon-macro call . body)
      `(define-macro ,call . ,body))
    #t))

(define Object? (lambda (o) ('#<procedure #28 ##meroon?> o)))

('#<procedure #2 eval>
 '(define-macro (meroon-ref o i)
    `(let ((o ,o) (i ,i))
       (declare (not safe) (extended-bindings))
       (##vector-ref o i))))

('#<procedure #2 eval>
 '(define-macro (meroon-set! o i val)
    `(let ((o ,o) (i ,i) (val ,val))
       (declare (not safe) (extended-bindings))
       (##vector-set! o i val))))

(define instance-clone
  (lambda (o)
    (let ((n ('#<procedure #29 ##vector-length> o)))
      (let ((r (let ((result ('#<procedure #30 ##make-vector>
                              n
                              meroon-uninitialized)))
                 (let ((begin-temp.4
                        ('#<procedure #31 ##subtype-set!> result 6)))
                   result))))
        (let ((begin-temp.5
               (letrec ((copy (lambda (o n r i)
                                (if ('#<procedure #20 ##fx<> i n)
                                    (let ((begin-temp.3
                                           (let ((val ('#<procedure #32 ##vector-ref>
                                                       o
                                                       i)))
                                             ('#<procedure #33 ##vector-set!>
                                              r
                                              i
                                              val))))
                                      (copy o
                                            n
                                            r
                                            ('#<procedure #21 ##fx+> i 1)))
                                    #!void))))
                 (copy o n r 0))))
          r)))))

(define meroon-distribution-name "Paques2001+1")

(define meroon-version
  ('#<procedure #34 ##list> "Meroon V3" "Paques2001+1" "$Revision: 1.1 $"))

(define meroon-revision
  (let ((length ('#<procedure #35 ##string-length> "$Revision: 1.1 $")))
    (letrec ((scan (lambda (length i r)
                     (if ('#<procedure #36 ##fx>=> i length)
                         r
                         (let ((ch ('#<procedure #37 ##string-ref>
                                    "$Revision: 1.1 $"
                                    i)))
                           (if (or ('#<procedure #3 ##eq?> ch #\0)
                                   (or ('#<procedure #3 ##eq?> ch #\1)
                                       (or ('#<procedure #3 ##eq?> ch #\2)
                                           (or ('#<procedure #3 ##eq?> ch #\3)
                                               (or ('#<procedure #3 ##eq?>
                                                    ch
                                                    #\4)
                                                   (or ('#<procedure #3 ##eq?>
                                                        ch
                                                        #\5)
                                                       (or ('#<procedure #3 ##eq?>
                                                            ch
                                                            #\6)
                                                           (or ('#<procedure #3 ##eq?>
                                                                ch
                                                                #\7)
                                                               (or ('#<procedure #3 ##eq?>
                                                                    ch
                                                                    #\8)
                                                                   ('#<procedure #3 ##eq?>
                                                                    ch
                                                                    #\9))))))))))
                               (scan length
                                     ('#<procedure #21 ##fx+> 1 i)
                                     ('#<procedure #21 ##fx+>
                                      ('#<procedure #38 ##fx*> 10 r)
                                      ('#<procedure #39 ##fx->
                                       ('#<procedure #40 ##char->fixnum> ch)
                                       ('#<procedure #40 ##char->fixnum>
                                        #\0))))
                               (if ('#<procedure #3 ##eq?> ch #\.)
                                   ('#<procedure #10 ##cons>
                                    r
                                    (scan length
                                          ('#<procedure #21 ##fx+> i 1)
                                          0))
                                   (scan length
                                         ('#<procedure #21 ##fx+> 1 i)
                                         r))))))))
      (scan length 0 0))))

(define check-revision
  (lambda (rev)
    (if ('#<procedure #25 equal?> rev meroon-revision)
        #f
        (report-meroon-error
         'Syntax
         'define-generic
         "Compiled with incompatible versions of Meroon"
         rev
         meroon-revision))))

(define display-meroon-banner
  (lambda (out)
    (let ((begin-temp.10 ('#<procedure #41 display> "[ " out)))
      (let ((begin-temp.9
             (letrec ((loop2.756
                       (lambda (out lst2.757)
                         (if ('#<procedure #4 ##pair?> lst2.757)
                             (let ((x.758 (let ((x ('#<procedure #6 ##car>
                                                    lst2.757)))
                                            (let ((begin-temp.7
                                                   ('#<procedure #41 display>
                                                    x
                                                    out)))
                                              ('#<procedure #41 display>
                                               " "
                                               out)))))
                               (let ((lst2.757
                                      ('#<procedure #7 ##cdr> lst2.757)))
                                 (if ('#<procedure #4 ##pair?> lst2.757)
                                     (let ((x.758 (let ((x ('#<procedure #6 ##car>
                                                            lst2.757)))
                                                    (let ((begin-temp.7
                                                           ('#<procedure #41 display>
                                                            x
                                                            out)))
                                                      ('#<procedure #41 display>
                                                       " "
                                                       out)))))
                                       (loop2.756
                                        out
                                        ('#<procedure #7 ##cdr> lst2.757)))
                                     #!void)))
                             #!void))))
               (loop2.756 out meroon-version))))
        (let ((begin-temp.8 ('#<procedure #41 display> "]" out)))
          ('#<procedure #42 newline> out))))))

(display-meroon-banner (current-output-port))

(define process-with-access-form
  (lambda (ins-tance specs body)
    (check-with-access-specifications
     specs
     (lambda (class fields)
       (generate-with-access #t ins-tance class fields body '())))))

(define check-with-access-specifications
  (lambda (specs q)
    (let ((begin-temp.11
           (if ('#<procedure #5 ##not> ('#<procedure #4 ##pair?> specs))
               (report-meroon-error
                'Syntax
                'with-access
                "Incorrect specification"
                specs)
               #!void)))
      (let ((class-name
             (if ('#<procedure #4 ##pair?> specs)
                 ('#<procedure #6 ##car> specs)
                 (car specs))))
        (let ((field-names
               (if ('#<procedure #4 ##pair?> specs)
                   ('#<procedure #7 ##cdr> specs)
                   (cdr specs))))
          (let ((no-such-class
                 (lambda (name)
                   (report-meroon-error
                    'Syntax
                    'with-access
                    "No such class"
                    name))))
            (let ((class (symbol->class class-name no-such-class)))
              (let ((no-such-field
                     (lambda (class name)
                       (report-meroon-error
                        'Syntax
                        'with-access
                        "No such field"
                        name
                        class))))
                (let ((fields (letrec ((loop2.763
                                        (lambda (class no-such-field lst2.764)
                                          (if ('#<procedure #4 ##pair?>
                                               lst2.764)
                                              (let ((x.765 (let ((name ('#<procedure #6 ##car>
                                                                        lst2.764)))
                                                             (retrieve-named-field
                                                              class
                                                              name
                                                              no-such-field))))
                                                ('#<procedure #10 ##cons>
                                                 x.765
                                                 (loop2.763
                                                  class
                                                  no-such-field
                                                  ('#<procedure #7 ##cdr>
                                                   lst2.764))))
                                              '()))))
                                (loop2.763 class no-such-field field-names))))
                  (q class fields))))))))))

(define generate-with-access
  (lambda (care ins-tance class fields body env)
    (let ((class-var (symbol-concatenate (Class-name class) '- 'class))
          (o (gensym)))
      (let ((walk* (make-expander* o class fields)))
        ('#<procedure #43 ##quasi-cons>
         'let
         ('#<procedure #43 ##quasi-cons>
          ('#<procedure #44 ##quasi-list>
           ('#<procedure #44 ##quasi-list> o ins-tance))
          ('#<procedure #45 ##quasi-append>
           (if care
               ('#<procedure #44 ##quasi-list>
                ('#<procedure #43 ##quasi-cons>
                 'check-class
                 ('#<procedure #43 ##quasi-cons>
                  o
                  ('#<procedure #43 ##quasi-cons> class-var '('with-access)))))
               '())
           ('#<procedure #44 ##quasi-list>
            ('#<procedure #44 ##quasi-list>
             ('#<procedure #43 ##quasi-cons>
              'lambda
              ('#<procedure #43 ##quasi-cons> '() (walk* body env))))))))))))

(define make-expander*
  (lambda (ins-tance class fields)
    (let ((field-name?
           (lambda (fields n)
             (letrec ((search (lambda (n fields)
                                (and ('#<procedure #4 ##pair?> fields)
                                     (if ('#<procedure #3 ##eq?>
                                          n
                                          (Field-name
                                           (if ('#<procedure #4 ##pair?>
                                                fields)
                                               ('#<procedure #6 ##car> fields)
                                               (car fields))))
                                         (if ('#<procedure #4 ##pair?> fields)
                                             ('#<procedure #6 ##car> fields)
                                             (car fields))
                                         (let ((fields (if ('#<procedure #4 ##pair?>
                                                            fields)
                                                           ('#<procedure #7 ##cdr>
                                                            fields)
                                                           (cdr fields))))
                                           (and ('#<procedure #4 ##pair?>
                                                 fields)
                                                (if ('#<procedure #3 ##eq?>
                                                     n
                                                     (Field-name
                                                      (if ('#<procedure #4 ##pair?>
                                                           fields)
                                                          ('#<procedure #6 ##car>
                                                           fields)
                                                          (car fields))))
                                                    (if ('#<procedure #4 ##pair?>
                                                         fields)
                                                        ('#<procedure #6 ##car>
                                                         fields)
                                                        (car fields))
                                                    (search n
                                                            (if ('#<procedure #4 ##pair?>
                                                                 fields)
                                                                ('#<procedure #7 ##cdr>
                                                                 fields)
                                                                (cdr fields)))))))))))
               (search n fields)))))
      (letrec ((expand (lambda (e r)
                         (if ('#<procedure #5 ##not>
                              ('#<procedure #4 ##pair?> e))
                             (if ('#<procedure #16 ##symbol?> e)
                                 (if (letrec ((loop.771
                                               (lambda (e r lst1.772)
                                                 (if ('#<procedure #4 ##pair?>
                                                      lst1.772)
                                                     (let ((x.773 ('#<procedure #6 ##car>
                                                                   lst1.772)))
                                                       (if ('#<procedure #3 ##eq?>
                                                            e
                                                            x.773)
                                                           lst1.772
                                                           (loop.771
                                                            e
                                                            r
                                                            ('#<procedure #7 ##cdr>
                                                             lst1.772))))
                                                     (if ('#<procedure #24 ##null?>
                                                          lst1.772)
                                                         #f
                                                         (memq e r))))))
                                       (loop.771 e r r))
                                     e
                                     (let ((field (field-name? fields e)))
                                       (if field
                                           (let ((path-length
                                                  (Field-path-length field)))
                                             (if (or ('#<procedure #3 ##eq?>
                                                      path-length
                                                      1)
                                                     ('#<procedure #3 ##eq?>
                                                      path-length
                                                      2))
                                                 ('#<procedure #44 ##quasi-list>
                                                  'instance-ref
                                                  ins-tance
                                                  (generate-offset
                                                   ins-tance
                                                   field
                                                   0
                                                   0))
                                                 ('#<procedure #44 ##quasi-list>
                                                  (symbol-concatenate
                                                   (Class-name
                                                    (Field-defining-class
                                                     field))
                                                   '-
                                                   (Field-name field))
                                                  e)))
                                           e)))
                                 e)
                             (let ((case-temp.12
                                    (if ('#<procedure #4 ##pair?> e)
                                        ('#<procedure #6 ##car> e)
                                        (car e))))
                               (if ('#<procedure #3 ##eq?> case-temp.12 'quote)
                                   e
                                   (if ('#<procedure #3 ##eq?>
                                        case-temp.12
                                        'set!)
                                       (let ((ee (expand (let ((temp.783
                                                                (let ((temp.784
                                                                       (if ('#<procedure #4 ##pair?>
                                                                            e)
                                                                           ('#<procedure #7 ##cdr>
                                                                            e)
                                                                           #f)))
                                                                  (if ('#<procedure #4 ##pair?>
                                                                       temp.784)
                                                                      ('#<procedure #7 ##cdr>
                                                                       temp.784)
                                                                      #f))))
                                                           (if ('#<procedure #4 ##pair?>
                                                                temp.783)
                                                               ('#<procedure #6 ##car>
                                                                temp.783)
                                                               (caddr e)))
                                                         r))
                                             (n (let ((temp.781
                                                       (if ('#<procedure #4 ##pair?>
                                                            e)
                                                           ('#<procedure #7 ##cdr>
                                                            e)
                                                           #f)))
                                                  (if ('#<procedure #4 ##pair?>
                                                       temp.781)
                                                      ('#<procedure #6 ##car>
                                                       temp.781)
                                                      (cadr e)))))
                                         (if (letrec ((loop.787
                                                       (lambda (r n lst1.788)
                                                         (if ('#<procedure #4 ##pair?>
                                                              lst1.788)
                                                             (let ((x.789 ('#<procedure #6 ##car>
                                                                           lst1.788)))
                                                               (if ('#<procedure #3 ##eq?>
                                                                    n
                                                                    x.789)
                                                                   lst1.788
                                                                   (loop.787
                                                                    r
                                                                    n
                                                                    ('#<procedure #7 ##cdr>
                                                                     lst1.788))))
                                                             (if ('#<procedure #24 ##null?>
                                                                  lst1.788)
                                                                 #f
                                                                 (memq n
                                                                       r))))))
                                               (loop.787 r n r))
                                             ('#<procedure #44 ##quasi-list>
                                              'set!
                                              n
                                              ee)
                                             (let ((field (field-name?
                                                           fields
                                                           n)))
                                               (if field
                                                   (if ('#<procedure #5 ##not>
                                                        (Field-immutable?
                                                         field))
                                                       (let ((path-length
                                                              (Field-path-length
                                                               field)))
                                                         (if (or ('#<procedure #3 ##eq?>
                                                                  path-length
                                                                  1)
                                                                 ('#<procedure #3 ##eq?>
                                                                  path-length
                                                                  2))
                                                             ('#<procedure #44 ##quasi-list>
                                                              'instance-set!
                                                              ins-tance
                                                              (generate-offset
                                                               ins-tance
                                                               field
                                                               0
                                                               0)
                                                              ee)
                                                             ('#<procedure #44 ##quasi-list>
                                                              (symbol-concatenate
                                                               'set-
                                                               (Class-name
                                                                (Field-defining-class
                                                                 field))
                                                               '-
                                                               (Field-name
                                                                field)
                                                               '!)
                                                              n
                                                              ee)))
                                                       (report-meroon-error
                                                        'with-access
                                                        "Immutable field"
                                                        field))
                                                   ('#<procedure #44 ##quasi-list>
                                                    'set!
                                                    n
                                                    ee)))))
                                       (if ('#<procedure #3 ##eq?>
                                            case-temp.12
                                            'lambda)
                                           ('#<procedure #43 ##quasi-cons>
                                            'lambda
                                            ('#<procedure #43 ##quasi-cons>
                                             (let ((temp.791
                                                    (if ('#<procedure #4 ##pair?>
                                                         e)
                                                        ('#<procedure #7 ##cdr>
                                                         e)
                                                        #f)))
                                               (if ('#<procedure #4 ##pair?>
                                                    temp.791)
                                                   ('#<procedure #6 ##car>
                                                    temp.791)
                                                   (cadr e)))
                                             (expand* (let ((temp.793
                                                             (if ('#<procedure #4 ##pair?>
                                                                  e)
                                                                 ('#<procedure #7 ##cdr>
                                                                  e)
                                                                 #f)))
                                                        (if ('#<procedure #4 ##pair?>
                                                             temp.793)
                                                            ('#<procedure #7 ##cdr>
                                                             temp.793)
                                                            (cddr e)))
                                                      (let ((variables
                                                             (let ((temp.795
                                                                    (if ('#<procedure #4 ##pair?>
                                                                         e)
                                                                        ('#<procedure #7 ##cdr>
                                                                         e)
                                                                        #f)))
                                                               (if ('#<procedure #4 ##pair?>
                                                                    temp.795)
                                                                   ('#<procedure #6 ##car>
                                                                    temp.795)
                                                                   (cadr e)))))
                                                        ('#<procedure #46 append>
                                                         (if ('#<procedure #4 ##pair?>
                                                              variables)
                                                             (if (or (let ((thing ('#<procedure #6 ##car>
                                                                                   variables)))
                                                                       ('#<procedure #3 ##eq?>
                                                                        thing
                                                                        #!optional))
                                                                     (or (let ((thing ('#<procedure #6 ##car>
                                                                                       variables)))
                                                                           ('#<procedure #3 ##eq?>
                                                                            thing
                                                                            #!rest))
                                                                         (let ((thing ('#<procedure #6 ##car>
                                                                                       variables)))
                                                                           ('#<procedure #3 ##eq?>
                                                                            thing
                                                                            #!key))))
                                                                 (extract-formals
                                                                  ('#<procedure #7 ##cdr>
                                                                   variables))
                                                                 (if ('#<procedure #4 ##pair?>
                                                                      ('#<procedure #6 ##car>
                                                                       variables))
                                                                     ('#<procedure #10 ##cons>
                                                                      ('#<procedure #47 ##caar>
                                                                       variables)
                                                                      (extract-formals
                                                                       ('#<procedure #7 ##cdr>
                                                                        variables)))
                                                                     ('#<procedure #10 ##cons>
                                                                      ('#<procedure #6 ##car>
                                                                       variables)
                                                                      (extract-formals
                                                                       ('#<procedure #7 ##cdr>
                                                                        variables)))))
                                                             (if ('#<procedure #24 ##null?>
                                                                  variables)
                                                                 variables
                                                                 ('#<procedure #34 ##list>
                                                                  variables)))
                                                         r)))))
                                           (if ('#<procedure #3 ##eq?>
                                                case-temp.12
                                                'let)
                                               (if ('#<procedure #48 list?>
                                                    (let ((temp.797
                                                           (if ('#<procedure #4 ##pair?>
                                                                e)
                                                               ('#<procedure #7 ##cdr>
                                                                e)
                                                               #f)))
                                                      (if ('#<procedure #4 ##pair?>
                                                           temp.797)
                                                          ('#<procedure #6 ##car>
                                                           temp.797)
                                                          (cadr e))))
                                                   ('#<procedure #43 ##quasi-cons>
                                                    'let
                                                    ('#<procedure #43 ##quasi-cons>
                                                     (let ((temp.804
                                                            (let ((temp.802
                                                                   (if ('#<procedure #4 ##pair?>
                                                                        e)
                                                                       ('#<procedure #7 ##cdr>
                                                                        e)
                                                                       #f)))
                                                              (if ('#<procedure #4 ##pair?>
                                                                   temp.802)
                                                                  ('#<procedure #6 ##car>
                                                                   temp.802)
                                                                  (cadr e)))))
                                                       (letrec ((loop2.805
                                                                 (lambda (expand
                                                                          r
                                                                          lst2.806)
                                                                   (if ('#<procedure #4 ##pair?>
                                                                        lst2.806)
                                                                       (let ((x.807 (let ((binding ('#<procedure #6 ##car>
                                                                                                    lst2.806)))
                                                                                      ('#<procedure #44 ##quasi-list>
                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                            binding)
                                                                                           ('#<procedure #6 ##car>
                                                                                            binding)
                                                                                           (car binding))
                                                                                       (expand (let ((temp.800
                                                                                                      (if ('#<procedure #4 ##pair?>
                                                                                                           binding)
                                                                                                          ('#<procedure #7 ##cdr>
                                                                                                           binding)
                                                                                                          #f)))
                                                                                                 (if ('#<procedure #4 ##pair?>
                                                                                                      temp.800)
                                                                                                     ('#<procedure #6 ##car>
                                                                                                      temp.800)
                                                                                                     (cadr binding)))
                                                                                               r)))))
                                                                         ('#<procedure #10 ##cons>
                                                                          x.807
                                                                          (loop2.805
                                                                           expand
                                                                           r
                                                                           ('#<procedure #7 ##cdr>
                                                                            lst2.806))))
                                                                       '()))))
                                                         (loop2.805
                                                          expand
                                                          r
                                                          temp.804)))
                                                     (expand* (let ((temp.809
                                                                     (if ('#<procedure #4 ##pair?>
                                                                          e)
                                                                         ('#<procedure #7 ##cdr>
                                                                          e)
                                                                         #f)))
                                                                (if ('#<procedure #4 ##pair?>
                                                                     temp.809)
                                                                    ('#<procedure #7 ##cdr>
                                                                     temp.809)
                                                                    (cddr e)))
                                                              (let ((variables
                                                                     (let ((temp.813
                                                                            (let ((temp.811
                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                        e)
                                                                                       ('#<procedure #7 ##cdr>
                                                                                        e)
                                                                                       #f)))
                                                                              (if ('#<procedure #4 ##pair?>
                                                                                   temp.811)
                                                                                  ('#<procedure #6 ##car>
                                                                                   temp.811)
                                                                                  (cadr e)))))
                                                                       (letrec ((loop2.814
                                                                                 (lambda (lst2.815)
                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                        lst2.815)
                                                                                       (let ((x.816 ('#<procedure #9 car>
                                                                                                     ('#<procedure #6 ##car>
                                                                                                      lst2.815))))
                                                                                         ('#<procedure #10 ##cons>
                                                                                          x.816
                                                                                          (let ((lst2.815
                                                                                                 ('#<procedure #7 ##cdr>
                                                                                                  lst2.815)))
                                                                                            (if ('#<procedure #4 ##pair?>
                                                                                                 lst2.815)
                                                                                                (let ((x.816 ('#<procedure #9 car>
                                                                                                              ('#<procedure #6 ##car>
                                                                                                               lst2.815))))
                                                                                                  ('#<procedure #10 ##cons>
                                                                                                   x.816
                                                                                                   (let ((lst2.815
                                                                                                          ('#<procedure #7 ##cdr>
                                                                                                           lst2.815)))
                                                                                                     (if ('#<procedure #4 ##pair?>
                                                                                                          lst2.815)
                                                                                                         (let ((x.816 ('#<procedure #9 car>
                                                                                                                       ('#<procedure #6 ##car>
                                                                                                                        lst2.815))))
                                                                                                           ('#<procedure #10 ##cons>
                                                                                                            x.816
                                                                                                            (let ((lst2.815
                                                                                                                   ('#<procedure #7 ##cdr>
                                                                                                                    lst2.815)))
                                                                                                              (if ('#<procedure #4 ##pair?>
                                                                                                                   lst2.815)
                                                                                                                  (let ((x.816 ('#<procedure #9 car>
                                                                                                                                ('#<procedure #6 ##car>
                                                                                                                                 lst2.815))))
                                                                                                                    ('#<procedure #10 ##cons>
                                                                                                                     x.816
                                                                                                                     (let ((lst2.815
                                                                                                                            ('#<procedure #7 ##cdr>
                                                                                                                             lst2.815)))
                                                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                                                            lst2.815)
                                                                                                                           (let ((x.816 ('#<procedure #9 car>
                                                                                                                                         ('#<procedure #6 ##car>
                                                                                                                                          lst2.815))))
                                                                                                                             ('#<procedure #10 ##cons>
                                                                                                                              x.816
                                                                                                                              (let ((lst2.815
                                                                                                                                     ('#<procedure #7 ##cdr>
                                                                                                                                      lst2.815)))
                                                                                                                                (if ('#<procedure #4 ##pair?>
                                                                                                                                     lst2.815)
                                                                                                                                    (let ((x.816 ('#<procedure #9 car>
                                                                                                                                                  ('#<procedure #6 ##car>
                                                                                                                                                   lst2.815))))
                                                                                                                                      ('#<procedure #10 ##cons>
                                                                                                                                       x.816
                                                                                                                                       (let ((lst2.815
                                                                                                                                              ('#<procedure #7 ##cdr>
                                                                                                                                               lst2.815)))
                                                                                                                                         (if ('#<procedure #4 ##pair?>
                                                                                                                                              lst2.815)
                                                                                                                                             (let ((x.816 ('#<procedure #9 car>
                                                                                                                                                           ('#<procedure #6 ##car>
                                                                                                                                                            lst2.815))))
                                                                                                                                               ('#<procedure #10 ##cons>
                                                                                                                                                x.816
                                                                                                                                                (let ((lst2.815
                                                                                                                                                       ('#<procedure #7 ##cdr>
                                                                                                                                                        lst2.815)))
                                                                                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                                                                                       lst2.815)
                                                                                                                                                      (let ((x.816 ('#<procedure #9 car>
                                                                                                                                                                    ('#<procedure #6 ##car>
                                                                                                                                                                     lst2.815))))
                                                                                                                                                        ('#<procedure #10 ##cons>
                                                                                                                                                         x.816
                                                                                                                                                         (let ((lst2.815
                                                                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                                                                 lst2.815)))
                                                                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                                                                lst2.815)
                                                                                                                                                               (let ((x.816 ('#<procedure #9 car>
                                                                                                                                                                             ('#<procedure #6 ##car>
                                                                                                                                                                              lst2.815))))
                                                                                                                                                                 ('#<procedure #10 ##cons>
                                                                                                                                                                  x.816
                                                                                                                                                                  (let ((lst2.815
                                                                                                                                                                         ('#<procedure #7 ##cdr>
                                                                                                                                                                          lst2.815)))
                                                                                                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                                                                                                         lst2.815)
                                                                                                                                                                        (let ((x.816 ('#<procedure #9 car>
                                                                                                                                                                                      ('#<procedure #6 ##car>
                                                                                                                                                                                       lst2.815))))
                                                                                                                                                                          ('#<procedure #10 ##cons>
                                                                                                                                                                           x.816
                                                                                                                                                                           (loop2.814
                                                                                                                                                                            ('#<procedure #7 ##cdr>
                                                                                                                                                                             lst2.815))))
                                                                                                                                                                        '()))))
                                                                                                                                                               '()))))
                                                                                                                                                      '()))))
                                                                                                                                             '()))))
                                                                                                                                    '()))))
                                                                                                                           '()))))
                                                                                                                  '()))))
                                                                                                         '()))))
                                                                                                '()))))
                                                                                       '()))))
                                                                         (loop2.814
                                                                          temp.813)))))
                                                                ('#<procedure #46 append>
                                                                 (extract-formals
                                                                  variables)
                                                                 r)))))
                                                   ('#<procedure #43 ##quasi-cons>
                                                    'let
                                                    ('#<procedure #43 ##quasi-cons>
                                                     (let ((temp.818
                                                            (if ('#<procedure #4 ##pair?>
                                                                 e)
                                                                ('#<procedure #7 ##cdr>
                                                                 e)
                                                                #f)))
                                                       (if ('#<procedure #4 ##pair?>
                                                            temp.818)
                                                           ('#<procedure #6 ##car>
                                                            temp.818)
                                                           (cadr e)))
                                                     ('#<procedure #43 ##quasi-cons>
                                                      (let ((temp.826
                                                             (let ((temp.823
                                                                    (let ((temp.824
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                e)
                                                                               ('#<procedure #7 ##cdr>
                                                                                e)
                                                                               #f)))
                                                                      (if ('#<procedure #4 ##pair?>
                                                                           temp.824)
                                                                          ('#<procedure #7 ##cdr>
                                                                           temp.824)
                                                                          #f))))
                                                               (if ('#<procedure #4 ##pair?>
                                                                    temp.823)
                                                                   ('#<procedure #6 ##car>
                                                                    temp.823)
                                                                   (caddr e)))))
                                                        (letrec ((loop2.827
                                                                  (lambda (expand
                                                                           r
                                                                           lst2.828)
                                                                    (if ('#<procedure #4 ##pair?>
                                                                         lst2.828)
                                                                        (let ((x.829 (let ((binding ('#<procedure #6 ##car>
                                                                                                     lst2.828)))
                                                                                       ('#<procedure #44 ##quasi-list>
                                                                                        (if ('#<procedure #4 ##pair?>
                                                                                             binding)
                                                                                            ('#<procedure #6 ##car>
                                                                                             binding)
                                                                                            (car binding))
                                                                                        (expand (let ((temp.821
                                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                                            binding)
                                                                                                           ('#<procedure #7 ##cdr>
                                                                                                            binding)
                                                                                                           #f)))
                                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                                       temp.821)
                                                                                                      ('#<procedure #6 ##car>
                                                                                                       temp.821)
                                                                                                      (cadr binding)))
                                                                                                r)))))
                                                                          ('#<procedure #10 ##cons>
                                                                           x.829
                                                                           (loop2.827
                                                                            expand
                                                                            r
                                                                            ('#<procedure #7 ##cdr>
                                                                             lst2.828))))
                                                                        '()))))
                                                          (loop2.827
                                                           expand
                                                           r
                                                           temp.826)))
                                                      (expand* (let ((temp.831
                                                                      (let ((temp.832
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  e)
                                                                                 ('#<procedure #7 ##cdr>
                                                                                  e)
                                                                                 #f)))
                                                                        (if ('#<procedure #4 ##pair?>
                                                                             temp.832)
                                                                            ('#<procedure #7 ##cdr>
                                                                             temp.832)
                                                                            #f))))
                                                                 (if ('#<procedure #4 ##pair?>
                                                                      temp.831)
                                                                     ('#<procedure #7 ##cdr>
                                                                      temp.831)
                                                                     (cdddr e)))
                                                               (let ((variables
                                                                      ('#<procedure #10 ##cons>
                                                                       (let ((temp.834
                                                                              (if ('#<procedure #4 ##pair?>
                                                                                   e)
                                                                                  ('#<procedure #7 ##cdr>
                                                                                   e)
                                                                                  #f)))
                                                                         (if ('#<procedure #4 ##pair?>
                                                                              temp.834)
                                                                             ('#<procedure #6 ##car>
                                                                              temp.834)
                                                                             (cadr e)))
                                                                       (let ((temp.839
                                                                              (let ((temp.836
                                                                                     (let ((temp.837
                                                                                            (if ('#<procedure #4 ##pair?>
                                                                                                 e)
                                                                                                ('#<procedure #7 ##cdr>
                                                                                                 e)
                                                                                                #f)))
                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                            temp.837)
                                                                                           ('#<procedure #7 ##cdr>
                                                                                            temp.837)
                                                                                           #f))))
                                                                                (if ('#<procedure #4 ##pair?>
                                                                                     temp.836)
                                                                                    ('#<procedure #6 ##car>
                                                                                     temp.836)
                                                                                    (caddr e)))))
                                                                         (letrec ((loop2.840
                                                                                   (lambda (lst2.841)
                                                                                     (if ('#<procedure #4 ##pair?>
                                                                                          lst2.841)
                                                                                         (let ((x.842 ('#<procedure #9 car>
                                                                                                       ('#<procedure #6 ##car>
                                                                                                        lst2.841))))
                                                                                           ('#<procedure #10 ##cons>
                                                                                            x.842
                                                                                            (let ((lst2.841
                                                                                                   ('#<procedure #7 ##cdr>
                                                                                                    lst2.841)))
                                                                                              (if ('#<procedure #4 ##pair?>
                                                                                                   lst2.841)
                                                                                                  (let ((x.842 ('#<procedure #9 car>
                                                                                                                ('#<procedure #6 ##car>
                                                                                                                 lst2.841))))
                                                                                                    ('#<procedure #10 ##cons>
                                                                                                     x.842
                                                                                                     (let ((lst2.841
                                                                                                            ('#<procedure #7 ##cdr>
                                                                                                             lst2.841)))
                                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                                            lst2.841)
                                                                                                           (let ((x.842 ('#<procedure #9 car>
                                                                                                                         ('#<procedure #6 ##car>
                                                                                                                          lst2.841))))
                                                                                                             ('#<procedure #10 ##cons>
                                                                                                              x.842
                                                                                                              (let ((lst2.841
                                                                                                                     ('#<procedure #7 ##cdr>
                                                                                                                      lst2.841)))
                                                                                                                (if ('#<procedure #4 ##pair?>
                                                                                                                     lst2.841)
                                                                                                                    (let ((x.842 ('#<procedure #9 car>
                                                                                                                                  ('#<procedure #6 ##car>
                                                                                                                                   lst2.841))))
                                                                                                                      ('#<procedure #10 ##cons>
                                                                                                                       x.842
                                                                                                                       (let ((lst2.841
                                                                                                                              ('#<procedure #7 ##cdr>
                                                                                                                               lst2.841)))
                                                                                                                         (if ('#<procedure #4 ##pair?>
                                                                                                                              lst2.841)
                                                                                                                             (let ((x.842 ('#<procedure #9 car>
                                                                                                                                           ('#<procedure #6 ##car>
                                                                                                                                            lst2.841))))
                                                                                                                               ('#<procedure #10 ##cons>
                                                                                                                                x.842
                                                                                                                                (let ((lst2.841
                                                                                                                                       ('#<procedure #7 ##cdr>
                                                                                                                                        lst2.841)))
                                                                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                                                                       lst2.841)
                                                                                                                                      (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                    ('#<procedure #6 ##car>
                                                                                                                                                     lst2.841))))
                                                                                                                                        ('#<procedure #10 ##cons>
                                                                                                                                         x.842
                                                                                                                                         (let ((lst2.841
                                                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                                                 lst2.841)))
                                                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                                                lst2.841)
                                                                                                                                               (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                             ('#<procedure #6 ##car>
                                                                                                                                                              lst2.841))))
                                                                                                                                                 ('#<procedure #10 ##cons>
                                                                                                                                                  x.842
                                                                                                                                                  (let ((lst2.841
                                                                                                                                                         ('#<procedure #7 ##cdr>
                                                                                                                                                          lst2.841)))
                                                                                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                                                                                         lst2.841)
                                                                                                                                                        (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                      ('#<procedure #6 ##car>
                                                                                                                                                                       lst2.841))))
                                                                                                                                                          ('#<procedure #10 ##cons>
                                                                                                                                                           x.842
                                                                                                                                                           (let ((lst2.841
                                                                                                                                                                  ('#<procedure #7 ##cdr>
                                                                                                                                                                   lst2.841)))
                                                                                                                                                             (if ('#<procedure #4 ##pair?>
                                                                                                                                                                  lst2.841)
                                                                                                                                                                 (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                               ('#<procedure #6 ##car>
                                                                                                                                                                                lst2.841))))
                                                                                                                                                                   ('#<procedure #10 ##cons>
                                                                                                                                                                    x.842
                                                                                                                                                                    (let ((lst2.841
                                                                                                                                                                           ('#<procedure #7 ##cdr>
                                                                                                                                                                            lst2.841)))
                                                                                                                                                                      (if ('#<procedure #4 ##pair?>
                                                                                                                                                                           lst2.841)
                                                                                                                                                                          (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                        ('#<procedure #6 ##car>
                                                                                                                                                                                         lst2.841))))
                                                                                                                                                                            ('#<procedure #10 ##cons>
                                                                                                                                                                             x.842
                                                                                                                                                                             (let ((lst2.841
                                                                                                                                                                                    ('#<procedure #7 ##cdr>
                                                                                                                                                                                     lst2.841)))
                                                                                                                                                                               (if ('#<procedure #4 ##pair?>
                                                                                                                                                                                    lst2.841)
                                                                                                                                                                                   (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                                 ('#<procedure #6 ##car>
                                                                                                                                                                                                  lst2.841))))
                                                                                                                                                                                     ('#<procedure #10 ##cons>
                                                                                                                                                                                      x.842
                                                                                                                                                                                      (let ((lst2.841
                                                                                                                                                                                             ('#<procedure #7 ##cdr>
                                                                                                                                                                                              lst2.841)))
                                                                                                                                                                                        (if ('#<procedure #4 ##pair?>
                                                                                                                                                                                             lst2.841)
                                                                                                                                                                                            (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                                          ('#<procedure #6 ##car>
                                                                                                                                                                                                           lst2.841))))
                                                                                                                                                                                              ('#<procedure #10 ##cons>
                                                                                                                                                                                               x.842
                                                                                                                                                                                               (let ((lst2.841
                                                                                                                                                                                                      ('#<procedure #7 ##cdr>
                                                                                                                                                                                                       lst2.841)))
                                                                                                                                                                                                 (if ('#<procedure #4 ##pair?>
                                                                                                                                                                                                      lst2.841)
                                                                                                                                                                                                     (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                                                   ('#<procedure #6 ##car>
                                                                                                                                                                                                                    lst2.841))))
                                                                                                                                                                                                       ('#<procedure #10 ##cons>
                                                                                                                                                                                                        x.842
                                                                                                                                                                                                        (let ((lst2.841
                                                                                                                                                                                                               ('#<procedure #7 ##cdr>
                                                                                                                                                                                                                lst2.841)))
                                                                                                                                                                                                          (if ('#<procedure #4 ##pair?>
                                                                                                                                                                                                               lst2.841)
                                                                                                                                                                                                              (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                                                            ('#<procedure #6 ##car>
                                                                                                                                                                                                                             lst2.841))))
                                                                                                                                                                                                                ('#<procedure #10 ##cons>
                                                                                                                                                                                                                 x.842
                                                                                                                                                                                                                 (let ((lst2.841
                                                                                                                                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                                                                                                                                         lst2.841)))
                                                                                                                                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                                                                                                                                        lst2.841)
                                                                                                                                                                                                                       (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                                                                     ('#<procedure #6 ##car>
                                                                                                                                                                                                                                      lst2.841))))
                                                                                                                                                                                                                         ('#<procedure #10 ##cons>
                                                                                                                                                                                                                          x.842
                                                                                                                                                                                                                          (let ((lst2.841
                                                                                                                                                                                                                                 ('#<procedure #7 ##cdr>
                                                                                                                                                                                                                                  lst2.841)))
                                                                                                                                                                                                                            (if ('#<procedure #4 ##pair?>
                                                                                                                                                                                                                                 lst2.841)
                                                                                                                                                                                                                                (let ((x.842 ('#<procedure #9 car>
                                                                                                                                                                                                                                              ('#<procedure #6 ##car>
                                                                                                                                                                                                                                               lst2.841))))
                                                                                                                                                                                                                                  ('#<procedure #10 ##cons>
                                                                                                                                                                                                                                   x.842
                                                                                                                                                                                                                                   (loop2.840
                                                                                                                                                                                                                                    ('#<procedure #7 ##cdr>
                                                                                                                                                                                                                                     lst2.841))))
                                                                                                                                                                                                                                '()))))
                                                                                                                                                                                                                       '()))))
                                                                                                                                                                                                              '()))))
                                                                                                                                                                                                     '()))))
                                                                                                                                                                                            '()))))
                                                                                                                                                                                   '()))))
                                                                                                                                                                          '()))))
                                                                                                                                                                 '()))))
                                                                                                                                                        '()))))
                                                                                                                                               '()))))
                                                                                                                                      '()))))
                                                                                                                             '()))))
                                                                                                                    '()))))
                                                                                                           '()))))
                                                                                                  '()))))
                                                                                         '()))))
                                                                           (loop2.840
                                                                            temp.839))))))
                                                                 ('#<procedure #46 append>
                                                                  (extract-formals
                                                                   variables)
                                                                  r)))))))
                                               (if ('#<procedure #3 ##eq?>
                                                    case-temp.12
                                                    'let*)
                                                   (if ('#<procedure #4 ##pair?>
                                                        (let ((temp.844
                                                               (if ('#<procedure #4 ##pair?>
                                                                    e)
                                                                   ('#<procedure #7 ##cdr>
                                                                    e)
                                                                   #f)))
                                                          (if ('#<procedure #4 ##pair?>
                                                               temp.844)
                                                              ('#<procedure #6 ##car>
                                                               temp.844)
                                                              (cadr e))))
                                                       (let ((binding (let ((temp.847
                                                                             (let ((temp.846
                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                         e)
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         e)
                                                                                        #f)))
                                                                               (if ('#<procedure #4 ##pair?>
                                                                                    temp.846)
                                                                                   ('#<procedure #6 ##car>
                                                                                    temp.846)
                                                                                   (cadr e)))))
                                                                        (if ('#<procedure #4 ##pair?>
                                                                             temp.847)
                                                                            ('#<procedure #6 ##car>
                                                                             temp.847)
                                                                            (car temp.847)))))
                                                         ('#<procedure #44 ##quasi-list>
                                                          'let
                                                          ('#<procedure #44 ##quasi-list>
                                                           ('#<procedure #44 ##quasi-list>
                                                            (if ('#<procedure #4 ##pair?>
                                                                 binding)
                                                                ('#<procedure #6 ##car>
                                                                 binding)
                                                                (car binding))
                                                            (expand (let ((temp.850
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                binding)
                                                                               ('#<procedure #7 ##cdr>
                                                                                binding)
                                                                               #f)))
                                                                      (if ('#<procedure #4 ##pair?>
                                                                           temp.850)
                                                                          ('#<procedure #6 ##car>
                                                                           temp.850)
                                                                          (cadr binding)))
                                                                    r)))
                                                          (expand ('#<procedure #43 ##quasi-cons>
                                                                   'let*
                                                                   ('#<procedure #43 ##quasi-cons>
                                                                    (let ((temp.853
                                                                           (let ((temp.852
                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                       e)
                                                                                      ('#<procedure #7 ##cdr>
                                                                                       e)
                                                                                      #f)))
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  temp.852)
                                                                                 ('#<procedure #6 ##car>
                                                                                  temp.852)
                                                                                 (cadr e)))))
                                                                      (if ('#<procedure #4 ##pair?>
                                                                           temp.853)
                                                                          ('#<procedure #7 ##cdr>
                                                                           temp.853)
                                                                          (cdr temp.853)))
                                                                    (let ((temp.855
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                e)
                                                                               ('#<procedure #7 ##cdr>
                                                                                e)
                                                                               #f)))
                                                                      (if ('#<procedure #4 ##pair?>
                                                                           temp.855)
                                                                          ('#<procedure #7 ##cdr>
                                                                           temp.855)
                                                                          (cddr e)))))
                                                                  (let ((variables
                                                                         ('#<procedure #34 ##list>
                                                                          (if ('#<procedure #4 ##pair?>
                                                                               binding)
                                                                              ('#<procedure #6 ##car>
                                                                               binding)
                                                                              (car binding)))))
                                                                    ('#<procedure #46 append>
                                                                     (extract-formals
                                                                      variables)
                                                                     r)))))
                                                       ('#<procedure #43 ##quasi-cons>
                                                        'begin
                                                        (expand* (let ((temp.858
                                                                        (if ('#<procedure #4 ##pair?>
                                                                             e)
                                                                            ('#<procedure #7 ##cdr>
                                                                             e)
                                                                            #f)))
                                                                   (if ('#<procedure #4 ##pair?>
                                                                        temp.858)
                                                                       ('#<procedure #7 ##cdr>
                                                                        temp.858)
                                                                       (cddr e)))
                                                                 r)))
                                                   (if ('#<procedure #3 ##eq?>
                                                        case-temp.12
                                                        'letrec)
                                                       (let ((names (let ((temp.862
                                                                           (let ((temp.860
                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                       e)
                                                                                      ('#<procedure #7 ##cdr>
                                                                                       e)
                                                                                      #f)))
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  temp.860)
                                                                                 ('#<procedure #6 ##car>
                                                                                  temp.860)
                                                                                 (cadr e)))))
                                                                      (letrec ((loop2.863
                                                                                (lambda (lst2.864)
                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                       lst2.864)
                                                                                      (let ((x.865 ('#<procedure #9 car>
                                                                                                    ('#<procedure #6 ##car>
                                                                                                     lst2.864))))
                                                                                        ('#<procedure #10 ##cons>
                                                                                         x.865
                                                                                         (loop2.863
                                                                                          ('#<procedure #7 ##cdr>
                                                                                           lst2.864))))
                                                                                      '()))))
                                                                        (loop2.863
                                                                         temp.862)))))
                                                         (let ((r ('#<procedure #46 append>
                                                                   (extract-formals
                                                                    names)
                                                                   r)))
                                                           ('#<procedure #43 ##quasi-cons>
                                                            'letrec
                                                            ('#<procedure #43 ##quasi-cons>
                                                             (let ((temp.872
                                                                    (let ((temp.870
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                e)
                                                                               ('#<procedure #7 ##cdr>
                                                                                e)
                                                                               #f)))
                                                                      (if ('#<procedure #4 ##pair?>
                                                                           temp.870)
                                                                          ('#<procedure #6 ##car>
                                                                           temp.870)
                                                                          (cadr e)))))
                                                               (letrec ((loop2.873
                                                                         (lambda (expand
                                                                                  r
                                                                                  lst2.874)
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                lst2.874)
                                                                               (let ((x.875 (let ((binding ('#<procedure #6 ##car>
                                                                                                            lst2.874)))
                                                                                              ('#<procedure #44 ##quasi-list>
                                                                                               (if ('#<procedure #4 ##pair?>
                                                                                                    binding)
                                                                                                   ('#<procedure #6 ##car>
                                                                                                    binding)
                                                                                                   (car binding))
                                                                                               (expand (let ((temp.868
                                                                                                              (if ('#<procedure #4 ##pair?>
                                                                                                                   binding)
                                                                                                                  ('#<procedure #7 ##cdr>
                                                                                                                   binding)
                                                                                                                  #f)))
                                                                                                         (if ('#<procedure #4 ##pair?>
                                                                                                              temp.868)
                                                                                                             ('#<procedure #6 ##car>
                                                                                                              temp.868)
                                                                                                             (cadr binding)))
                                                                                                       r)))))
                                                                                 ('#<procedure #10 ##cons>
                                                                                  x.875
                                                                                  (loop2.873
                                                                                   expand
                                                                                   r
                                                                                   ('#<procedure #7 ##cdr>
                                                                                    lst2.874))))
                                                                               '()))))
                                                                 (loop2.873
                                                                  expand
                                                                  r
                                                                  temp.872)))
                                                             (expand* (let ((temp.877
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  e)
                                                                                 ('#<procedure #7 ##cdr>
                                                                                  e)
                                                                                 #f)))
                                                                        (if ('#<procedure #4 ##pair?>
                                                                             temp.877)
                                                                            ('#<procedure #7 ##cdr>
                                                                             temp.877)
                                                                            (cddr e)))
                                                                      r)))))
                                                       (if ('#<procedure #3 ##eq?>
                                                            case-temp.12
                                                            'define)
                                                           (let ((names (if ('#<procedure #4 ##pair?>
                                                                             (let ((temp.879
                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                         e)
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         e)
                                                                                        #f)))
                                                                               (if ('#<procedure #4 ##pair?>
                                                                                    temp.879)
                                                                                   ('#<procedure #6 ##car>
                                                                                    temp.879)
                                                                                   (cadr e))))
                                                                            (let ((temp.881
                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                        e)
                                                                                       ('#<procedure #7 ##cdr>
                                                                                        e)
                                                                                       #f)))
                                                                              (if ('#<procedure #4 ##pair?>
                                                                                   temp.881)
                                                                                  ('#<procedure #6 ##car>
                                                                                   temp.881)
                                                                                  (cadr e)))
                                                                            ('#<procedure #34 ##list>
                                                                             (let ((temp.883
                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                         e)
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         e)
                                                                                        #f)))
                                                                               (if ('#<procedure #4 ##pair?>
                                                                                    temp.883)
                                                                                   ('#<procedure #6 ##car>
                                                                                    temp.883)
                                                                                   (cadr e)))))))
                                                             ('#<procedure #43 ##quasi-cons>
                                                              'define
                                                              ('#<procedure #43 ##quasi-cons>
                                                               (let ((temp.885
                                                                      (if ('#<procedure #4 ##pair?>
                                                                           e)
                                                                          ('#<procedure #7 ##cdr>
                                                                           e)
                                                                          #f)))
                                                                 (if ('#<procedure #4 ##pair?>
                                                                      temp.885)
                                                                     ('#<procedure #6 ##car>
                                                                      temp.885)
                                                                     (cadr e)))
                                                               (expand* (let ((temp.887
                                                                               (if ('#<procedure #4 ##pair?>
                                                                                    e)
                                                                                   ('#<procedure #7 ##cdr>
                                                                                    e)
                                                                                   #f)))
                                                                          (if ('#<procedure #4 ##pair?>
                                                                               temp.887)
                                                                              ('#<procedure #7 ##cdr>
                                                                               temp.887)
                                                                              (cddr e)))
                                                                        ('#<procedure #46 append>
                                                                         (extract-formals
                                                                          names)
                                                                         r)))))
                                                           (if ('#<procedure #3 ##eq?>
                                                                case-temp.12
                                                                'with-access)
                                                               ('#<procedure #43 ##quasi-cons>
                                                                'with-access
                                                                ('#<procedure #43 ##quasi-cons>
                                                                 (expand (let ((temp.889
                                                                                (if ('#<procedure #4 ##pair?>
                                                                                     e)
                                                                                    ('#<procedure #7 ##cdr>
                                                                                     e)
                                                                                    #f)))
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                temp.889)
                                                                               ('#<procedure #6 ##car>
                                                                                temp.889)
                                                                               (cadr e)))
                                                                         r)
                                                                 ('#<procedure #43 ##quasi-cons>
                                                                  (let ((temp.891
                                                                         (let ((temp.892
                                                                                (if ('#<procedure #4 ##pair?>
                                                                                     e)
                                                                                    ('#<procedure #7 ##cdr>
                                                                                     e)
                                                                                    #f)))
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                temp.892)
                                                                               ('#<procedure #7 ##cdr>
                                                                                temp.892)
                                                                               #f))))
                                                                    (if ('#<procedure #4 ##pair?>
                                                                         temp.891)
                                                                        ('#<procedure #6 ##car>
                                                                         temp.891)
                                                                        (caddr e)))
                                                                  (expand* (let ((temp.894
                                                                                  (let ((temp.895
                                                                                         (if ('#<procedure #4 ##pair?>
                                                                                              e)
                                                                                             ('#<procedure #7 ##cdr>
                                                                                              e)
                                                                                             #f)))
                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                         temp.895)
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         temp.895)
                                                                                        #f))))
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  temp.894)
                                                                                 ('#<procedure #7 ##cdr>
                                                                                  temp.894)
                                                                                 (cdddr e)))
                                                                           (let ((variables
                                                                                  (let ((temp.899
                                                                                         (let ((temp.897
                                                                                                (let ((temp.898
                                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                                            e)
                                                                                                           ('#<procedure #7 ##cdr>
                                                                                                            e)
                                                                                                           #f)))
                                                                                                  (if ('#<procedure #4 ##pair?>
                                                                                                       temp.898)
                                                                                                      ('#<procedure #7 ##cdr>
                                                                                                       temp.898)
                                                                                                      #f))))
                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                temp.897)
                                                                                               ('#<procedure #6 ##car>
                                                                                                temp.897)
                                                                                               (caddr e)))))
                                                                                    (if ('#<procedure #4 ##pair?>
                                                                                         temp.899)
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         temp.899)
                                                                                        (cdr temp.899)))))
                                                                             ('#<procedure #46 append>
                                                                              (extract-formals
                                                                               variables)
                                                                              r))))))
                                                               (if ('#<procedure #3 ##eq?>
                                                                    case-temp.12
                                                                    'quasiquote)
                                                                   (let ((e (let ((temp.901
                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                        e)
                                                                                       ('#<procedure #7 ##cdr>
                                                                                        e)
                                                                                       #f)))
                                                                              (if ('#<procedure #4 ##pair?>
                                                                                   temp.901)
                                                                                  ('#<procedure #6 ##car>
                                                                                   temp.901)
                                                                                  (cadr e)))))
                                                                     (letrec ((quasi-expand
                                                                               (lambda (expand
                                                                                        r
                                                                                        e)
                                                                                 (if ('#<procedure #4 ##pair?>
                                                                                      e)
                                                                                     (let ((case-temp.13
                                                                                            (if ('#<procedure #4 ##pair?>
                                                                                                 e)
                                                                                                ('#<procedure #6 ##car>
                                                                                                 e)
                                                                                                (car e))))
                                                                                       (if (or ('#<procedure #3 ##eq?>
                                                                                                case-temp.13
                                                                                                'unquote)
                                                                                               ('#<procedure #3 ##eq?>
                                                                                                case-temp.13
                                                                                                'unquote-splicing))
                                                                                           ('#<procedure #34 ##list>
                                                                                            (if ('#<procedure #4 ##pair?>
                                                                                                 e)
                                                                                                ('#<procedure #6 ##car>
                                                                                                 e)
                                                                                                (car e))
                                                                                            (expand (let ((temp.905
                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                e)
                                                                                                               ('#<procedure #7 ##cdr>
                                                                                                                e)
                                                                                                               #f)))
                                                                                                      (if ('#<procedure #4 ##pair?>
                                                                                                           temp.905)
                                                                                                          ('#<procedure #6 ##car>
                                                                                                           temp.905)
                                                                                                          (cadr e)))
                                                                                                    r))
                                                                                           ('#<procedure #10 ##cons>
                                                                                            (quasi-expand
                                                                                             expand
                                                                                             r
                                                                                             (if ('#<procedure #4 ##pair?>
                                                                                                  e)
                                                                                                 ('#<procedure #6 ##car>
                                                                                                  e)
                                                                                                 (car e)))
                                                                                            (quasi-expand
                                                                                             expand
                                                                                             r
                                                                                             (if ('#<procedure #4 ##pair?>
                                                                                                  e)
                                                                                                 ('#<procedure #7 ##cdr>
                                                                                                  e)
                                                                                                 (cdr e))))))
                                                                                     e))))
                                                                       ('#<procedure #34 ##list>
                                                                        'quasiquote
                                                                        (quasi-expand
                                                                         expand
                                                                         r
                                                                         e))))
                                                                   (letrec ((loop2.910
                                                                             (lambda (expand
                                                                                      r
                                                                                      lst2.911)
                                                                               (if ('#<procedure #4 ##pair?>
                                                                                    lst2.911)
                                                                                   (let ((x.912 (let ((e ('#<procedure #6 ##car>
                                                                                                          lst2.911)))
                                                                                                  (expand e
                                                                                                          r))))
                                                                                     ('#<procedure #10 ##cons>
                                                                                      x.912
                                                                                      (loop2.910
                                                                                       expand
                                                                                       r
                                                                                       ('#<procedure #7 ##cdr>
                                                                                        lst2.911))))
                                                                                   '()))))
                                                                     (loop2.910
                                                                      expand
                                                                      r
                                                                      e)))))))))))))))
               (expand* (lambda (e* r)
                          (letrec ((loop2.776
                                    (lambda (expand r lst2.777)
                                      (if ('#<procedure #4 ##pair?> lst2.777)
                                          (let ((x.778 (let ((e ('#<procedure #6 ##car>
                                                                 lst2.777)))
                                                         (expand e r))))
                                            ('#<procedure #10 ##cons>
                                             x.778
                                             (loop2.776
                                              expand
                                              r
                                              ('#<procedure #7 ##cdr>
                                               lst2.777))))
                                          '()))))
                            (loop2.776 expand r e*)))))
        expand*))))

(define Class-super-length
  (lambda (c)
    ('#<procedure #21 ##fx+> 1 ('#<procedure #32 ##vector-ref> c 4))))

(define is-a?
  (lambda (o class)
    (if (Class? class) (Class-is-a? o class) (internal-meroon-error o class))))

(set! is-a? is-a?)

'is-a?

(define default-is-a? internal-meroon-error)

#t

#f

(define Class-is-a?
  (lambda (o class)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((ocn ('#<procedure #32 ##vector-ref> o 0)))
           (let ((o-class ('#<procedure #32 ##vector-ref> *classes* ocn)))
             (or ('#<procedure #3 ##eq?> class o-class)
                 (let ((depth ('#<procedure #21 ##fx+>
                               1
                               ('#<procedure #32 ##vector-ref> class 4)))
                       (cn ('#<procedure #32 ##vector-ref> class 2)))
                   (and ('#<procedure #49 ##fx<=>
                         depth
                         ('#<procedure #21 ##fx+>
                          1
                          ('#<procedure #32 ##vector-ref> o-class 4)))
                        ('#<procedure #50 ##fx=>
                         cn
                         (let ((index ('#<procedure #39 ##fx-> depth 1)))
                           (if (and ('#<procedure #36 ##fx>=> index 0)
                                    ('#<procedure #49 ##fx<=>
                                     index
                                     ('#<procedure #32 ##vector-ref>
                                      o-class
                                      4)))
                               (let ((offset ('#<procedure #21 ##fx+>
                                              10
                                              ('#<procedure #21 ##fx+>
                                               1
                                               index))))
                                 (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                                   ('#<procedure #32 ##vector-ref> o-class i)))
                               (report-bad-index
                                'super
                                o-class
                                index))))))))))))

(define subclass?
  (lambda (class1 class2)
    (let ((begin-temp.16
           (if (and (Class? class1) (Class? class2))
               #!void
               (report-meroon-error
                'Domain
                'subclass?
                "Must be classes"
                class1
                class2))))
      (careless-subclass? class1 class2))))

(define careless-subclass?
  (lambda (class1 class2)
    (let ((depth2 ('#<procedure #32 ##vector-ref> class2 4))
          (cn2 ('#<procedure #32 ##vector-ref> class2 2)))
      (and ('#<procedure #36 ##fx>=>
            ('#<procedure #32 ##vector-ref> class1 4)
            depth2)
           ('#<procedure #50 ##fx=>
            cn2
            (if (and ('#<procedure #36 ##fx>=> depth2 0)
                     ('#<procedure #49 ##fx<=>
                      depth2
                      ('#<procedure #32 ##vector-ref> class1 4)))
                (let ((offset ('#<procedure #21 ##fx+>
                               10
                               ('#<procedure #21 ##fx+> 1 depth2))))
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #32 ##vector-ref> class1 i)))
                (report-bad-index 'super class1 depth2)))))))

(define implements?
  (lambda (class view)
    (let ((begin-temp.18
           (if (Class? class)
               #!void
               (report-meroon-error
                'Domain
                'implements
                "Inappropriate class"
                Class-class
                class))))
      (let ((begin-temp.17
             (if (View? view)
                 #!void
                 (report-meroon-error
                  'Domain
                  'implements
                  "Inappropriate class"
                  View-class
                  class))))
        (let ((temp.914 (Class-views class)))
          (letrec ((loop.915
                    (lambda (view lst1.916)
                      (if ('#<procedure #4 ##pair?> lst1.916)
                          (let ((x.917 ('#<procedure #6 ##car> lst1.916)))
                            (if ('#<procedure #3 ##eq?>
                                 view
                                 ('#<procedure #6 ##car> x.917))
                                x.917
                                (loop.915
                                 view
                                 ('#<procedure #7 ##cdr> lst1.916))))
                          #f))))
            (loop.915 view temp.914)))))))

(define View-is-a?
  (lambda (o view)
    (and ('#<procedure #28 ##meroon?> o)
         (implements?
          ('#<procedure #32 ##vector-ref>
           *classes*
           ('#<procedure #32 ##vector-ref> o 0))
          view))))

(define resolve-virtual-field
  (lambda (field class)
    (let ((view (Virtual-Field-view field)))
      (let ((map (let ((temp.919 (Class-views class)))
                   (letrec ((loop.920
                             (lambda (view lst1.921)
                               (if ('#<procedure #4 ##pair?> lst1.921)
                                   (let ((x.922 ('#<procedure #6 ##car>
                                                 lst1.921)))
                                     (if ('#<procedure #3 ##eq?>
                                          view
                                          ('#<procedure #6 ##car> x.922))
                                         x.922
                                         (loop.920
                                          view
                                          ('#<procedure #7 ##cdr> lst1.921))))
                                   #f))))
                     (loop.920 view temp.919)))))
        (if map
            ('#<procedure #51 list-ref> map (Virtual-Field-index field))
            #f)))))

(define *classes* ('#<procedure #52 make-vector> 35 #f))

(define *class-number* 0)

(define object->class
  (lambda (o)
    ('#<procedure #32 ##vector-ref>
     *classes*
     ('#<procedure #32 ##vector-ref> o 0))))

(define number->class
  (lambda (i) ('#<procedure #32 ##vector-ref> *classes* i)))

(define current-class-number
  (lambda (cn)
    (let ((o ('#<procedure #32 ##vector-ref> *classes* cn)))
      ('#<procedure #32 ##vector-ref> o 2))))

(define get-new-class-number
  (lambda ()
    (let ((i *class-number*))
      (let ((begin-temp.20
             (set! *class-number* ('#<procedure #21 ##fx+> 1 *class-number*))))
        (let ((begin-temp.19
               (if ('#<procedure #36 ##fx>=>
                    *class-number*
                    ('#<procedure #29 ##vector-length> *classes*))
                   (extend-classes-number!)
                   #!void)))
          i)))))

(define symbol->class
  (lambda (name . default)
    (letrec ((scan (lambda (name default i)
                     (let ((class ('#<procedure #32 ##vector-ref>
                                   *classes*
                                   i)))
                       (if ('#<procedure #3 ##eq?>
                            ('#<procedure #32 ##vector-ref> class 1)
                            name)
                           class
                           (if ('#<procedure #53 ##fx>> i 0)
                               (scan name
                                     default
                                     ('#<procedure #39 ##fx-> i 1))
                               (if ('#<procedure #4 ##pair?> default)
                                   (('#<procedure #6 ##car> default) name)
                                   (report-meroon-error
                                    'Anomaly
                                    'symbol->class
                                    "No such class"
                                    name))))))))
      (scan name default ('#<procedure #39 ##fx-> *class-number* 1)))))

(define *generics* ('#<procedure #52 make-vector> 20 #f))

(define *generic-number* 0)

(define get-new-generic-number
  (lambda ()
    (let ((i *generic-number*))
      (let ((begin-temp.22
             (if ('#<procedure #36 ##fx>=>
                  *generic-number*
                  ('#<procedure #29 ##vector-length> *generics*))
                 (set! *generics* (vector-extend *generics*))
                 #!void)))
        (let ((begin-temp.21
               (set! *generic-number*
                     ('#<procedure #21 ##fx+> 1 *generic-number*))))
          i)))))

(define symbol->generic
  (lambda (name . default)
    (sequence-find
     name
     *generics*
     Generic-name
     identity
     (if ('#<procedure #4 ##pair?> default)
         ('#<procedure #6 ##car> default)
         (lambda (name)
           (report-meroon-error
            'Anomaly
            'symbol->generic
            "No such generic"
            name))))))

(define *last-meroon-anomaly* #f)

(define vector-extend
  (lambda (s . at-least)
    (let ((n ('#<procedure #29 ##vector-length> s)))
      (let ((r ('#<procedure #52 make-vector>
                (if ('#<procedure #4 ##pair?> at-least)
                    ('#<procedure #54 ##fxmax>
                     ('#<procedure #6 ##car> at-least)
                     n)
                    ('#<procedure #21 ##fx+>
                     n
                     ('#<procedure #21 ##fx+>
                      1
                      ('#<procedure #55 ##fxquotient> n 2))))
                #f)))
        (let ((begin-temp.23 (copy-vector-slice! s r 0 n))) r)))))

(define copy-vector-slice!
  (lambda (old new start end)
    (letrec ((copy (lambda (old new end i)
                     (if ('#<procedure #20 ##fx<> i end)
                         (let ((begin-temp.24
                                ('#<procedure #33 ##vector-set!>
                                 new
                                 i
                                 ('#<procedure #32 ##vector-ref> old i))))
                           (copy old new end ('#<procedure #21 ##fx+> i 1)))
                         #!void))))
      (copy old new end start))))

(define sequence-map
  (lambda (fn v)
    (if ('#<procedure #24 ##null?> v)
        #f
        (if ('#<procedure #56 ##vector?> v)
            (let ((n ('#<procedure #29 ##vector-length> v)))
              (letrec ((mapvector
                        (lambda (fn v n i)
                          (if ('#<procedure #20 ##fx<> i n)
                              (let ((begin-temp.25
                                     (fn ('#<procedure #32 ##vector-ref>
                                          v
                                          i))))
                                (let ((i ('#<procedure #21 ##fx+> 1 i)))
                                  (if ('#<procedure #20 ##fx<> i n)
                                      (let ((begin-temp.25
                                             (fn ('#<procedure #32 ##vector-ref>
                                                  v
                                                  i))))
                                        (mapvector
                                         fn
                                         v
                                         n
                                         ('#<procedure #21 ##fx+> 1 i)))
                                      #!void)))
                              #!void))))
                (mapvector fn v n 0)))
            (if ('#<procedure #4 ##pair?> v)
                (letrec ((loop2.925
                          (lambda (fn lst2.926)
                            (if ('#<procedure #4 ##pair?> lst2.926)
                                (let ((x.927 (fn ('#<procedure #6 ##car>
                                                  lst2.926))))
                                  (let ((lst2.926
                                         ('#<procedure #7 ##cdr> lst2.926)))
                                    (if ('#<procedure #4 ##pair?> lst2.926)
                                        (let ((x.927 (fn ('#<procedure #6 ##car>
                                                          lst2.926))))
                                          (loop2.925
                                           fn
                                           ('#<procedure #7 ##cdr> lst2.926)))
                                        #!void)))
                                #!void))))
                  (loop2.925 fn v))
                (oo-error 'sequence-map "Not a sequence" v))))))

(define sequence-find
  (lambda (name s key success fail)
    (if ('#<procedure #24 ##null?> s)
        (fail name)
        (if ('#<procedure #56 ##vector?> s)
            (letrec ((look (lambda (name s key success fail i)
                             (if (and ('#<procedure #20 ##fx<>
                                       i
                                       ('#<procedure #29 ##vector-length> s))
                                      ('#<procedure #32 ##vector-ref> s i))
                                 (if ('#<procedure #3 ##eq?>
                                      name
                                      (key ('#<procedure #32 ##vector-ref>
                                            s
                                            i)))
                                     (success ('#<procedure #32 ##vector-ref>
                                               s
                                               i))
                                     (look name
                                           s
                                           key
                                           success
                                           fail
                                           ('#<procedure #21 ##fx+> i 1)))
                                 (fail name)))))
              (look name s key success fail 0))
            (if ('#<procedure #4 ##pair?> s)
                (letrec ((look (lambda (name key success fail s)
                                 (if ('#<procedure #4 ##pair?> s)
                                     (if ('#<procedure #3 ##eq?>
                                          name
                                          (key ('#<procedure #6 ##car> s)))
                                         (success ('#<procedure #6 ##car> s))
                                         (look name
                                               key
                                               success
                                               fail
                                               ('#<procedure #7 ##cdr> s)))
                                     (fail name)))))
                  (look name key success fail s))
                (oo-error 'sequence-find "Not a sequence" s))))))

(define fill-instance!
  (lambda (ins-tance index content)
    (if ('#<procedure #4 ##pair?> content)
        (let ((begin-temp.26
               (let ((value ('#<procedure #6 ##car> content)))
                 (let ((i ('#<procedure #21 ##fx+> 1 index)))
                   ('#<procedure #33 ##vector-set!> ins-tance i value)))))
          (fill-instance!
           ins-tance
           ('#<procedure #21 ##fx+> 1 index)
           ('#<procedure #7 ##cdr> content)))
        ins-tance)))

(define meroon-uninitialized ('#<procedure #34 ##list> '???))

(define uninitialized?
  (lambda (value) ('#<procedure #3 ##eq?> meroon-uninitialized value)))

(define check-fields
  (lambda (class super-name description)
    (let ((begin-temp.29
           (if ('#<procedure #3 ##eq?>
                super-name
                (Class-name (Class-super-class class)))
               #!void
               (report-meroon-error
                'Syntax
                'define-class
                "Incompatible super-class"
                super-name))))
      (let ((begin-temp.28
             (if ('#<procedure #50 ##fx=>
                  ('#<procedure #23 length> description)
                  ('#<procedure #23 length> (Class-fields class)))
                 #!void
                 (report-meroon-error
                  'Syntax
                  'define-class
                  "Incompatible number of fields"
                  (Class-fields class)))))
        (let ((begin-temp.27
               (if (every? (lambda (f desc)
                             (and ('#<procedure #3 ##eq?>
                                   (Field-name f)
                                   ('#<procedure #6 ##car> desc))
                                  ('#<procedure #3 ##eq?>
                                   (Class-name
                                    ('#<procedure #32 ##vector-ref>
                                     *classes*
                                     ('#<procedure #32 ##vector-ref> f 0)))
                                   ('#<procedure #7 ##cdr> desc))))
                           (Class-fields class)
                           description)
                   #!void
                   (report-meroon-error
                    'Syntax
                    'define-class
                    "Incompatible :prototype !?"
                    (Class-name class)))))
          #t)))))

(define collect-super-class-numbers
  (lambda (class)
    (letrec ((collect (lambda (cn)
                        ('#<procedure #10 ##cons>
                         cn
                         (let ((super (let ((class ('#<procedure #32 ##vector-ref>
                                                    *classes*
                                                    cn)))
                                        ('#<procedure #32 ##vector-ref>
                                         class
                                         5))))
                           (if super (collect super) '()))))))
      (let ((cn ('#<procedure #32 ##vector-ref> class 2)))
        ('#<procedure #10 ##cons>
         cn
         (let ((super (let ((class ('#<procedure #32 ##vector-ref>
                                    *classes*
                                    cn)))
                        ('#<procedure #32 ##vector-ref> class 5))))
           (if super
               ('#<procedure #10 ##cons>
                super
                (let ((super (let ((class ('#<procedure #32 ##vector-ref>
                                           *classes*
                                           super)))
                               ('#<procedure #32 ##vector-ref> class 5))))
                  (if super (collect super) '())))
               '())))))))

(define common-super-class-number
  (lambda (c1 c2)
    (letrec ((deeper (lambda (c1 c2 i)
                       (if ('#<procedure #50 ##fx=>
                            (if (and ('#<procedure #36 ##fx>=> i 0)
                                     ('#<procedure #49 ##fx<=>
                                      i
                                      ('#<procedure #32 ##vector-ref> c1 4)))
                                (let ((offset ('#<procedure #21 ##fx+>
                                               10
                                               ('#<procedure #21 ##fx+> 1 i))))
                                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                                    ('#<procedure #32 ##vector-ref> c1 i)))
                                (report-bad-index 'super c1 i))
                            (if (and ('#<procedure #36 ##fx>=> i 0)
                                     ('#<procedure #49 ##fx<=>
                                      i
                                      ('#<procedure #32 ##vector-ref> c2 4)))
                                (let ((offset ('#<procedure #21 ##fx+>
                                               10
                                               ('#<procedure #21 ##fx+> 1 i))))
                                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                                    ('#<procedure #32 ##vector-ref> c2 i)))
                                (report-bad-index 'super c2 i)))
                           (if (and ('#<procedure #36 ##fx>=> i 0)
                                    ('#<procedure #49 ##fx<=>
                                     i
                                     ('#<procedure #32 ##vector-ref> c1 4)))
                               (let ((offset ('#<procedure #21 ##fx+>
                                              10
                                              ('#<procedure #21 ##fx+> 1 i))))
                                 (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                                   ('#<procedure #32 ##vector-ref> c1 i)))
                               (report-bad-index 'super c1 i))
                           (and ('#<procedure #53 ##fx>> i 0)
                                (deeper c1
                                        c2
                                        ('#<procedure #39 ##fx-> i 1)))))))
      (let ((i ('#<procedure #57 ##fxmin>
                ('#<procedure #21 ##fx+>
                 1
                 ('#<procedure #32 ##vector-ref> c1 4))
                ('#<procedure #21 ##fx+>
                 1
                 ('#<procedure #32 ##vector-ref> c2 4)))))
        (if ('#<procedure #50 ##fx=>
             (if (and ('#<procedure #36 ##fx>=> i 0)
                      ('#<procedure #49 ##fx<=>
                       i
                       ('#<procedure #32 ##vector-ref> c1 4)))
                 (let ((offset ('#<procedure #21 ##fx+>
                                10
                                ('#<procedure #21 ##fx+> 1 i))))
                   (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                     ('#<procedure #32 ##vector-ref> c1 i)))
                 (report-bad-index 'super c1 i))
             (if (and ('#<procedure #36 ##fx>=> i 0)
                      ('#<procedure #49 ##fx<=>
                       i
                       ('#<procedure #32 ##vector-ref> c2 4)))
                 (let ((offset ('#<procedure #21 ##fx+>
                                10
                                ('#<procedure #21 ##fx+> 1 i))))
                   (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                     ('#<procedure #32 ##vector-ref> c2 i)))
                 (report-bad-index 'super c2 i)))
            (if (and ('#<procedure #36 ##fx>=> i 0)
                     ('#<procedure #49 ##fx<=>
                      i
                      ('#<procedure #32 ##vector-ref> c1 4)))
                (let ((offset ('#<procedure #21 ##fx+>
                               10
                               ('#<procedure #21 ##fx+> 1 i))))
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #32 ##vector-ref> c1 i)))
                (report-bad-index 'super c1 i))
            (and ('#<procedure #53 ##fx>> i 0)
                 (deeper c1 c2 ('#<procedure #39 ##fx-> i 1))))))))

(define *last-defined-class* #f)

(define register-class
  (lambda (rev class name superclass own-fields)
    (let ((begin-temp.32 (check-revision rev)))
      (let ((begin-temp.31
             (if (field-defined? class 'name)
                 #!void
                 ('#<procedure #33 ##vector-set!> class 1 name))))
        (let ((begin-temp.30
               (if (field-defined? class 'super-number)
                   #!void
                   (let ((scn (Class-number superclass)))
                     ('#<procedure #33 ##vector-set!> class 5 scn)))))
          (Class-add-subclass class superclass own-fields))))))

(define Class-add-subclass
  (lambda (class super-class own-fields)
    (let ((old-class
           ((lambda (name . default)
              (letrec ((scan (lambda (name default i)
                               (let ((class ('#<procedure #32 ##vector-ref>
                                             *classes*
                                             i)))
                                 (if ('#<procedure #3 ##eq?>
                                      ('#<procedure #32 ##vector-ref> class 1)
                                      name)
                                     class
                                     (if ('#<procedure #53 ##fx>> i 0)
                                         (scan name
                                               default
                                               ('#<procedure #39 ##fx-> i 1))
                                         (if ('#<procedure #4 ##pair?> default)
                                             (('#<procedure #6 ##car> default)
                                              name)
                                             (report-meroon-error
                                              'Anomaly
                                              'symbol->class
                                              "No such class"
                                              name))))))))
                (scan name
                      default
                      ('#<procedure #39 ##fx-> *class-number* 1))))
            ('#<procedure #32 ##vector-ref> class 1)
            (lambda (name) #f))))
      (let ((begin-temp.52
             (if old-class
                 (let ((old-super-class (Class-super-class old-class)))
                   (set-Class-subclass-numbers!
                    old-super-class
                    (let ((list ('#<procedure #32 ##vector-ref>
                                 old-super-class
                                 6))
                          (item ('#<procedure #32 ##vector-ref> old-class 2)))
                      (if ('#<procedure #4 ##pair?> list)
                          (if ('#<procedure #25 equal?>
                               item
                               ('#<procedure #6 ##car> list))
                              ('#<procedure #7 ##cdr> list)
                              ('#<procedure #10 ##cons>
                               ('#<procedure #6 ##car> list)
                               (let ((list ('#<procedure #7 ##cdr> list)))
                                 (if ('#<procedure #4 ##pair?> list)
                                     (if ('#<procedure #25 equal?>
                                          item
                                          ('#<procedure #6 ##car> list))
                                         ('#<procedure #7 ##cdr> list)
                                         ('#<procedure #10 ##cons>
                                          ('#<procedure #6 ##car> list)
                                          (let ((list ('#<procedure #7 ##cdr>
                                                       list)))
                                            (if ('#<procedure #4 ##pair?> list)
                                                (if ('#<procedure #25 equal?>
                                                     item
                                                     ('#<procedure #6 ##car>
                                                      list))
                                                    ('#<procedure #7 ##cdr>
                                                     list)
                                                    ('#<procedure #10 ##cons>
                                                     ('#<procedure #6 ##car>
                                                      list)
                                                     (let ((list ('#<procedure #7 ##cdr>
                                                                  list)))
                                                       (if ('#<procedure #4 ##pair?>
                                                            list)
                                                           (if ('#<procedure #25 equal?>
                                                                item
                                                                ('#<procedure #6 ##car>
                                                                 list))
                                                               ('#<procedure #7 ##cdr>
                                                                list)
                                                               ('#<procedure #10 ##cons>
                                                                ('#<procedure #6 ##car>
                                                                 list)
                                                                (remove item
                                                                        ('#<procedure #7 ##cdr>
                                                                         list))))
                                                           list))))
                                                list))))
                                     list))))
                          list))))
                 #!void)))
        (let ((strict-supers (collect-super-class-numbers super-class)))
          (let ((begin-temp.51
                 (let ((scn ('#<procedure #32 ##vector-ref> super-class 2)))
                   ('#<procedure #33 ##vector-set!> class 5 scn))))
            (let ((begin-temp.50
                   (let ((cn ('#<procedure #21 ##fx+>
                              1
                              ('#<procedure #32 ##vector-ref> super-class 4))))
                     ('#<procedure #33 ##vector-set!> class 4 cn))))
              (let ((begin-temp.49
                     (let ((lcn (if old-class
                                    ('#<procedure #32 ##vector-ref>
                                     old-class
                                     6)
                                    ('#<procedure #34 ##list>))))
                       ('#<procedure #33 ##vector-set!> class 6 lcn))))
                (let ((begin-temp.48
                       (if (field-defined? class 'fields)
                           #!void
                           (let ((fields ('#<procedure #46 append>
                                          (let ((temp.929
                                                 ('#<procedure #32 ##vector-ref>
                                                  super-class
                                                  3)))
                                            (letrec ((loop2.930
                                                      (lambda (lst2.931)
                                                        (if ('#<procedure #4 ##pair?>
                                                             lst2.931)
                                                            (let ((x.932 (instance-clone
                                                                          ('#<procedure #6 ##car>
                                                                           lst2.931))))
                                                              ('#<procedure #10 ##cons>
                                                               x.932
                                                               (loop2.930
                                                                ('#<procedure #7 ##cdr>
                                                                 lst2.931))))
                                                            '()))))
                                              (loop2.930 temp.929)))
                                          own-fields)))
                             ('#<procedure #33 ##vector-set!>
                              class
                              3
                              fields)))))
                  (let ((begin-temp.47
                         (if (field-defined? class 'immutable?)
                             #!void
                             (let ((bool (every? Field-immutable?
                                                 ('#<procedure #32 ##vector-ref>
                                                  class
                                                  3))))
                               ('#<procedure #33 ##vector-set!>
                                class
                                9
                                bool)))))
                    (let ((begin-temp.46
                           (let ((cn (if old-class
                                         ('#<procedure #32 ##vector-ref>
                                          old-class
                                          2)
                                         (let ((cn (get-new-class-number)))
                                           (let ((begin-temp.34
                                                  ('#<procedure #33 ##vector-set!>
                                                   Object-class
                                                   7
                                                   cn)))
                                             cn)))))
                             (let ((supers (reverse!
                                            ('#<procedure #10 ##cons>
                                             cn
                                             strict-supers))))
                               (let ((begin-temp.41
                                      ('#<procedure #33 ##vector-set!>
                                       class
                                       2
                                       cn)))
                                 (let ((begin-temp.40
                                        ('#<procedure #33 ##vector-set!>
                                         *classes*
                                         cn
                                         class)))
                                   (let ((begin-temp.39
                                          (letrec ((fill (lambda (class
                                                                  i
                                                                  supers)
                                                           (if ('#<procedure #4 ##pair?>
                                                                supers)
                                                               (let ((begin-temp.35
                                                                      (let ((cn ('#<procedure #6 ##car>
                                                                                 supers)))
                                                                        (if (and ('#<procedure #36 ##fx>=>
                                                                                  i
                                                                                  0)
                                                                                 ('#<procedure #49 ##fx<=>
                                                                                  i
                                                                                  ('#<procedure #32 ##vector-ref>
                                                                                   class
                                                                                   4)))
                                                                            (let ((offset ('#<procedure #21 ##fx+>
                                                                                           10
                                                                                           ('#<procedure #21 ##fx+>
                                                                                            1
                                                                                            i))))
                                                                              (let ((i ('#<procedure #21 ##fx+>
                                                                                        1
                                                                                        offset)))
                                                                                ('#<procedure #33 ##vector-set!>
                                                                                 class
                                                                                 i
                                                                                 cn)))
                                                                            (report-bad-index
                                                                             'super
                                                                             class
                                                                             i)))))
                                                                 (fill class
                                                                       ('#<procedure #21 ##fx+>
                                                                        1
                                                                        i)
                                                                       ('#<procedure #7 ##cdr>
                                                                        supers)))
                                                               #!void))))
                                            (fill class 0 supers))))
                                     (let ((begin-temp.38
                                            (let ((cn (if old-class
                                                          ('#<procedure #32 ##vector-ref>
                                                           old-class
                                                           7)
                                                          0)))
                                              ('#<procedure #33 ##vector-set!>
                                               class
                                               7
                                               cn))))
                                       (letrec ((fill (lambda (class
                                                               old-class
                                                               i
                                                               supers)
                                                        (if ('#<procedure #4 ##pair?>
                                                             supers)
                                                            (let ((begin-temp.37
                                                                   (let ((cn (let ((cls (let ((i ('#<procedure #6 ##car>
                                                                                                  supers)))
                                                                                          ('#<procedure #32 ##vector-ref>
                                                                                           *classes*
                                                                                           i))))
                                                                               (if old-class
                                                                                   (if (and ('#<procedure #36 ##fx>=>
                                                                                             i
                                                                                             0)
                                                                                            ('#<procedure #49 ##fx<=>
                                                                                             i
                                                                                             ('#<procedure #32 ##vector-ref>
                                                                                              old-class
                                                                                              4)))
                                                                                       (let ((offset ('#<procedure #21 ##fx+>
                                                                                                      10
                                                                                                      ('#<procedure #21 ##fx+>
                                                                                                       1
                                                                                                       ('#<procedure #21 ##fx+>
                                                                                                        ('#<procedure #32 ##vector-ref>
                                                                                                         old-class
                                                                                                         4)
                                                                                                        i)))))
                                                                                         (let ((i ('#<procedure #21 ##fx+>
                                                                                                   1
                                                                                                   offset)))
                                                                                           ('#<procedure #32 ##vector-ref>
                                                                                            old-class
                                                                                            i)))
                                                                                       (report-bad-index
                                                                                        'super
                                                                                        old-class
                                                                                        i))
                                                                                   (let ((nxt ('#<procedure #32 ##vector-ref>
                                                                                               cls
                                                                                               7)))
                                                                                     (let ((begin-temp.36
                                                                                            (let ((cn ('#<procedure #21 ##fx+>
                                                                                                       nxt
                                                                                                       1)))
                                                                                              ('#<procedure #33 ##vector-set!>
                                                                                               cls
                                                                                               7
                                                                                               cn))))
                                                                                       nxt))))))
                                                                     (if (and ('#<procedure #36 ##fx>=>
                                                                               i
                                                                               0)
                                                                              ('#<procedure #49 ##fx<=>
                                                                               i
                                                                               ('#<procedure #32 ##vector-ref>
                                                                                class
                                                                                4)))
                                                                         (let ((offset ('#<procedure #21 ##fx+>
                                                                                        10
                                                                                        ('#<procedure #21 ##fx+>
                                                                                         1
                                                                                         ('#<procedure #21 ##fx+>
                                                                                          ('#<procedure #32 ##vector-ref>
                                                                                           class
                                                                                           4)
                                                                                          i)))))
                                                                           (let ((i ('#<procedure #21 ##fx+>
                                                                                     1
                                                                                     offset)))
                                                                             ('#<procedure #33 ##vector-set!>
                                                                              class
                                                                              i
                                                                              cn)))
                                                                         (report-bad-index
                                                                          'super
                                                                          class
                                                                          i)))))
                                                              (fill class
                                                                    old-class
                                                                    ('#<procedure #21 ##fx+>
                                                                     1
                                                                     i)
                                                                    ('#<procedure #7 ##cdr>
                                                                     supers)))
                                                            #!void))))
                                         (fill class
                                               old-class
                                               1
                                               ('#<procedure #7 ##cdr>
                                                supers)))))))))))
                      (let ((begin-temp.45
                             (let ((temp.934
                                    ('#<procedure #32 ##vector-ref> class 3)))
                               (letrec ((loop2.935
                                         (lambda (class lst2.936)
                                           (if ('#<procedure #4 ##pair?>
                                                lst2.936)
                                               (let ((x.937 (let ((field ('#<procedure #6 ##car>
                                                                          lst2.936)))
                                                              (if (field-defined?
                                                                   field
                                                                   'class-number)
                                                                  #f
                                                                  (let ((cn ('#<procedure #32 ##vector-ref>
                                                                             class
                                                                             2)))
                                                                    ('#<procedure #33 ##vector-set!>
                                                                     field
                                                                     3
                                                                     cn))))))
                                                 (let ((lst2.936
                                                        ('#<procedure #7 ##cdr>
                                                         lst2.936)))
                                                   (if ('#<procedure #4 ##pair?>
                                                        lst2.936)
                                                       (let ((x.937 (let ((field ('#<procedure #6 ##car>
                                                                                  lst2.936)))
                                                                      (if (field-defined?
                                                                           field
                                                                           'class-number)
                                                                          #f
                                                                          (let ((cn ('#<procedure #32 ##vector-ref>
                                                                                     class
                                                                                     2)))
                                                                            ('#<procedure #33 ##vector-set!>
                                                                             field
                                                                             3
                                                                             cn))))))
                                                         (loop2.935
                                                          class
                                                          ('#<procedure #7 ##cdr>
                                                           lst2.936)))
                                                       #!void)))
                                               #!void))))
                                 (loop2.935 class temp.934)))))
                        (let ((begin-temp.44
                               (if (field-defined? class 'allocator)
                                   #!void
                                   (let ((a (create-allocator class)))
                                     ('#<procedure #33 ##vector-set!>
                                      class
                                      8
                                      a)))))
                          (let ((begin-temp.43
                                 (let ((lcn ('#<procedure #10 ##cons>
                                             ('#<procedure #32 ##vector-ref>
                                              class
                                              2)
                                             ('#<procedure #32 ##vector-ref>
                                              super-class
                                              6))))
                                   ('#<procedure #33 ##vector-set!>
                                    super-class
                                    6
                                    lcn))))
                            (let ((begin-temp.42
                                   (if old-class
                                       #!void
                                       (propagate-super-methods! class))))
                              (initialize! class))))))))))))))))

(define add-subclass Class-add-subclass)

(set! add-subclass add-subclass)

'add-subclass

(define fill-other-fields! (lambda (o) o))

(set! fill-other-fields! fill-other-fields!)

'fill-other-fields!

(define propagate-super-methods!
  (lambda (class)
    (sequence-map
     (lambda (g) (if g (Generic-update! g class) #!void))
     *generics*)))

(define create-allocator
  (lambda (class)
    (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
      (let ((last-field
             (if ('#<procedure #4 ##pair?> fields)
                 ('#<procedure #6 ##car> (last-pair fields))
                 #f)))
        (let ((n (count-Poly-Fields fields)))
          (if ('#<procedure #3 ##eq?> n 0)
              (let ((size (if last-field
                              ('#<procedure #21 ##fx+>
                               1
                               ('#<procedure #32 ##vector-ref> last-field 7))
                              0)))
                (lambda ()
                  (let ((cn ('#<procedure #32 ##vector-ref> class 2)))
                    (let ((result (let ((n ('#<procedure #21 ##fx+> 1 size)))
                                    (let ((result ('#<procedure #30 ##make-vector>
                                                   n
                                                   meroon-uninitialized)))
                                      (let ((begin-temp.54
                                             ('#<procedure #31 ##subtype-set!>
                                              result
                                              6)))
                                        result)))))
                      (let ((begin-temp.55
                             ('#<procedure #33 ##vector-set!> result 0 cn)))
                        result)))))
              (if ('#<procedure #3 ##eq?> n 1)
                  (let ((size2 (if ('#<procedure #50 ##fx=>
                                    1
                                    (Field-path-length last-field))
                                   0
                                   ('#<procedure #21 ##fx+>
                                    1
                                    (Field-path last-field 1))))
                        (size1 (Field-path last-field 0)))
                    (lambda (size)
                      (let ((begin-temp.59 (check-size size class)))
                        (let ((v (let ((size ('#<procedure #21 ##fx+>
                                              size1
                                              ('#<procedure #21 ##fx+>
                                               1
                                               ('#<procedure #21 ##fx+>
                                                size
                                                size2))))
                                       (cn ('#<procedure #32 ##vector-ref>
                                            class
                                            2)))
                                   (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                           1
                                                           size)))
                                                   (let ((result ('#<procedure #30 ##make-vector>
                                                                  n
                                                                  meroon-uninitialized)))
                                                     (let ((begin-temp.56
                                                            ('#<procedure #31 ##subtype-set!>
                                                             result
                                                             6)))
                                                       result)))))
                                     (let ((begin-temp.57
                                            ('#<procedure #33 ##vector-set!>
                                             result
                                             0
                                             cn)))
                                       result)))))
                          (let ((begin-temp.58
                                 (let ((i ('#<procedure #21 ##fx+> 1 size1)))
                                   ('#<procedure #33 ##vector-set!>
                                    v
                                    i
                                    size))))
                            v)))))
                  (lambda sizes
                    (let ((v (let ((size (letrec ((count (lambda (class
                                                                  last-field
                                                                  n
                                                                  i
                                                                  sizes)
                                                           (if ('#<procedure #20 ##fx<>
                                                                i
                                                                n)
                                                               (if ('#<procedure #4 ##pair?>
                                                                    sizes)
                                                                   (let ((begin-temp.60
                                                                          (let ((sz ('#<procedure #6 ##car>
                                                                                     sizes)))
                                                                            (if (and ('#<procedure #58 ##fixnum?>
                                                                                      sz)
                                                                                     ('#<procedure #36 ##fx>=>
                                                                                      sz
                                                                                      0))
                                                                                #f
                                                                                (report-meroon-error
                                                                                 'Domain
                                                                                 'allocate
                                                                                 "Incorrect size"
                                                                                 sz
                                                                                 class)))))
                                                                     ('#<procedure #21 ##fx+>
                                                                      (Field-path
                                                                       last-field
                                                                       i)
                                                                      ('#<procedure #21 ##fx+>
                                                                       1
                                                                       ('#<procedure #21 ##fx+>
                                                                        ('#<procedure #6 ##car>
                                                                         sizes)
                                                                        (count class
                                                                               last-field
                                                                               n
                                                                               ('#<procedure #21 ##fx+>
                                                                                i
                                                                                1)
                                                                               ('#<procedure #7 ##cdr>
                                                                                sizes))))))
                                                                   (report-meroon-error
                                                                    'Allocation
                                                                    'Meroon-allocator
                                                                    "Missing sizes"
                                                                    class
                                                                    '()))
                                                               (if ('#<procedure #24 ##null?>
                                                                    sizes)
                                                                   (if ('#<procedure #50 ##fx=>
                                                                        n
                                                                        (Field-path-length
                                                                         last-field))
                                                                       0
                                                                       ('#<procedure #21 ##fx+>
                                                                        1
                                                                        (Field-path
                                                                         last-field
                                                                         i)))
                                                                   (report-meroon-error
                                                                    'Allocation
                                                                    'Meroon-allocator
                                                                    "Too much sizes"
                                                                    sizes))))))
                                           (count class last-field n 0 sizes)))
                                   (cn ('#<procedure #32 ##vector-ref>
                                        class
                                        2)))
                               (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                       1
                                                       size)))
                                               (let ((result ('#<procedure #30 ##make-vector>
                                                              n
                                                              meroon-uninitialized)))
                                                 (let ((begin-temp.61
                                                        ('#<procedure #31 ##subtype-set!>
                                                         result
                                                         6)))
                                                   result)))))
                                 (let ((begin-temp.62
                                        ('#<procedure #33 ##vector-set!>
                                         result
                                         0
                                         cn)))
                                   result)))))
                      (let ((begin-temp.64
                             (letrec ((skeletize
                                       (lambda (last-field n v i sizes offset)
                                         (if ('#<procedure #20 ##fx<> i n)
                                             (let ((offset ('#<procedure #21 ##fx+>
                                                            offset
                                                            (Field-path
                                                             last-field
                                                             i))))
                                               (let ((begin-temp.63
                                                      (let ((value ('#<procedure #6 ##car>
                                                                    sizes)))
                                                        (let ((i ('#<procedure #21 ##fx+>
                                                                  1
                                                                  offset)))
                                                          ('#<procedure #33 ##vector-set!>
                                                           v
                                                           i
                                                           value)))))
                                                 (let ((offset ('#<procedure #21 ##fx+>
                                                                offset
                                                                ('#<procedure #21 ##fx+>
                                                                 1
                                                                 ('#<procedure #6 ##car>
                                                                  sizes))))
                                                       (sizes ('#<procedure #7 ##cdr>
                                                               sizes))
                                                       (i ('#<procedure #21 ##fx+>
                                                           i
                                                           1)))
                                                   (if ('#<procedure #20 ##fx<>
                                                        i
                                                        n)
                                                       (let ((offset ('#<procedure #21 ##fx+>
                                                                      offset
                                                                      (Field-path
                                                                       last-field
                                                                       i))))
                                                         (let ((begin-temp.63
                                                                (let ((value ('#<procedure #6 ##car>
                                                                              sizes)))
                                                                  (let ((i ('#<procedure #21 ##fx+>
                                                                            1
                                                                            offset)))
                                                                    ('#<procedure #33 ##vector-set!>
                                                                     v
                                                                     i
                                                                     value)))))
                                                           (skeletize
                                                            last-field
                                                            n
                                                            v
                                                            ('#<procedure #21 ##fx+>
                                                             i
                                                             1)
                                                            ('#<procedure #7 ##cdr>
                                                             sizes)
                                                            ('#<procedure #21 ##fx+>
                                                             offset
                                                             ('#<procedure #21 ##fx+>
                                                              1
                                                              ('#<procedure #6 ##car>
                                                               sizes))))))
                                                       #!void))))
                                             #!void))))
                               (skeletize last-field n v 0 sizes 0))))
                        v))))))))))

(define initialize! (lambda (o) o))

(set! initialize! initialize!)

'initialize!

(define check-size
  (lambda (sz hint)
    (if (and ('#<procedure #58 ##fixnum?> sz) ('#<procedure #36 ##fx>=> sz 0))
        #f
        (report-meroon-error 'Domain 'allocate "Incorrect size" sz hint))))

(define check-appropriate-size
  (lambda (size1 size2 hint)
    (let ((begin-temp.65 (check-size size2 hint)))
      (if ('#<procedure #50 ##fx=> size1 size2)
          #f
          (report-meroon-error
           'Syntax
           'make
           "Wrong number of values in Poly-Field"
           hint)))))

(define check-class
  (lambda (o class hint)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((oc ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0))))
          (if (careless-subclass? oc class)
              #f
              (report-meroon-error
               'Domain
               hint
               "Inappropriate class"
               class
               o)))
        (report-meroon-error 'Domain hint "Inappropriate class" class o))))

(define report-wrong-class
  (lambda (o class hint)
    (report-meroon-error 'Domain hint "Inappropriate class" class o)))

(define check-index
  (lambda (i o offset hint)
    (if ('#<procedure #58 ##fixnum?> i)
        (if (and ('#<procedure #36 ##fx>=> i 0)
                 ('#<procedure #20 ##fx<>
                  i
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #32 ##vector-ref> o i))))
            #t
            (report-bad-index hint o i))
        (report-meroon-error 'Domain hint "Not a legal index" i o offset))))

(define combine
  (lambda (s1 s2)
    (if ('#<procedure #3 ##eq?> s2 '=)
        s1
        (if ('#<procedure #3 ##eq?> s2 '<)
            (if (or ('#<procedure #3 ##eq?> s1 '=)
                    ('#<procedure #3 ##eq?> s1 '<))
                '<
                (if (or ('#<procedure #3 ##eq?> s1 '>)
                        ('#<procedure #3 ##eq?> s1 'clash))
                    'clash
                    (if ('#<procedure #3 ##eq?> s1 'unrelated)
                        'unrelated
                        unknown-combination)))
            (if ('#<procedure #3 ##eq?> s2 '>)
                (if (or ('#<procedure #3 ##eq?> s1 '=)
                        ('#<procedure #3 ##eq?> s1 '>))
                    '>
                    (if (or ('#<procedure #3 ##eq?> s1 '<)
                            ('#<procedure #3 ##eq?> s1 'clash))
                        'clash
                        (if ('#<procedure #3 ##eq?> s1 'unrelated)
                            'unrelated
                            unknown-combination)))
                (if ('#<procedure #3 ##eq?> s2 'unrelated)
                    'unrelated
                    unknown-combination))))))

(define unknown-combination ('#<procedure #34 ##list> "?<!>?"))

(define compare-signatures
  (lambda (sig1 sig2)
    (letrec ((comp (lambda (sig1 sig2 status)
                     (if ('#<procedure #4 ##pair?> sig1)
                         (let ((status (let ((s2 (if ('#<procedure #3 ##eq?>
                                                      ('#<procedure #6 ##car>
                                                       sig1)
                                                      ('#<procedure #6 ##car>
                                                       sig2))
                                                     '=
                                                     (if ('#<procedure #5 ##not>
                                                          ('#<procedure #6 ##car>
                                                           sig1))
                                                         '>
                                                         (if ('#<procedure #5 ##not>
                                                              ('#<procedure #6 ##car>
                                                               sig2))
                                                             '<
                                                             (if (careless-subclass?
                                                                  ('#<procedure #6 ##car>
                                                                   sig1)
                                                                  ('#<procedure #6 ##car>
                                                                   sig2))
                                                                 '<
                                                                 (if (careless-subclass?
                                                                      ('#<procedure #6 ##car>
                                                                       sig2)
                                                                      ('#<procedure #6 ##car>
                                                                       sig1))
                                                                     '>
                                                                     'unrelated)))))))
                                         (if ('#<procedure #3 ##eq?> s2 '=)
                                             status
                                             (if ('#<procedure #3 ##eq?> s2 '<)
                                                 (if (or ('#<procedure #3 ##eq?>
                                                          status
                                                          '=)
                                                         ('#<procedure #3 ##eq?>
                                                          status
                                                          '<))
                                                     '<
                                                     (if (or ('#<procedure #3 ##eq?>
                                                              status
                                                              '>)
                                                             ('#<procedure #3 ##eq?>
                                                              status
                                                              'clash))
                                                         'clash
                                                         (if ('#<procedure #3 ##eq?>
                                                              status
                                                              'unrelated)
                                                             'unrelated
                                                             unknown-combination)))
                                                 (if ('#<procedure #3 ##eq?>
                                                      s2
                                                      '>)
                                                     (if (or ('#<procedure #3 ##eq?>
                                                              status
                                                              '=)
                                                             ('#<procedure #3 ##eq?>
                                                              status
                                                              '>))
                                                         '>
                                                         (if (or ('#<procedure #3 ##eq?>
                                                                  status
                                                                  '<)
                                                                 ('#<procedure #3 ##eq?>
                                                                  status
                                                                  'clash))
                                                             'clash
                                                             (if ('#<procedure #3 ##eq?>
                                                                  status
                                                                  'unrelated)
                                                                 'unrelated
                                                                 unknown-combination)))
                                                     (if ('#<procedure #3 ##eq?>
                                                          s2
                                                          'unrelated)
                                                         'unrelated
                                                         unknown-combination))))))
                               (sig2 ('#<procedure #7 ##cdr> sig2))
                               (sig1 ('#<procedure #7 ##cdr> sig1)))
                           (if ('#<procedure #4 ##pair?> sig1)
                               (comp ('#<procedure #7 ##cdr> sig1)
                                     ('#<procedure #7 ##cdr> sig2)
                                     (combine status
                                              (if ('#<procedure #3 ##eq?>
                                                   ('#<procedure #6 ##car>
                                                    sig1)
                                                   ('#<procedure #6 ##car>
                                                    sig2))
                                                  '=
                                                  (if ('#<procedure #5 ##not>
                                                       ('#<procedure #6 ##car>
                                                        sig1))
                                                      '>
                                                      (if ('#<procedure #5 ##not>
                                                           ('#<procedure #6 ##car>
                                                            sig2))
                                                          '<
                                                          (if (careless-subclass?
                                                               ('#<procedure #6 ##car>
                                                                sig1)
                                                               ('#<procedure #6 ##car>
                                                                sig2))
                                                              '<
                                                              (if (careless-subclass?
                                                                   ('#<procedure #6 ##car>
                                                                    sig2)
                                                                   ('#<procedure #6 ##car>
                                                                    sig1))
                                                                  '>
                                                                  'unrelated)))))))
                               status))
                         status))))
      (comp sig1 sig2 '=))))

#t

(define meroon-keyword?
  (lambda (e)
    (or ('#<procedure #59 ##keyword?> e)
        (and ('#<procedure #16 ##symbol?> e)
             ('#<procedure #60 ##char=?>
              ('#<procedure #37 ##string-ref>
               ('#<procedure #17 symbol->string> e)
               0)
              #\:)))))

(define meroon-keyword-eq?
  (lambda (thing symbols)
    (let ((thing ('#<procedure #61 ##box> thing)))
      (let ((starting-index ('#<procedure #61 ##box> 1)))
        (let ((begin-temp.73
               (if ('#<procedure #59 ##keyword?>
                    ('#<procedure #62 ##unbox> thing))
                   (let ((begin-temp.70
                          ('#<procedure #63 ##set-box!>
                           thing
                           ('#<procedure #64 keyword->string>
                            ('#<procedure #62 ##unbox> thing)))))
                     ('#<procedure #63 ##set-box!> starting-index 0))
                   #!void)))
          (let ((thing (if ('#<procedure #18 ##string?>
                            ('#<procedure #62 ##unbox> thing))
                           ('#<procedure #62 ##unbox> thing)
                           ('#<procedure #17 symbol->string>
                            ('#<procedure #62 ##unbox> thing)))))
            (let ((limit ('#<procedure #35 ##string-length> thing)))
              (let ((symbols (if ('#<procedure #4 ##pair?> symbols)
                                 symbols
                                 (if ('#<procedure #16 ##symbol?> symbols)
                                     ('#<procedure #34 ##list> symbols)
                                     (report-meroon-error
                                      'Domain
                                      'meroon-keyword-eq?
                                      "Not a keyword specification"
                                      symbols)))))
                (letrec ((compare (lambda (thing limit i symbols)
                                    (if ('#<procedure #20 ##fx<> i limit)
                                        (and ('#<procedure #4 ##pair?> symbols)
                                             (let ((sym ('#<procedure #17 symbol->string>
                                                         ('#<procedure #6 ##car>
                                                          symbols))))
                                               (let ((len ('#<procedure #35 ##string-length>
                                                           sym)))
                                                 (letrec ((comp (lambda (thing
                                                                         limit
                                                                         symbols
                                                                         sym
                                                                         len
                                                                         i
                                                                         j)
                                                                  (if ('#<procedure #36 ##fx>=>
                                                                       j
                                                                       len)
                                                                      (compare thing
                                                                               limit
                                                                               i
                                                                               ('#<procedure #7 ##cdr>
                                                                                symbols))
                                                                      (and ('#<procedure #20 ##fx<>
                                                                            i
                                                                            limit)
                                                                           (and ('#<procedure #60 ##char=?>
                                                                                 ('#<procedure #37 ##string-ref>
                                                                                  thing
                                                                                  i)
                                                                                 ('#<procedure #37 ##string-ref>
                                                                                  sym
                                                                                  j))
                                                                                (comp thing
                                                                                      limit
                                                                                      symbols
                                                                                      sym
                                                                                      len
                                                                                      ('#<procedure #21 ##fx+>
                                                                                       1
                                                                                       i)
                                                                                      ('#<procedure #21 ##fx+>
                                                                                       1
                                                                                       j))))))))
                                                   (comp thing
                                                         limit
                                                         symbols
                                                         sym
                                                         len
                                                         i
                                                         0)))))
                                        ('#<procedure #24 ##null?> symbols)))))
                  (compare thing
                           limit
                           ('#<procedure #62 ##unbox> starting-index)
                           symbols))))))))))

(define find-option-plus-values
  (lambda (keyword options)
    (letrec ((get-values
              (lambda (options)
                (if (or ('#<procedure #24 ##null?> options)
                        (and ('#<procedure #4 ##pair?> options)
                             (let ((e ('#<procedure #6 ##car> options)))
                               (or ('#<procedure #59 ##keyword?> e)
                                   (and ('#<procedure #16 ##symbol?> e)
                                        ('#<procedure #60 ##char=?>
                                         ('#<procedure #37 ##string-ref>
                                          ('#<procedure #17 symbol->string> e)
                                          0)
                                         #\:))))))
                    '()
                    ('#<procedure #10 ##cons>
                     ('#<procedure #6 ##car> options)
                     (get-values ('#<procedure #7 ##cdr> options)))))))
      (let ((options (look4keyword keyword (skip2next-keyword options))))
        (if ('#<procedure #4 ##pair?> options)
            ('#<procedure #10 ##cons>
             ('#<procedure #6 ##car> options)
             (get-values ('#<procedure #7 ##cdr> options)))
            '())))))

(define find-option-values
  (lambda (keyword options default)
    (let ((kw+values (find-option-plus-values keyword options)))
      (if ('#<procedure #4 ##pair?> kw+values)
          ('#<procedure #7 ##cdr> kw+values)
          (default keyword)))))

(define find-option-single-value
  (lambda (keyword options default)
    (let ((kw+values (find-option-plus-values keyword options)))
      (if ('#<procedure #4 ##pair?> kw+values)
          (let ((values ('#<procedure #7 ##cdr> kw+values)))
            (if (and ('#<procedure #4 ##pair?> values)
                     ('#<procedure #24 ##null?>
                      ('#<procedure #7 ##cdr> values)))
                ('#<procedure #6 ##car> values)
                (report-meroon-error
                 'Syntax
                 'find-option
                 "This option expects a single value"
                 keyword
                 values)))
          (default keyword)))))

(define find-option-present?
  (lambda (keyword options)
    (let ((kw+values (find-option-plus-values keyword options)))
      (if ('#<procedure #4 ##pair?> kw+values)
          (if ('#<procedure #24 ##null?> ('#<procedure #7 ##cdr> kw+values))
              #t
              (report-meroon-error
               'Syntax
               'find-option
               "this option should not have associated values"
               keyword
               ('#<procedure #7 ##cdr> kw+values)))
          #f))))

(define check-option-present-once?
  (lambda (keyword options)
    (let ((options (look4keyword keyword (skip2next-keyword options))))
      (if ('#<procedure #4 ##pair?> options)
          ('#<procedure #24 ##null?>
           (look4keyword
            keyword
            (skip2next-keyword ('#<procedure #7 ##cdr> options))))
          #t))))

(define remove-option
  (lambda (keyword options)
    (letrec ((skip (lambda (keyword options)
                     (if ('#<procedure #4 ##pair?> options)
                         (if (and (let ((e ('#<procedure #6 ##car> options)))
                                    (or ('#<procedure #59 ##keyword?> e)
                                        (and ('#<procedure #16 ##symbol?> e)
                                             ('#<procedure #60 ##char=?>
                                              ('#<procedure #37 ##string-ref>
                                               ('#<procedure #17 symbol->string>
                                                e)
                                               0)
                                              #\:))))
                                  (meroon-keyword-eq?
                                   ('#<procedure #6 ##car> options)
                                   keyword))
                             (skip2next-keyword
                              ('#<procedure #7 ##cdr> options))
                             ('#<procedure #10 ##cons>
                              ('#<procedure #6 ##car> options)
                              (skip keyword ('#<procedure #7 ##cdr> options))))
                         '()))))
      (skip keyword options))))

(define skip2next-keyword
  (lambda (options)
    (if (or ('#<procedure #24 ##null?> options)
            (and ('#<procedure #4 ##pair?> options)
                 (let ((e ('#<procedure #6 ##car> options)))
                   (or ('#<procedure #59 ##keyword?> e)
                       (and ('#<procedure #16 ##symbol?> e)
                            ('#<procedure #60 ##char=?>
                             ('#<procedure #37 ##string-ref>
                              ('#<procedure #17 symbol->string> e)
                              0)
                             #\:))))))
        options
        (skip2next-keyword ('#<procedure #7 ##cdr> options)))))

(define look4keyword
  (lambda (keyword options)
    (if ('#<procedure #4 ##pair?> options)
        (if (meroon-keyword-eq? ('#<procedure #6 ##car> options) keyword)
            options
            (let ((options (skip2next-keyword
                            ('#<procedure #7 ##cdr> options))))
              (if ('#<procedure #4 ##pair?> options)
                  (if (meroon-keyword-eq?
                       ('#<procedure #6 ##car> options)
                       keyword)
                      options
                      (look4keyword
                       keyword
                       (skip2next-keyword ('#<procedure #7 ##cdr> options))))
                  '())))
        '())))

(define meroon-option-not-there
  ('#<procedure #34 ##list> 'meroon-option-not-there))

(define option-not-there (lambda (kw) meroon-option-not-there))

(define absent-option?
  (lambda (e) ('#<procedure #3 ##eq?> e meroon-option-not-there)))

(define compute-offset
  (lambda (o field)
    (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
      (let ((limit ('#<procedure #39 ##fx-> path-length 1)))
        (letrec ((compute (lambda (o field limit offset index)
                            (let ((n ('#<procedure #21 ##fx+>
                                      offset
                                      (let ((offset ('#<procedure #21 ##fx+>
                                                     5
                                                     ('#<procedure #21 ##fx+>
                                                      1
                                                      index))))
                                        (let ((i ('#<procedure #21 ##fx+>
                                                  1
                                                  offset)))
                                          ('#<procedure #32 ##vector-ref>
                                           field
                                           i))))))
                              (if ('#<procedure #50 ##fx=> index limit)
                                  n
                                  (let ((index ('#<procedure #21 ##fx+>
                                                index
                                                1))
                                        (offset ('#<procedure #21 ##fx+>
                                                 n
                                                 ('#<procedure #21 ##fx+>
                                                  1
                                                  (let ((i ('#<procedure #21 ##fx+>
                                                            1
                                                            n)))
                                                    ('#<procedure #32 ##vector-ref>
                                                     o
                                                     i))))))
                                    (let ((n ('#<procedure #21 ##fx+>
                                              offset
                                              (let ((offset ('#<procedure #21 ##fx+>
                                                             5
                                                             ('#<procedure #21 ##fx+>
                                                              1
                                                              index))))
                                                (let ((i ('#<procedure #21 ##fx+>
                                                          1
                                                          offset)))
                                                  ('#<procedure #32 ##vector-ref>
                                                   field
                                                   i))))))
                                      (if ('#<procedure #50 ##fx=> index limit)
                                          n
                                          (compute o
                                                   field
                                                   limit
                                                   ('#<procedure #21 ##fx+>
                                                    n
                                                    ('#<procedure #21 ##fx+>
                                                     1
                                                     (let ((i ('#<procedure #21 ##fx+>
                                                               1
                                                               n)))
                                                       ('#<procedure #32 ##vector-ref>
                                                        o
                                                        i))))
                                                   ('#<procedure #21 ##fx+>
                                                    index
                                                    1))))))))))
          (compute o field limit 0 0))))))

(define compute-value-offset
  (lambda (o field . index)
    (if (Mono-Field? field)
        (Mono-Field-compute-value-offset o field index)
        (if (Poly-Field? field)
            (Poly-Field-compute-value-offset o field index)
            (if (Virtual-Field? field)
                (Virtual-Field-compute-value-offset o field index)
                (if ('#<procedure #16 ##symbol?> field)
                    (let ((begin-temp.74
                           (if ('#<procedure #28 ##meroon?> o)
                               #!void
                               (report-meroon-error
                                'Access
                                'compute-value-offset
                                "Not an Object"
                                o))))
                      (let ((field (retrieve-named-field
                                    ('#<procedure #32 ##vector-ref>
                                     *classes*
                                     ('#<procedure #32 ##vector-ref> o 0))
                                    field)))
                        (if ('#<procedure #4 ##pair?> index)
                            (compute-value-offset
                             o
                             field
                             ('#<procedure #6 ##car> index))
                            (compute-value-offset o field))))
                    (internal-meroon-error o field index)))))))

(set! compute-value-offset compute-value-offset)

'compute-value-offset

(define Mono-Field-compute-value-offset
  (lambda (o field index)
    (let ((begin-temp.75
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((offset (compute-offset o field))) offset))))

(define Poly-Field-compute-value-offset
  (lambda (o field index)
    (let ((begin-temp.77
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((index (if ('#<procedure #4 ##pair?> index)
                       ('#<procedure #6 ##car> index)
                       (report-missing-index field o))))
        (let ((offset (compute-offset o field)))
          (let ((begin-temp.76 (check-index index o offset field)))
            ('#<procedure #21 ##fx+>
             offset
             ('#<procedure #21 ##fx+> 1 index))))))))

(define Virtual-Field-compute-value-offset
  (lambda (o field index)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((class ('#<procedure #32 ##vector-ref>
                      *classes*
                      ('#<procedure #32 ##vector-ref> o 0))))
          (let ((new-field (resolve-virtual-field field class)))
            (if new-field
                (if index
                    ('#<procedure #8 apply>
                     compute-value-offset
                     o
                     new-field
                     index)
                    (compute-value-offset o new-field))
                (report-meroon-error 'Access "Inappropriate view" o))))
        (report-meroon-error
         'Domain
         'compute-value-offset
         "Inappropriate class"
         Object-class
         o))))

(define field-value
  (lambda (o field . index)
    (if (Mono-Field? field)
        (Mono-Field-field-value o field index)
        (if (Poly-Field? field)
            (Poly-Field-field-value o field index)
            (if (Virtual-Field? field)
                (Virtual-Field-field-value o field index)
                (if ('#<procedure #16 ##symbol?> field)
                    (let ((begin-temp.78
                           (if ('#<procedure #28 ##meroon?> o)
                               #!void
                               (report-meroon-error
                                'Access
                                'field-value
                                "Not an Object"
                                o))))
                      (let ((field (retrieve-named-field
                                    ('#<procedure #32 ##vector-ref>
                                     *classes*
                                     ('#<procedure #32 ##vector-ref> o 0))
                                    field)))
                        (if ('#<procedure #4 ##pair?> index)
                            (field-value
                             o
                             field
                             ('#<procedure #6 ##car> index))
                            (field-value o field))))
                    (internal-meroon-error o field index)))))))

(set! field-value field-value)

'field-value

(define default-field-value internal-meroon-error)

(define Mono-Field-field-value
  (lambda (o field index)
    (let ((begin-temp.79
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((offset (compute-offset o field)))
        (let ((content (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                         ('#<procedure #32 ##vector-ref> o i))))
          (if ('#<procedure #3 ##eq?> meroon-uninitialized content)
              (report-uninitialized-field field o)
              content))))))

(define Poly-Field-field-value
  (lambda (o field index)
    (let ((begin-temp.81
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((index (if ('#<procedure #4 ##pair?> index)
                       ('#<procedure #6 ##car> index)
                       (report-missing-index field o))))
        (let ((offset (compute-offset o field)))
          (let ((begin-temp.80 (check-index index o offset field)))
            (let ((content (let ((offset ('#<procedure #21 ##fx+>
                                          offset
                                          ('#<procedure #21 ##fx+> 1 index))))
                             (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                               ('#<procedure #32 ##vector-ref> o i)))))
              (if ('#<procedure #3 ##eq?> meroon-uninitialized content)
                  (report-uninitialized-field field o index)
                  content))))))))

(define Virtual-Field-field-value
  (lambda (o field index)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((class ('#<procedure #32 ##vector-ref>
                      *classes*
                      ('#<procedure #32 ##vector-ref> o 0))))
          (let ((new-field (resolve-virtual-field field class)))
            (if new-field
                (if index
                    ('#<procedure #8 apply> field-value o new-field index)
                    (field-value o new-field))
                (report-meroon-error 'Access "Inappropriate view" o))))
        (report-meroon-error
         'Domain
         'field-value
         "Inappropriate class"
         Object-class
         o))))

(define set-field-value!
  (lambda (o value field . index)
    (if (Mono-Field? field)
        (Mono-Field-set-field-value! o value field index)
        (if (Poly-Field? field)
            (Poly-Field-set-field-value! o value field index)
            (if (Virtual-Field? field)
                (Virtual-Field-set-field-value! o value field index)
                (if ('#<procedure #16 ##symbol?> field)
                    (let ((begin-temp.82
                           (if ('#<procedure #28 ##meroon?> o)
                               #!void
                               (report-meroon-error
                                'Access
                                'set-field-value!
                                "Not an Object"
                                o))))
                      (let ((field (retrieve-named-field
                                    ('#<procedure #32 ##vector-ref>
                                     *classes*
                                     ('#<procedure #32 ##vector-ref> o 0))
                                    field)))
                        (if ('#<procedure #4 ##pair?> index)
                            (set-field-value!
                             o
                             value
                             field
                             ('#<procedure #6 ##car> index))
                            (set-field-value! o value field))))
                    (internal-meroon-error o value field index)))))))

(set! set-field-value! set-field-value!)

'set-field-value!

(define default-set-field-value! internal-meroon-error)

(define Mono-Field-set-field-value!
  (lambda (o value field index)
    (let ((begin-temp.83
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((offset (compute-offset o field)))
        (if ('#<procedure #32 ##vector-ref> field 2)
            (report-immutable-field field o)
            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
              ('#<procedure #33 ##vector-set!> o i value)))))))

(define Poly-Field-set-field-value!
  (lambda (o value field index)
    (let ((begin-temp.85
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((index (if ('#<procedure #4 ##pair?> index)
                       ('#<procedure #6 ##car> index)
                       (report-missing-index field o))))
        (if ('#<procedure #32 ##vector-ref> field 2)
            (report-immutable-field field o index)
            (let ((offset (compute-offset o field)))
              (let ((begin-temp.84 (check-index index o offset field)))
                (let ((offset ('#<procedure #21 ##fx+>
                               offset
                               ('#<procedure #21 ##fx+> 1 index))))
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #33 ##vector-set!> o i value))))))))))

(define Virtual-Field-set-field-value!
  (lambda (o value field index)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((class ('#<procedure #32 ##vector-ref>
                      *classes*
                      ('#<procedure #32 ##vector-ref> o 0))))
          (let ((new-field (resolve-virtual-field field class)))
            (if new-field
                (if index
                    ('#<procedure #8 apply>
                     set-field-value!
                     o
                     value
                     new-field
                     index)
                    (set-field-value! o value new-field))
                (report-meroon-error 'Access "Inappropriate view" o))))
        (report-meroon-error
         'Domain
         'set-field-value!
         "Inappropriate class"
         Object-class
         o))))

(define initialize-field-value!
  (lambda (o value field . index)
    (if (Mono-Field? field)
        (Mono-Field-initialize-field-value! o value field index)
        (if (Poly-Field? field)
            (Poly-Field-initialize-field-value! o value field index)
            (if (Virtual-Field? field)
                (Virtual-Field-initialize-field-value! o value field index)
                (if ('#<procedure #16 ##symbol?> field)
                    (let ((begin-temp.86
                           (if ('#<procedure #28 ##meroon?> o)
                               #!void
                               (report-meroon-error
                                'Access
                                'initialize-field-value!
                                "Not an Object"
                                o))))
                      (let ((field (retrieve-named-field
                                    ('#<procedure #32 ##vector-ref>
                                     *classes*
                                     ('#<procedure #32 ##vector-ref> o 0))
                                    field)))
                        (if ('#<procedure #4 ##pair?> index)
                            (initialize-field-value!
                             o
                             value
                             field
                             ('#<procedure #6 ##car> index))
                            (initialize-field-value! o value field))))
                    (internal-meroon-error o value field index)))))))

(set! initialize-field-value! initialize-field-value!)

'initialize-field-value!

(define default-initialize-field-value! internal-meroon-error)

(define Mono-Field-initialize-field-value!
  (lambda (o value field index)
    (let ((begin-temp.87
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((offset (compute-offset o field)))
        (let ((content (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                         ('#<procedure #32 ##vector-ref> o i))))
          (if ('#<procedure #3 ##eq?> meroon-uninitialized content)
              (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                ('#<procedure #33 ##vector-set!> o i value))
              (report-already-initialized field o value)))))))

(define Poly-Field-initialize-field-value!
  (lambda (o value field index)
    (let ((begin-temp.89
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((index (if ('#<procedure #4 ##pair?> index)
                       ('#<procedure #6 ##car> index)
                       (report-missing-index field o))))
        (let ((offset (compute-offset o field)))
          (let ((begin-temp.88 (check-index index o offset field)))
            (let ((content (let ((offset ('#<procedure #21 ##fx+>
                                          offset
                                          ('#<procedure #21 ##fx+> 1 index))))
                             (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                               ('#<procedure #32 ##vector-ref> o i)))))
              (if ('#<procedure #3 ##eq?> meroon-uninitialized content)
                  (let ((offset ('#<procedure #21 ##fx+>
                                 offset
                                 ('#<procedure #21 ##fx+> 1 index))))
                    (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                      ('#<procedure #33 ##vector-set!> o i value)))
                  (report-already-initialized field o value index)))))))))

(define Virtual-Field-initialize-field-value!
  (lambda (o value field index)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((class ('#<procedure #32 ##vector-ref>
                      *classes*
                      ('#<procedure #32 ##vector-ref> o 0))))
          (let ((new-field (resolve-virtual-field field class)))
            (if new-field
                (if index
                    ('#<procedure #8 apply>
                     initialize-field-value!
                     o
                     value
                     new-field
                     index)
                    (initialize-field-value! o value new-field))
                (report-meroon-error 'Access "Inappropriate view" o))))
        (report-meroon-error
         'Domain
         'initialize-field-value!
         "Inappropriate class"
         Object-class
         o))))

(define field-defined?
  (lambda (o field . index)
    (if (Mono-Field? field)
        (Mono-Field-field-defined? o field index)
        (if (Poly-Field? field)
            (Poly-Field-field-defined? o field index)
            (if (Virtual-Field? field)
                (Virtual-Field-field-defined? o field index)
                (if ('#<procedure #16 ##symbol?> field)
                    (let ((begin-temp.90
                           (if ('#<procedure #28 ##meroon?> o)
                               #!void
                               (report-meroon-error
                                'Access
                                'field-defined?
                                "Not an Object"
                                o))))
                      (let ((field (retrieve-named-field
                                    ('#<procedure #32 ##vector-ref>
                                     *classes*
                                     ('#<procedure #32 ##vector-ref> o 0))
                                    field)))
                        (if ('#<procedure #4 ##pair?> index)
                            (field-defined?
                             o
                             field
                             ('#<procedure #6 ##car> index))
                            (field-defined? o field))))
                    (internal-meroon-error o field index)))))))

(set! field-defined? field-defined?)

'field-defined?

(define default-field-defined? internal-meroon-error)

(define Mono-Field-field-defined?
  (lambda (o field index)
    (let ((begin-temp.91
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((offset (compute-offset o field)))
        ('#<procedure #5 ##not>
         (let ((value (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                        ('#<procedure #32 ##vector-ref> o i))))
           ('#<procedure #3 ##eq?> meroon-uninitialized value)))))))

(define Poly-Field-field-defined?
  (lambda (o field index)
    (let ((begin-temp.93
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((index (if ('#<procedure #4 ##pair?> index)
                       ('#<procedure #6 ##car> index)
                       (report-missing-index field o))))
        (let ((offset (compute-offset o field)))
          (let ((begin-temp.92 (check-index index o offset field)))
            ('#<procedure #5 ##not>
             (let ((value (let ((offset ('#<procedure #21 ##fx+>
                                         offset
                                         ('#<procedure #21 ##fx+> 1 index))))
                            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                              ('#<procedure #32 ##vector-ref> o i)))))
               ('#<procedure #3 ##eq?> meroon-uninitialized value)))))))))

(define Virtual-Field-field-defined?
  (lambda (o field index)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((class ('#<procedure #32 ##vector-ref>
                      *classes*
                      ('#<procedure #32 ##vector-ref> o 0))))
          (let ((new-field (resolve-virtual-field field class)))
            (if new-field
                (if index
                    ('#<procedure #8 apply> field-defined? o new-field index)
                    (field-defined? o new-field))
                (report-meroon-error 'Access "Inappropriate view" o))))
        (report-meroon-error
         'Domain
         'field-defined?
         "Inappropriate class"
         Object-class
         o))))

(define field-length
  (lambda (o field)
    (if (Poly-Field? field)
        (Poly-Field-field-length o field)
        (if (Mono-Field? field)
            (report-meroon-error 'Access field "Non indexed field" o field)
            (if (Virtual-Field? field)
                (Virtual-Field-field-length o field)
                (if ('#<procedure #16 ##symbol?> field)
                    (let ((begin-temp.94
                           (if ('#<procedure #28 ##meroon?> o)
                               #!void
                               (report-meroon-error
                                'Access
                                'field-length
                                "Not an Object"
                                o))))
                      (field-length
                       o
                       (retrieve-named-field
                        ('#<procedure #32 ##vector-ref>
                         *classes*
                         ('#<procedure #32 ##vector-ref> o 0))
                        field)))
                    (internal-meroon-error o field)))))))

(set! field-length field-length)

'field-length

(define default-field-length internal-meroon-error)

(define Poly-Field-field-length
  (lambda (o field)
    (let ((begin-temp.95
           (let ((class (let ((i ('#<procedure #32 ##vector-ref> field 3)))
                          ('#<procedure #32 ##vector-ref> *classes* i))))
             (if ('#<procedure #28 ##meroon?> o)
                 (let ((oc ('#<procedure #32 ##vector-ref>
                            *classes*
                            ('#<procedure #32 ##vector-ref> o 0))))
                   (if (careless-subclass? oc class)
                       #f
                       (report-meroon-error
                        'Domain
                        field
                        "Inappropriate class"
                        class
                        o)))
                 (report-meroon-error
                  'Domain
                  field
                  "Inappropriate class"
                  class
                  o)))))
      (let ((offset (compute-offset o field)))
        (let ((i ('#<procedure #21 ##fx+> 1 offset)))
          ('#<procedure #32 ##vector-ref> o i))))))

(define Mono-Field-field-length
  (lambda (o field)
    (report-meroon-error 'Access field "Non indexed field" o field)))

(define Virtual-Field-field-length
  (lambda (o field)
    (if ('#<procedure #28 ##meroon?> o)
        (let ((class ('#<procedure #32 ##vector-ref>
                      *classes*
                      ('#<procedure #32 ##vector-ref> o 0))))
          (let ((new-field (resolve-virtual-field field class)))
            (if new-field
                (field-length o new-field)
                (report-meroon-error 'Access "Inappropriate view" o))))
        (report-meroon-error
         'Domain
         'field-length
         "Inappropriate class"
         Object-class
         o))))

(define Class-super-class
  (lambda (class)
    (if (Class? class)
        (let ((i (Class-super-number class)))
          ('#<procedure #32 ##vector-ref> *classes* i))
        (report-meroon-error 'Domain 'Class-super-class "Not a class" class))))

(define Class-subclasses
  (lambda (class)
    (if (Class? class)
        (let ((temp.939 (Class-subclass-numbers class)))
          (letrec ((loop2.940
                    (lambda (lst2.941)
                      (if ('#<procedure #4 ##pair?> lst2.941)
                          (let ((x.942 (let ((i ('#<procedure #6 ##car>
                                                 lst2.941)))
                                         ('#<procedure #32 ##vector-ref>
                                          *classes*
                                          i))))
                            ('#<procedure #10 ##cons>
                             x.942
                             (loop2.940 ('#<procedure #7 ##cdr> lst2.941))))
                          '()))))
            (loop2.940 temp.939)))
        (report-meroon-error 'Domain 'Class-subclasses "Not a class" class))))

(define Field-defining-class
  (lambda (field)
    (if (Field? field)
        (let ((i (Field-class-number field)))
          ('#<procedure #32 ##vector-ref> *classes* i))
        (report-meroon-error
         'Domain
         'Field-defining-class
         "Not a field"
         field))))

(define retrieve-named-field
  (lambda (class name . default)
    (letrec ((look (lambda (class name default fields)
                     (if ('#<procedure #4 ##pair?> fields)
                         (if ('#<procedure #3 ##eq?>
                              name
                              (let ((field ('#<procedure #6 ##car> fields)))
                                ('#<procedure #32 ##vector-ref> field 1)))
                             ('#<procedure #6 ##car> fields)
                             (look class
                                   name
                                   default
                                   ('#<procedure #7 ##cdr> fields)))
                         (if ('#<procedure #4 ##pair?> default)
                             (('#<procedure #6 ##car> default) class name)
                             (report-meroon-error
                              'Domain
                              'field-value
                              "Not coercible to a Field"
                              name
                              class))))))
      (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
        (if ('#<procedure #4 ##pair?> fields)
            (if ('#<procedure #3 ##eq?>
                 name
                 (let ((field ('#<procedure #6 ##car> fields)))
                   ('#<procedure #32 ##vector-ref> field 1)))
                ('#<procedure #6 ##car> fields)
                (look class name default ('#<procedure #7 ##cdr> fields)))
            (if ('#<procedure #4 ##pair?> default)
                (('#<procedure #6 ##car> default) class name)
                (report-meroon-error
                 'Domain
                 'field-value
                 "Not coercible to a Field"
                 name
                 class)))))))

(define report-bad-coercion-to-field
  (lambda (class o)
    (report-meroon-error
     'Domain
     'field-value
     "Not coercible to a Field"
     o
     class)))

(define Field-mutable?
  (lambda (field) ('#<procedure #5 ##not> (Field-immutable? field))))

(define set-important-offsets!
  (lambda (field preceding-fields)
    (let ((begin-temp.96
           (if ('#<procedure #4 ##pair?> preceding-fields)
               (let ((last-field
                      ('#<procedure #6 ##car> (last-pair preceding-fields))))
                 (Field-generate-next-offset! field last-field))
               (initialize-field-value! field 0 'path 0))))
      field)))

(define Field-generate-next-offset!
  (lambda (field last-field)
    (if (Mono-Field? last-field)
        (Mono-Field-generate-next-offset! field last-field)
        (if (Poly-Field? last-field)
            (Poly-Field-generate-next-offset! field last-field)
            (report-meroon-error
             'internal
             'Field-generate-next-offset!
             "Unknown type of field"
             last-field)))))

(set! Field-generate-next-offset! Field-generate-next-offset!)

'Field-generate-next-offset!

(define Mono-Field-generate-next-offset!
  (lambda (field last-field)
    (let ((path-length (Field-path-length last-field)))
      (letrec ((fill (lambda (field last-field path-length i)
                       (if ('#<procedure #20 ##fx<>
                            i
                            ('#<procedure #39 ##fx-> path-length 1))
                           (let ((begin-temp.97
                                  (initialize-field-value!
                                   field
                                   (Field-path last-field i)
                                   'path
                                   i)))
                             (fill field
                                   last-field
                                   path-length
                                   ('#<procedure #21 ##fx+> i 1)))
                           (initialize-field-value!
                            field
                            ('#<procedure #21 ##fx+>
                             (Field-path last-field i)
                             1)
                            'path
                            i)))))
        (fill field last-field path-length 0)))))

(define Poly-Field-generate-next-offset!
  (lambda (field last-field)
    (let ((path-length (Field-path-length last-field)))
      (letrec ((fill (lambda (field last-field path-length i)
                       (if ('#<procedure #20 ##fx<> i path-length)
                           (let ((begin-temp.98
                                  (initialize-field-value!
                                   field
                                   (Field-path last-field i)
                                   'path
                                   i)))
                             (fill field
                                   last-field
                                   path-length
                                   ('#<procedure #21 ##fx+> i 1)))
                           (initialize-field-value! field 0 'path i)))))
        (fill field last-field path-length 0)))))

(define count-Poly-Fields
  (lambda (fields)
    (letrec ((count (lambda (fields)
                      (if ('#<procedure #4 ##pair?> fields)
                          (if (Poly-Field? ('#<procedure #6 ##car> fields))
                              ('#<procedure #21 ##fx+>
                               1
                               (count ('#<procedure #7 ##cdr> fields)))
                              (count ('#<procedure #7 ##cdr> fields)))
                          0))))
      (count fields))))

(define Mono-Field-create-careful-reader
  (lambda (class fieldname)
    (let ((field (retrieve-named-field class fieldname)))
      (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
        (if ('#<procedure #3 ##eq?> path-length 1)
            (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
              (lambda (o)
                (let ((begin-temp.100 (check-class o class fieldname)))
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #32 ##vector-ref> o i)))))
            (if ('#<procedure #3 ##eq?> path-length 2)
                (let ((offset1 ('#<procedure #32 ##vector-ref> field 7)))
                  (let ((offset2 ('#<procedure #32 ##vector-ref> field 8)))
                    (let ((offset ('#<procedure #21 ##fx+>
                                   offset1
                                   ('#<procedure #21 ##fx+> 1 offset2))))
                      (lambda (o)
                        (let ((begin-temp.101 (check-class o class fieldname)))
                          (let ((offset ('#<procedure #21 ##fx+>
                                         offset
                                         (let ((i ('#<procedure #21 ##fx+>
                                                   1
                                                   offset1)))
                                           ('#<procedure #32 ##vector-ref>
                                            o
                                            i)))))
                            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                              ('#<procedure #32 ##vector-ref> o i))))))))
                (lambda (o) (field-value o field))))))))

(define Mono-Field-create-careful-writer
  (lambda (class fieldname)
    (let ((field (retrieve-named-field class fieldname)))
      (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
        (if ('#<procedure #3 ##eq?> path-length 1)
            (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
              (lambda (o v)
                (let ((begin-temp.103 (check-class o class fieldname)))
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #33 ##vector-set!> o i v)))))
            (if ('#<procedure #3 ##eq?> path-length 2)
                (let ((offset1 ('#<procedure #32 ##vector-ref> field 7)))
                  (let ((offset2 ('#<procedure #32 ##vector-ref> field 8)))
                    (let ((offset ('#<procedure #21 ##fx+>
                                   offset1
                                   ('#<procedure #21 ##fx+> 1 offset2))))
                      (lambda (o v)
                        (let ((begin-temp.104 (check-class o class fieldname)))
                          (let ((offset ('#<procedure #21 ##fx+>
                                         offset
                                         (let ((i ('#<procedure #21 ##fx+>
                                                   1
                                                   offset1)))
                                           ('#<procedure #32 ##vector-ref>
                                            o
                                            i)))))
                            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                              ('#<procedure #33 ##vector-set!> o i v))))))))
                (lambda (o v) (set-field-value! o v field))))))))

(define Poly-Field-create-careful-lengther
  (lambda (class fieldname)
    (let ((field (retrieve-named-field class fieldname)))
      (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
        (if ('#<procedure #3 ##eq?> path-length 1)
            (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
              (lambda (o)
                (let ((begin-temp.106 (check-class o class fieldname)))
                  (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                    ('#<procedure #32 ##vector-ref> o i)))))
            (if ('#<procedure #3 ##eq?> path-length 2)
                (let ((offset1 ('#<procedure #32 ##vector-ref> field 7)))
                  (let ((offset2 ('#<procedure #32 ##vector-ref> field 8)))
                    (let ((offset ('#<procedure #21 ##fx+>
                                   offset1
                                   ('#<procedure #21 ##fx+> 1 offset2))))
                      (lambda (o)
                        (let ((begin-temp.107 (check-class o class fieldname)))
                          (let ((offset ('#<procedure #21 ##fx+>
                                         offset
                                         (let ((i ('#<procedure #21 ##fx+>
                                                   1
                                                   offset1)))
                                           ('#<procedure #32 ##vector-ref>
                                            o
                                            i)))))
                            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                              ('#<procedure #32 ##vector-ref> o i))))))))
                (lambda (o) (field-length o field))))))))

(define Poly-Field-create-careful-reader
  (lambda (class fieldname)
    (let ((field (retrieve-named-field class fieldname)))
      (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
        (if ('#<procedure #3 ##eq?> path-length 1)
            (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
              (let ((offset+1 ('#<procedure #21 ##fx+> offset 1)))
                (lambda (o i)
                  (let ((begin-temp.110 (check-class o class fieldname)))
                    (let ((begin-temp.109 (check-index i o offset fieldname)))
                      (let ((offset ('#<procedure #21 ##fx+> offset+1 i)))
                        (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                          ('#<procedure #32 ##vector-ref> o i))))))))
            (lambda (o i) (field-value o field i)))))))

(define Poly-Field-create-careful-writer
  (lambda (class fieldname)
    (let ((field (retrieve-named-field class fieldname)))
      (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
        (if ('#<procedure #3 ##eq?> path-length 1)
            (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
              (let ((offset+1 ('#<procedure #21 ##fx+> offset 1)))
                (lambda (o i v)
                  (let ((begin-temp.113 (check-class o class fieldname)))
                    (let ((begin-temp.112 (check-index i o offset fieldname)))
                      (let ((offset ('#<procedure #21 ##fx+> offset+1 i)))
                        (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                          ('#<procedure #33 ##vector-set!> o i v))))))))
            (lambda (o i v) (set-field-value! o v field i)))))))

(define generate-fast-careful-reader
  (lambda (field class-variable)
    ((if (Mono-Field? field)
         Mono-Field-generate-fast-careful-reader
         (if (Poly-Field? field)
             Poly-Field-generate-fast-careful-reader
             internal-meroon-error))
     field
     class-variable)))

(set! generate-fast-careful-reader generate-fast-careful-reader)

'generate-fast-careful-reader

(define default-generate-fast-careful-reader internal-meroon-error)

(define Mono-Field-generate-fast-careful-reader
  (lambda (field class-variable)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((offset ('#<procedure #32 ##vector-ref> field 7)) (o (gensym)))
            ('#<procedure #44 ##quasi-list>
             'lambda
             ('#<procedure #44 ##quasi-list> o)
             ('#<procedure #44 ##quasi-list>
              'check-class
              o
              class-variable
              ('#<procedure #44 ##quasi-list> 'quote fieldname))
             ('#<procedure #44 ##quasi-list> 'instance-ref o offset)))
          (if ('#<procedure #3 ##eq?> path-length 2)
              (let ((o (gensym)))
                (let ((offset1 ('#<procedure #32 ##vector-ref> field 7)))
                  (let ((offset2 ('#<procedure #32 ##vector-ref> field 8)))
                    (let ((offset ('#<procedure #21 ##fx+>
                                   offset1
                                   ('#<procedure #21 ##fx+> 1 offset2))))
                      ('#<procedure #44 ##quasi-list>
                       'lambda
                       ('#<procedure #44 ##quasi-list> o)
                       ('#<procedure #44 ##quasi-list>
                        'check-class
                        o
                        class-variable
                        ('#<procedure #44 ##quasi-list> 'quote fieldname))
                       ('#<procedure #44 ##quasi-list>
                        'instance-ref
                        o
                        ('#<procedure #44 ##quasi-list>
                         'fx+
                         offset
                         ('#<procedure #44 ##quasi-list>
                          'instance-ref
                          o
                          offset1))))))))
              ('#<procedure #44 ##quasi-list>
               'Mono-Field-create-careful-reader
               class-variable
               ('#<procedure #44 ##quasi-list> 'quote fieldname)))))))

(define Poly-Field-generate-fast-careful-reader
  (lambda (field class-variable)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((o (gensym)))
            (let ((i (gensym)))
              (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
                (let ((offset+1 ('#<procedure #21 ##fx+> offset 1)))
                  ('#<procedure #44 ##quasi-list>
                   'lambda
                   ('#<procedure #44 ##quasi-list> o i)
                   ('#<procedure #44 ##quasi-list>
                    'check-class
                    o
                    class-variable
                    ('#<procedure #44 ##quasi-list> 'quote fieldname))
                   ('#<procedure #44 ##quasi-list>
                    'check-index
                    i
                    o
                    offset
                    ('#<procedure #44 ##quasi-list> 'quote fieldname))
                   ('#<procedure #44 ##quasi-list>
                    'instance-ref
                    o
                    ('#<procedure #44 ##quasi-list> 'fx+ offset+1 i)))))))
          ('#<procedure #44 ##quasi-list>
           'Poly-Field-create-careful-reader
           class-variable
           ('#<procedure #44 ##quasi-list> 'quote fieldname))))))

(define generate-fast-careful-lengther
  (lambda (field class-variable)
    ((if (Poly-Field? field)
         Poly-Field-generate-fast-careful-lengther
         internal-meroon-error)
     field
     class-variable)))

(set! generate-fast-careful-lengther generate-fast-careful-lengther)

'generate-fast-careful-lengther

(define default-generate-fast-careful-lengther internal-meroon-error)

(define Poly-Field-generate-fast-careful-lengther
  (lambda (field class-variable)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((o (gensym)))
            (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
              ('#<procedure #44 ##quasi-list>
               'lambda
               ('#<procedure #44 ##quasi-list> o)
               ('#<procedure #44 ##quasi-list>
                'check-class
                o
                class-variable
                ('#<procedure #44 ##quasi-list> 'quote fieldname))
               ('#<procedure #44 ##quasi-list> 'instance-ref o offset))))
          ('#<procedure #44 ##quasi-list>
           'Poly-Field-create-careful-lengther
           class-variable
           ('#<procedure #44 ##quasi-list> 'quote fieldname))))))

(define generate-fast-careful-writer
  (lambda (field class-variable)
    ((if (Mono-Field? field)
         Mono-Field-generate-fast-careful-writer
         (if (Poly-Field? field)
             Poly-Field-generate-fast-careful-writer
             internal-meroon-error))
     field
     class-variable)))

(set! generate-fast-careful-writer generate-fast-careful-writer)

'generate-fast-careful-writer

(define default-generate-fast-careful-writer internal-meroon-error)

(define Mono-Field-generate-fast-careful-writer
  (lambda (field class-variable)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((offset ('#<procedure #32 ##vector-ref> field 7))
                (v (gensym))
                (o (gensym)))
            ('#<procedure #44 ##quasi-list>
             'lambda
             ('#<procedure #44 ##quasi-list> o v)
             ('#<procedure #44 ##quasi-list>
              'check-class
              o
              class-variable
              ('#<procedure #44 ##quasi-list> 'quote fieldname))
             ('#<procedure #44 ##quasi-list> 'instance-set! o offset v)))
          (if ('#<procedure #3 ##eq?> path-length 2)
              (let ((o (gensym)))
                (let ((v (gensym)))
                  (let ((offset1 ('#<procedure #32 ##vector-ref> field 7)))
                    (let ((offset2 ('#<procedure #32 ##vector-ref> field 8)))
                      (let ((offset ('#<procedure #21 ##fx+>
                                     offset1
                                     ('#<procedure #21 ##fx+> 1 offset2))))
                        ('#<procedure #44 ##quasi-list>
                         'lambda
                         ('#<procedure #44 ##quasi-list> o v)
                         ('#<procedure #44 ##quasi-list>
                          'check-class
                          o
                          class-variable
                          ('#<procedure #44 ##quasi-list> 'quote fieldname))
                         ('#<procedure #44 ##quasi-list>
                          'instance-set!
                          o
                          ('#<procedure #44 ##quasi-list>
                           'fx+
                           offset
                           ('#<procedure #44 ##quasi-list>
                            'instance-ref
                            o
                            offset1))
                          v)))))))
              ('#<procedure #44 ##quasi-list>
               'Mono-Field-create-careful-writer
               class-variable
               ('#<procedure #44 ##quasi-list> 'quote fieldname)))))))

(define Poly-Field-generate-fast-careful-writer
  (lambda (field class-variable)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((o (gensym)))
            (let ((i (gensym)))
              (let ((v (gensym)))
                (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
                  (let ((offset+1 ('#<procedure #21 ##fx+> offset 1)))
                    ('#<procedure #44 ##quasi-list>
                     'lambda
                     ('#<procedure #44 ##quasi-list> o i v)
                     ('#<procedure #44 ##quasi-list>
                      'check-class
                      o
                      class-variable
                      ('#<procedure #44 ##quasi-list> 'quote fieldname))
                     ('#<procedure #44 ##quasi-list>
                      'check-index
                      i
                      o
                      offset
                      ('#<procedure #44 ##quasi-list> 'quote fieldname))
                     ('#<procedure #44 ##quasi-list>
                      'instance-set!
                      o
                      ('#<procedure #44 ##quasi-list> 'fx+ offset+1 i)
                      v)))))))
          ('#<procedure #44 ##quasi-list>
           'Poly-Field-create-careful-writer
           class-variable
           ('#<procedure #44 ##quasi-list> 'quote fieldname))))))

(define generate-offset
  (lambda (ovar field fieldvar . indexvar)
    ((if (Mono-Field? field)
         Mono-Field-generate-offset
         (if (Poly-Field? field)
             Poly-Field-generate-offset
             internal-meroon-error))
     ovar
     field
     fieldvar
     (if ('#<procedure #4 ##pair?> indexvar)
         ('#<procedure #6 ##car> indexvar)
         'void))))

(set! generate-offset generate-offset)

'generate-offset

(define default-generate-offset internal-meroon-error)

(define Mono-Field-generate-offset
  (lambda (ovar field fieldvar indexvar)
    (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((offset ('#<procedure #32 ##vector-ref> field 7))) offset)
          (if ('#<procedure #3 ##eq?> path-length 2)
              (let ((offset ('#<procedure #32 ##vector-ref> field 8))
                    (indexed-offset ('#<procedure #32 ##vector-ref> field 7)))
                ('#<procedure #44 ##quasi-list>
                 'fx+
                 ('#<procedure #21 ##fx+>
                  indexed-offset
                  ('#<procedure #21 ##fx+> 1 offset))
                 ('#<procedure #44 ##quasi-list>
                  'instance-ref
                  ovar
                  indexed-offset)))
              ('#<procedure #44 ##quasi-list>
               'compute-offset
               ovar
               fieldvar))))))

(define Poly-Field-generate-offset
  (lambda (ovar field fieldvar indexvar)
    (let ((path-length ('#<procedure #32 ##vector-ref> field 6)))
      (if ('#<procedure #3 ##eq?> path-length 1)
          (let ((offset ('#<procedure #32 ##vector-ref> field 7)))
            ('#<procedure #44 ##quasi-list>
             'fx+
             ('#<procedure #21 ##fx+> offset 1)
             indexvar))
          ('#<procedure #44 ##quasi-list> 'compute-offset ovar fieldvar)))))

(define *dispatcher-max-depth* 3)

(define extend-classes-number!
  (lambda ()
    (let ((begin-temp.122 (set! *classes* (vector-extend *classes*))))
      (let ((v *generics*))
        (if ('#<procedure #24 ##null?> v)
            #f
            (if ('#<procedure #56 ##vector?> v)
                (let ((n ('#<procedure #29 ##vector-length> v)))
                  (letrec ((mapvector
                            (lambda (v n i)
                              (if ('#<procedure #20 ##fx<> i n)
                                  (let ((begin-temp.25
                                         (let ((g ('#<procedure #32 ##vector-ref>
                                                   v
                                                   i)))
                                           (if g
                                               (let ((d (enlarge-dispatcher!
                                                         ('#<procedure #32 ##vector-ref>
                                                          g
                                                          4))))
                                                 ('#<procedure #33 ##vector-set!>
                                                  g
                                                  4
                                                  d))
                                               #!void))))
                                    (let ((i ('#<procedure #21 ##fx+> 1 i)))
                                      (if ('#<procedure #20 ##fx<> i n)
                                          (let ((begin-temp.25
                                                 (let ((g ('#<procedure #32 ##vector-ref>
                                                           v
                                                           i)))
                                                   (if g
                                                       (let ((d (enlarge-dispatcher!
                                                                 ('#<procedure #32 ##vector-ref>
                                                                  g
                                                                  4))))
                                                         ('#<procedure #33 ##vector-set!>
                                                          g
                                                          4
                                                          d))
                                                       #!void))))
                                            (mapvector
                                             v
                                             n
                                             ('#<procedure #21 ##fx+> 1 i)))
                                          #!void)))
                                  #!void))))
                    (mapvector v n 0)))
                (if ('#<procedure #4 ##pair?> v)
                    (letrec ((loop2.925
                              (lambda (lst2.926)
                                (if ('#<procedure #4 ##pair?> lst2.926)
                                    (let ((x.927 (let ((g ('#<procedure #6 ##car>
                                                           lst2.926)))
                                                   (if g
                                                       (let ((d (enlarge-dispatcher!
                                                                 ('#<procedure #32 ##vector-ref>
                                                                  g
                                                                  4))))
                                                         ('#<procedure #33 ##vector-set!>
                                                          g
                                                          4
                                                          d))
                                                       #!void))))
                                      (let ((lst2.926
                                             ('#<procedure #7 ##cdr>
                                              lst2.926)))
                                        (if ('#<procedure #4 ##pair?> lst2.926)
                                            (let ((x.927 (let ((g ('#<procedure #6 ##car>
                                                                   lst2.926)))
                                                           (if g
                                                               (let ((d (enlarge-dispatcher!
                                                                         ('#<procedure #32 ##vector-ref>
                                                                          g
                                                                          4))))
                                                                 ('#<procedure #33 ##vector-set!>
                                                                  g
                                                                  4
                                                                  d))
                                                               #!void))))
                                              (loop2.925
                                               ('#<procedure #7 ##cdr>
                                                lst2.926)))
                                            #!void)))
                                    #!void))))
                      (loop2.925 v))
                    (oo-error 'sequence-map "Not a sequence" v))))))))

(define enlarge-dispatcher!
  (lambda (d)
    (if (Global-Dispatcher? d) (Global-Dispatcher-enlarge-dispatcher! d) d)))

(set! enlarge-dispatcher! enlarge-dispatcher!)

'enlarge-dispatcher!

(define Global-Dispatcher-enlarge-dispatcher!
  (lambda (d)
    (let ((size ('#<procedure #29 ##vector-length> *classes*)))
      (let ((oldn ('#<procedure #32 ##vector-ref> d 2)))
        (let ((newd ((Class-allocator Global-Dispatcher-class) size)))
          (let ((begin-temp.126
                 ('#<procedure #33 ##vector-set!>
                  newd
                  1
                  Global-Dispatcher-find-method)))
            (let ((begin-temp.125
                   (letrec ((do-temp.123
                             (lambda (d oldn newd i)
                               (if ('#<procedure #36 ##fx>=> i oldn)
                                   #!void
                                   (let ((begin-temp.124
                                          (let ((m (let ((offset ('#<procedure #21 ##fx+>
                                                                  2
                                                                  i)))
                                                     (let ((i ('#<procedure #21 ##fx+>
                                                               1
                                                               offset)))
                                                       ('#<procedure #32 ##vector-ref>
                                                        d
                                                        i)))))
                                            (let ((offset ('#<procedure #21 ##fx+>
                                                           2
                                                           i)))
                                              (let ((i ('#<procedure #21 ##fx+>
                                                        1
                                                        offset)))
                                                ('#<procedure #33 ##vector-set!>
                                                 newd
                                                 i
                                                 m))))))
                                     (do-temp.123
                                      d
                                      oldn
                                      newd
                                      ('#<procedure #21 ##fx+> i 1)))))))
                     (do-temp.123 d oldn newd 0))))
              newd)))))))

(define barfing-method
  (lambda arguments
    ('#<procedure #8 apply>
     report-meroon-error
     'Domain
     'barfing-method
     "Absent method"
     arguments)))

(define create-default-generic-method
  (lambda (generic)
    (lambda arguments
      ('#<procedure #8 apply>
       report-meroon-error
       'Domain
       generic
       "No method for"
       arguments))))

(define create-Indexed-Dispatcher
  (lambda (cn . no)
    (let ((cl ('#<procedure #32 ##vector-ref> *classes* cn)))
      (let ((no (if ('#<procedure #4 ##pair?> no)
                    ('#<procedure #6 ##car> no)
                    (make-Immediate-Dispatcher
                     Immediate-Dispatcher-find-method
                     #f))))
        (let ((sz ('#<procedure #32 ##vector-ref> cl 7)))
          (let ((size ('#<procedure #21 ##fx+>
                       sz
                       ('#<procedure #21 ##fx+>
                        1
                        ('#<procedure #55 ##fxquotient> sz 2)))))
            (let ((d ((Class-allocator Indexed-Dispatcher-class) size)))
              (let ((begin-temp.133
                     ('#<procedure #33 ##vector-set!>
                      d
                      1
                      Indexed-Dispatcher-find-method)))
                (let ((begin-temp.132
                       ('#<procedure #33 ##vector-set!> d 2 cn)))
                  (let ((begin-temp.131
                         (let ((cn ('#<procedure #32 ##vector-ref> cl 4)))
                           ('#<procedure #33 ##vector-set!> d 3 cn))))
                    (let ((begin-temp.130 (set-Indexed-Dispatcher-no! d no)))
                      (let ((begin-temp.129
                             (letrec ((do-temp.127
                                       (lambda (size d i)
                                         (if ('#<procedure #36 ##fx>=> i size)
                                             #!void
                                             (let ((begin-temp.128
                                                    (set-Indexed-Dispatcher-method!
                                                     d
                                                     i
                                                     barfing-method)))
                                               (let ((i ('#<procedure #21 ##fx+>
                                                         1
                                                         i)))
                                                 (if ('#<procedure #36 ##fx>=>
                                                      i
                                                      size)
                                                     #!void
                                                     (let ((begin-temp.128
                                                            (set-Indexed-Dispatcher-method!
                                                             d
                                                             i
                                                             barfing-method)))
                                                       (do-temp.127
                                                        size
                                                        d
                                                        ('#<procedure #21 ##fx+>
                                                         1
                                                         i))))))))))
                               (do-temp.127 size d 0))))
                        (initialize! d)))))))))))))

(define extend-Indexed-Dispatcher
  (lambda (d)
    (let ((newd (create-Indexed-Dispatcher
                 (Indexed-Dispatcher-class-number d)
                 (Indexed-Dispatcher-no d)))
          (old-size (Indexed-Dispatcher-method-length d)))
      (letrec ((do-temp.134
                (lambda (d newd old-size i)
                  (if ('#<procedure #50 ##fx=> i old-size)
                      newd
                      (let ((begin-temp.135
                             (set-Indexed-Dispatcher-method!
                              newd
                              i
                              (Indexed-Dispatcher-method d i))))
                        (do-temp.134
                         d
                         newd
                         old-size
                         ('#<procedure #21 ##fx+> 1 i)))))))
        (do-temp.134 d newd old-size 0)))))

(define create-Subclass-Dispatcher
  (lambda (cn no yes)
    (let ((cl ('#<procedure #32 ##vector-ref> *classes* cn)))
      (make-Subclass-Dispatcher
       Subclass-Dispatcher-find-method
       cn
       ('#<procedure #32 ##vector-ref> cl 4)
       no
       yes))))

(define register-Generic-1
  (lambda (rev name default-method signature top-class-name)
    (let ((begin-temp.147 (check-revision rev)))
      (let ((g (make-Generic-1
                name
                default-method
                signature
                meroon-uninitialized
                meroon-uninitialized)))
        (let ((begin-temp.146
               (if (field-defined? g 'default)
                   #!void
                   (let ((d (create-default-generic-method g)))
                     ('#<procedure #33 ##vector-set!> g 2 d)))))
          (let ((begin-temp.145
                 (let ((cs ('#<procedure #34 ##list>
                            (if top-class-name
                                (symbol->class
                                 top-class-name
                                 (lambda (name)
                                   (report-meroon-error
                                    'Syntax
                                    'define-generic
                                    "No such class"
                                    name)))
                                #f))))
                   ('#<procedure #33 ##vector-set!> g 5 cs))))
            (let ((begin-temp.144
                   (let ((d (let ((top-class
                                   ('#<procedure #6 ##car>
                                    ('#<procedure #32 ##vector-ref> g 5)))
                                  (defdispatcher
                                   (make-Immediate-Dispatcher
                                    Immediate-Dispatcher-find-method
                                    #f)))
                              (if (and (Class? top-class)
                                       ('#<procedure #5 ##not>
                                        ('#<procedure #3 ##eq?>
                                         top-class
                                         Object-class)))
                                  (create-Indexed-Dispatcher
                                   ('#<procedure #32 ##vector-ref> top-class 2)
                                   defdispatcher)
                                  defdispatcher))))
                     ('#<procedure #33 ##vector-set!> g 4 d))))
              (let ((begin-temp.143
                     (let ((d ('#<procedure #32 ##vector-ref> g 4)))
                       (let ((begin-temp.141
                              (if (Global-Dispatcher? d)
                                  (let ((default ('#<procedure #32 ##vector-ref>
                                                  g
                                                  2))
                                        (size (Global-Dispatcher-method-length
                                               d)))
                                    (letrec ((do-temp.137
                                              (lambda (d default size i)
                                                (if ('#<procedure #36 ##fx>=>
                                                     i
                                                     size)
                                                    #!void
                                                    (let ((begin-temp.138
                                                           (let ((offset ('#<procedure #21 ##fx+>
                                                                          2
                                                                          i)))
                                                             (let ((i ('#<procedure #21 ##fx+>
                                                                       1
                                                                       offset)))
                                                               ('#<procedure #33 ##vector-set!>
                                                                d
                                                                i
                                                                default)))))
                                                      (do-temp.137
                                                       d
                                                       default
                                                       size
                                                       ('#<procedure #21 ##fx+>
                                                        1
                                                        i)))))))
                                      (do-temp.137 d default size 0)))
                                  #!void)))
                         (if (Indexed-Dispatcher? d)
                             (let ((default ('#<procedure #32 ##vector-ref>
                                             g
                                             2))
                                   (size (Indexed-Dispatcher-method-length d)))
                               (letrec ((do-temp.139
                                         (lambda (d default size i)
                                           (if ('#<procedure #36 ##fx>=>
                                                i
                                                size)
                                               #!void
                                               (let ((begin-temp.140
                                                      (let ((offset ('#<procedure #21 ##fx+>
                                                                     5
                                                                     i)))
                                                        (let ((i ('#<procedure #21 ##fx+>
                                                                  1
                                                                  offset)))
                                                          ('#<procedure #33 ##vector-set!>
                                                           d
                                                           i
                                                           default)))))
                                                 (do-temp.139
                                                  d
                                                  default
                                                  size
                                                  ('#<procedure #21 ##fx+>
                                                   1
                                                   i)))))))
                                 (do-temp.139 d default size 0)))
                             #!void)))))
                (let ((begin-temp.142
                       (let ((i (or (look-generic (Generic-name g))
                                    (get-new-generic-number))))
                         ('#<procedure #33 ##vector-set!> *generics* i g))))
                  (initialize! (fill-other-fields! g)))))))))))

(define register-Generic-N
  (lambda (rev name default-method signature . top-class-names)
    (let ((begin-temp.152 (check-revision rev)))
      (let ((g (make-Generic-N
                name
                default-method
                signature
                meroon-uninitialized
                meroon-uninitialized)))
        (let ((begin-temp.151
               (if (field-defined? g 'default)
                   #!void
                   (let ((d (create-default-generic-method g)))
                     ('#<procedure #33 ##vector-set!> g 2 d)))))
          (let ((begin-temp.150
                 (let ((cs (let ((temp.943
                                  (lambda (name)
                                    (if name
                                        (symbol->class
                                         name
                                         (lambda (name)
                                           (report-meroon-error
                                            'Syntax
                                            'define-generic
                                            "No such class"
                                            name)))
                                        #f))))
                             (letrec ((loop2.945
                                       (lambda (lst2.946)
                                         (if ('#<procedure #4 ##pair?>
                                              lst2.946)
                                             (let ((x.947 (temp.943
                                                           ('#<procedure #6 ##car>
                                                            lst2.946))))
                                               ('#<procedure #10 ##cons>
                                                x.947
                                                (loop2.945
                                                 ('#<procedure #7 ##cdr>
                                                  lst2.946))))
                                             '()))))
                               (loop2.945 top-class-names)))))
                   ('#<procedure #33 ##vector-set!> g 5 cs))))
            (let ((begin-temp.149
                   (let ((d (make-Immediate-Dispatcher
                             Immediate-Dispatcher-find-multi-method
                             #f)))
                     ('#<procedure #33 ##vector-set!> g 4 d))))
              (let ((begin-temp.148
                     (let ((i (or (look-generic (Generic-name g))
                                  (get-new-generic-number))))
                       ('#<procedure #33 ##vector-set!> *generics* i g))))
                (initialize! (fill-other-fields! g))))))))))

(define look-generic
  (lambda (name)
    (letrec ((look (lambda (name i)
                     (if ('#<procedure #20 ##fx<> i *generic-number*)
                         (if ('#<procedure #3 ##eq?>
                              name
                              (let ((g ('#<procedure #32 ##vector-ref>
                                        *generics*
                                        i)))
                                ('#<procedure #32 ##vector-ref> g 1)))
                             i
                             (look name ('#<procedure #21 ##fx+> 1 i)))
                         #f))))
      (look name 0))))

(define careless-determine-method1
  (lambda (g o1)
    (if ('#<procedure #28 ##meroon?> o1)
        (let ((d ('#<procedure #32 ##vector-ref> g 4)))
          (let ((method (find-method1
                         d
                         ('#<procedure #32 ##vector-ref>
                          *classes*
                          ('#<procedure #32 ##vector-ref> o1 0)))))
            (or method ('#<procedure #32 ##vector-ref> g 2))))
        ('#<procedure #32 ##vector-ref> g 2))))

(define determine-method
  (lambda (g . o*)
    (if ('#<procedure #24 ##null?> ('#<procedure #7 ##cdr> o*))
        (careless-determine-method1 g ('#<procedure #6 ##car> o*))
        (let ((method (let ((classes (letrec ((loop2.950
                                               (lambda (lst2.951)
                                                 (if ('#<procedure #4 ##pair?>
                                                      lst2.951)
                                                     (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                            lst2.951)))
                                                                    (if ('#<procedure #28 ##meroon?>
                                                                         o)
                                                                        ('#<procedure #32 ##vector-ref>
                                                                         *classes*
                                                                         ('#<procedure #32 ##vector-ref>
                                                                          o
                                                                          0))
                                                                        #f))))
                                                       ('#<procedure #10 ##cons>
                                                        x.952
                                                        (let ((lst2.951
                                                               ('#<procedure #7 ##cdr>
                                                                lst2.951)))
                                                          (if ('#<procedure #4 ##pair?>
                                                               lst2.951)
                                                              (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                     lst2.951)))
                                                                             (if ('#<procedure #28 ##meroon?>
                                                                                  o)
                                                                                 ('#<procedure #32 ##vector-ref>
                                                                                  *classes*
                                                                                  ('#<procedure #32 ##vector-ref>
                                                                                   o
                                                                                   0))
                                                                                 #f))))
                                                                ('#<procedure #10 ##cons>
                                                                 x.952
                                                                 (let ((lst2.951
                                                                        ('#<procedure #7 ##cdr>
                                                                         lst2.951)))
                                                                   (if ('#<procedure #4 ##pair?>
                                                                        lst2.951)
                                                                       (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                              lst2.951)))
                                                                                      (if ('#<procedure #28 ##meroon?>
                                                                                           o)
                                                                                          ('#<procedure #32 ##vector-ref>
                                                                                           *classes*
                                                                                           ('#<procedure #32 ##vector-ref>
                                                                                            o
                                                                                            0))
                                                                                          #f))))
                                                                         ('#<procedure #10 ##cons>
                                                                          x.952
                                                                          (let ((lst2.951
                                                                                 ('#<procedure #7 ##cdr>
                                                                                  lst2.951)))
                                                                            (if ('#<procedure #4 ##pair?>
                                                                                 lst2.951)
                                                                                (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                                       lst2.951)))
                                                                                               (if ('#<procedure #28 ##meroon?>
                                                                                                    o)
                                                                                                   ('#<procedure #32 ##vector-ref>
                                                                                                    *classes*
                                                                                                    ('#<procedure #32 ##vector-ref>
                                                                                                     o
                                                                                                     0))
                                                                                                   #f))))
                                                                                  ('#<procedure #10 ##cons>
                                                                                   x.952
                                                                                   (let ((lst2.951
                                                                                          ('#<procedure #7 ##cdr>
                                                                                           lst2.951)))
                                                                                     (if ('#<procedure #4 ##pair?>
                                                                                          lst2.951)
                                                                                         (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                                                lst2.951)))
                                                                                                        (if ('#<procedure #28 ##meroon?>
                                                                                                             o)
                                                                                                            ('#<procedure #32 ##vector-ref>
                                                                                                             *classes*
                                                                                                             ('#<procedure #32 ##vector-ref>
                                                                                                              o
                                                                                                              0))
                                                                                                            #f))))
                                                                                           ('#<procedure #10 ##cons>
                                                                                            x.952
                                                                                            (let ((lst2.951
                                                                                                   ('#<procedure #7 ##cdr>
                                                                                                    lst2.951)))
                                                                                              (if ('#<procedure #4 ##pair?>
                                                                                                   lst2.951)
                                                                                                  (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                                                         lst2.951)))
                                                                                                                 (if ('#<procedure #28 ##meroon?>
                                                                                                                      o)
                                                                                                                     ('#<procedure #32 ##vector-ref>
                                                                                                                      *classes*
                                                                                                                      ('#<procedure #32 ##vector-ref>
                                                                                                                       o
                                                                                                                       0))
                                                                                                                     #f))))
                                                                                                    ('#<procedure #10 ##cons>
                                                                                                     x.952
                                                                                                     (let ((lst2.951
                                                                                                            ('#<procedure #7 ##cdr>
                                                                                                             lst2.951)))
                                                                                                       (if ('#<procedure #4 ##pair?>
                                                                                                            lst2.951)
                                                                                                           (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                                                                  lst2.951)))
                                                                                                                          (if ('#<procedure #28 ##meroon?>
                                                                                                                               o)
                                                                                                                              ('#<procedure #32 ##vector-ref>
                                                                                                                               *classes*
                                                                                                                               ('#<procedure #32 ##vector-ref>
                                                                                                                                o
                                                                                                                                0))
                                                                                                                              #f))))
                                                                                                             ('#<procedure #10 ##cons>
                                                                                                              x.952
                                                                                                              (let ((lst2.951
                                                                                                                     ('#<procedure #7 ##cdr>
                                                                                                                      lst2.951)))
                                                                                                                (if ('#<procedure #4 ##pair?>
                                                                                                                     lst2.951)
                                                                                                                    (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                                                                           lst2.951)))
                                                                                                                                   (if ('#<procedure #28 ##meroon?>
                                                                                                                                        o)
                                                                                                                                       ('#<procedure #32 ##vector-ref>
                                                                                                                                        *classes*
                                                                                                                                        ('#<procedure #32 ##vector-ref>
                                                                                                                                         o
                                                                                                                                         0))
                                                                                                                                       #f))))
                                                                                                                      ('#<procedure #10 ##cons>
                                                                                                                       x.952
                                                                                                                       (let ((lst2.951
                                                                                                                              ('#<procedure #7 ##cdr>
                                                                                                                               lst2.951)))
                                                                                                                         (if ('#<procedure #4 ##pair?>
                                                                                                                              lst2.951)
                                                                                                                             (let ((x.952 (let ((o ('#<procedure #6 ##car>
                                                                                                                                                    lst2.951)))
                                                                                                                                            (if ('#<procedure #28 ##meroon?>
                                                                                                                                                 o)
                                                                                                                                                ('#<procedure #32 ##vector-ref>
                                                                                                                                                 *classes*
                                                                                                                                                 ('#<procedure #32 ##vector-ref>
                                                                                                                                                  o
                                                                                                                                                  0))
                                                                                                                                                #f))))
                                                                                                                               ('#<procedure #10 ##cons>
                                                                                                                                x.952
                                                                                                                                (loop2.950
                                                                                                                                 ('#<procedure #7 ##cdr>
                                                                                                                                  lst2.951))))
                                                                                                                             '()))))
                                                                                                                    '()))))
                                                                                                           '()))))
                                                                                                  '()))))
                                                                                         '()))))
                                                                                '()))))
                                                                       '()))))
                                                              '()))))
                                                     '()))))
                                       (loop2.950 o*)))
                            (d ('#<procedure #32 ##vector-ref> g 4)))
                        (('#<procedure #32 ##vector-ref> d 1) d classes))))
          (or method ('#<procedure #32 ##vector-ref> g 2))))))

(define Immediate-Dispatcher-find-method
  (lambda (d cl) ('#<procedure #32 ##vector-ref> d 2)))

(define Subclass-Dispatcher-find-method
  (lambda (d cl)
    (if (let ((number ('#<procedure #32 ##vector-ref> d 2))
              (depth ('#<procedure #32 ##vector-ref> d 3)))
          (and ('#<procedure #36 ##fx>=>
                ('#<procedure #32 ##vector-ref> cl 4)
                depth)
               ('#<procedure #50 ##fx=>
                (if (and ('#<procedure #36 ##fx>=> depth 0)
                         ('#<procedure #49 ##fx<=>
                          depth
                          ('#<procedure #32 ##vector-ref> cl 4)))
                    (let ((offset ('#<procedure #21 ##fx+>
                                   10
                                   ('#<procedure #21 ##fx+> 1 depth))))
                      (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                        ('#<procedure #32 ##vector-ref> cl i)))
                    (report-bad-index 'super cl depth))
                number)))
        (find-method1 ('#<procedure #32 ##vector-ref> d 5) cl)
        (find-method1 ('#<procedure #32 ##vector-ref> d 4) cl))))

(define Indexed-Dispatcher-find-method
  (lambda (d cl)
    (let ((number ('#<procedure #32 ##vector-ref> d 2))
          (depth ('#<procedure #32 ##vector-ref> d 3)))
      (if (and ('#<procedure #36 ##fx>=>
                ('#<procedure #32 ##vector-ref> cl 4)
                depth)
               ('#<procedure #50 ##fx=>
                (if (and ('#<procedure #36 ##fx>=> depth 0)
                         ('#<procedure #49 ##fx<=>
                          depth
                          ('#<procedure #32 ##vector-ref> cl 4)))
                    (let ((offset ('#<procedure #21 ##fx+>
                                   10
                                   ('#<procedure #21 ##fx+> 1 depth))))
                      (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                        ('#<procedure #32 ##vector-ref> cl i)))
                    (report-bad-index 'super cl depth))
                number))
          (let ((i (if (and ('#<procedure #36 ##fx>=> depth 0)
                            ('#<procedure #49 ##fx<=>
                             depth
                             ('#<procedure #32 ##vector-ref> cl 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+>
                                       1
                                       ('#<procedure #21 ##fx+>
                                        ('#<procedure #32 ##vector-ref> cl 4)
                                        depth)))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> cl i)))
                       (report-bad-index 'super cl depth))))
            (let ((offset ('#<procedure #21 ##fx+> 5 i)))
              (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                ('#<procedure #32 ##vector-ref> d i))))
          (find-method1 ('#<procedure #32 ##vector-ref> d 4) cl)))))

(define Global-Dispatcher-find-method
  (lambda (d cl)
    (let ((i ('#<procedure #32 ##vector-ref> cl 2)))
      (let ((offset ('#<procedure #21 ##fx+> 2 i)))
        (let ((i ('#<procedure #21 ##fx+> 1 offset)))
          ('#<procedure #32 ##vector-ref> d i))))))

(define *indexed-dispatch* 0)

(define *subclass-dispatch* 0)

(define *immediate-dispatch* 0)

(define *global-dispatch* 0)

(define *else-dispatch* 0)

(define find-method1
  (lambda (d cl)
    (let ((cn ('#<procedure #32 ##vector-ref> d 0)))
      (if ('#<procedure #50 ##fx=>
           cn
           original-Subclass-Dispatcher-class-number)
          (if (let ((number ('#<procedure #32 ##vector-ref> d 2))
                    (depth ('#<procedure #32 ##vector-ref> d 3)))
                (and ('#<procedure #36 ##fx>=>
                      ('#<procedure #32 ##vector-ref> cl 4)
                      depth)
                     ('#<procedure #50 ##fx=>
                      (if (and ('#<procedure #36 ##fx>=> depth 0)
                               ('#<procedure #49 ##fx<=>
                                depth
                                ('#<procedure #32 ##vector-ref> cl 4)))
                          (let ((offset ('#<procedure #21 ##fx+>
                                         10
                                         ('#<procedure #21 ##fx+> 1 depth))))
                            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                              ('#<procedure #32 ##vector-ref> cl i)))
                          (report-bad-index 'super cl depth))
                      number)))
              (find-method1 ('#<procedure #32 ##vector-ref> d 5) cl)
              (find-method1 ('#<procedure #32 ##vector-ref> d 4) cl))
          (if ('#<procedure #50 ##fx=>
               cn
               original-Immediate-Dispatcher-class-number)
              ('#<procedure #32 ##vector-ref> d 2)
              (if ('#<procedure #50 ##fx=>
                   cn
                   original-Indexed-Dispatcher-class-number)
                  (let ((number ('#<procedure #32 ##vector-ref> d 2))
                        (depth ('#<procedure #32 ##vector-ref> d 3)))
                    (if (and ('#<procedure #36 ##fx>=>
                              ('#<procedure #32 ##vector-ref> cl 4)
                              depth)
                             ('#<procedure #50 ##fx=>
                              (if (and ('#<procedure #36 ##fx>=> depth 0)
                                       ('#<procedure #49 ##fx<=>
                                        depth
                                        ('#<procedure #32 ##vector-ref> cl 4)))
                                  (let ((offset ('#<procedure #21 ##fx+>
                                                 10
                                                 ('#<procedure #21 ##fx+>
                                                  1
                                                  depth))))
                                    (let ((i ('#<procedure #21 ##fx+>
                                              1
                                              offset)))
                                      ('#<procedure #32 ##vector-ref> cl i)))
                                  (report-bad-index 'super cl depth))
                              number))
                        (let ((i (if (and ('#<procedure #36 ##fx>=> depth 0)
                                          ('#<procedure #49 ##fx<=>
                                           depth
                                           ('#<procedure #32 ##vector-ref>
                                            cl
                                            4)))
                                     (let ((offset ('#<procedure #21 ##fx+>
                                                    10
                                                    ('#<procedure #21 ##fx+>
                                                     1
                                                     ('#<procedure #21 ##fx+>
                                                      ('#<procedure #32 ##vector-ref>
                                                       cl
                                                       4)
                                                      depth)))))
                                       (let ((i ('#<procedure #21 ##fx+>
                                                 1
                                                 offset)))
                                         ('#<procedure #32 ##vector-ref>
                                          cl
                                          i)))
                                     (report-bad-index 'super cl depth))))
                          (let ((offset ('#<procedure #21 ##fx+> 5 i)))
                            (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                              ('#<procedure #32 ##vector-ref> d i))))
                        (find-method1
                         ('#<procedure #32 ##vector-ref> d 4)
                         cl)))
                  (if ('#<procedure #50 ##fx=>
                       cn
                       original-Global-Dispatcher-class-number)
                      (let ((i ('#<procedure #32 ##vector-ref> cl 2)))
                        (let ((offset ('#<procedure #21 ##fx+> 2 i)))
                          (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                            ('#<procedure #32 ##vector-ref> d i))))
                      (('#<procedure #32 ##vector-ref> d 1) d cl))))))))

(define register-method
  (lambda (generic-name
           variable-list
           rev
           method-maker
           .
           discriminating-class-names)
    (let ((begin-temp.167 (check-revision rev)))
      (let ((classes (let ((temp.953
                            (lambda (generic-name name)
                              (symbol->class
                               name
                               (lambda (name)
                                 (report-meroon-error
                                  'Domain
                                  'define-method
                                  "No such class"
                                  generic-name
                                  name))))))
                       (letrec ((loop2.955
                                 (lambda (generic-name lst2.956)
                                   (if ('#<procedure #4 ##pair?> lst2.956)
                                       (let ((x.957 (temp.953
                                                     generic-name
                                                     ('#<procedure #6 ##car>
                                                      lst2.956))))
                                         ('#<procedure #10 ##cons>
                                          x.957
                                          (loop2.955
                                           generic-name
                                           ('#<procedure #7 ##cdr> lst2.956))))
                                       '()))))
                         (loop2.955 generic-name discriminating-class-names))))
            (g (symbol->generic
                generic-name
                (lambda (name)
                  (report-meroon-error
                   'Domain
                   'define-method
                   "No such generic function"
                   generic-name
                   discriminating-class-names
                   variable-list
                   method-maker)))))
        (let ((begin-temp.166
               (if (coherent-variables? (Generic-variables g) variable-list)
                   #!void
                   (report-meroon-error
                    'Syntax
                    'define-method
                    "Non congruent lambda-lists"
                    (Generic-variables g)
                    variable-list))))
          (let ((begin-temp.165
                 (if (let ((temp.958
                            (compare-signatures
                             classes
                             (Generic-top-classes g))))
                       (letrec ((loop.960
                                 (lambda (temp.958 lst1.961)
                                   (if ('#<procedure #4 ##pair?> lst1.961)
                                       (let ((x.962 ('#<procedure #6 ##car>
                                                     lst1.961)))
                                         (if ('#<procedure #3 ##eq?>
                                              temp.958
                                              x.962)
                                             lst1.961
                                             (loop.960
                                              temp.958
                                              ('#<procedure #7 ##cdr>
                                               lst1.961))))
                                       #f))))
                         (loop.960 temp.958 '(< =))))
                     #!void
                     (report-meroon-error
                      'Syntax
                      'define-method
                      "method prohibited by the generic declaration"
                      (Generic-top-classes g)
                      classes))))
            (let ((begin-temp.164
                   (let ((case-temp.163
                          ('#<procedure #23 length>
                           discriminating-class-names)))
                     (if ('#<procedure #3 ##eq?> case-temp.163 1)
                         (let ((c ('#<procedure #6 ##car> classes)))
                           (add-1-method! g c (method-maker g c 'void)))
                         (add-N-method! g classes method-maker)))))
              generic-name)))))))

(define coherent-variables?
  (lambda (generic-vars method-vars)
    (let ((rest? ('#<procedure #61 ##box> #f))
          (dsssl? ('#<procedure #61 ##box> #f)))
      (letrec ((extract-keywords
                (lambda (formals)
                  (if ('#<procedure #4 ##pair?> formals)
                      (if ('#<procedure #4 ##pair?>
                           ('#<procedure #6 ##car> formals))
                          ('#<procedure #10 ##cons>
                           ('#<procedure #47 ##caar> formals)
                           (extract-keywords ('#<procedure #7 ##cdr> formals)))
                          ('#<procedure #10 ##cons>
                           ('#<procedure #6 ##car> formals)
                           (extract-keywords
                            ('#<procedure #7 ##cdr> formals))))
                      '()))))
        (letrec ((set-included?
                  (lambda (set1 set2)
                    (if ('#<procedure #4 ##pair?> set1)
                        (and (let ((temp.963 ('#<procedure #6 ##car> set1)))
                               (letrec ((loop.965
                                         (lambda (temp.963 lst1.966)
                                           (if ('#<procedure #4 ##pair?>
                                                lst1.966)
                                               (let ((x.967 ('#<procedure #6 ##car>
                                                             lst1.966)))
                                                 (if ('#<procedure #3 ##eq?>
                                                      temp.963
                                                      x.967)
                                                     lst1.966
                                                     (loop.965
                                                      temp.963
                                                      ('#<procedure #7 ##cdr>
                                                       lst1.966))))
                                               #f))))
                                 (loop.965 temp.963 set2)))
                             (set-included?
                              ('#<procedure #7 ##cdr> set1)
                              set2))
                        #t))))
          (letrec ((set-equal?
                    (lambda (set1 set2)
                      (if ('#<procedure #4 ##pair?> set1)
                          (and (let ((temp.968 ('#<procedure #6 ##car> set1)))
                                 (letrec ((loop.970
                                           (lambda (temp.968 lst1.971)
                                             (if ('#<procedure #4 ##pair?>
                                                  lst1.971)
                                                 (let ((x.972 ('#<procedure #6 ##car>
                                                               lst1.971)))
                                                   (if ('#<procedure #3 ##eq?>
                                                        temp.968
                                                        x.972)
                                                       lst1.971
                                                       (loop.970
                                                        temp.968
                                                        ('#<procedure #7 ##cdr>
                                                         lst1.971))))
                                                 #f))))
                                   (loop.970 temp.968 set2)))
                               (set-equal?
                                ('#<procedure #7 ##cdr> set1)
                                (remove ('#<procedure #6 ##car> set1) set2)))
                          ('#<procedure #24 ##null?> set2)))))
            (letrec ((cv (lambda (rest?
                                  dsssl?
                                  set-included?
                                  set-equal?
                                  generic-vars
                                  method-vars)
                           (if ('#<procedure #4 ##pair?> generic-vars)
                               (if ('#<procedure #4 ##pair?> method-vars)
                                   (if (and ('#<procedure #5 ##not>
                                             ('#<procedure #62 ##unbox>
                                              dsssl?))
                                            (and ('#<procedure #4 ##pair?>
                                                  ('#<procedure #6 ##car>
                                                   generic-vars))
                                                 ('#<procedure #4 ##pair?>
                                                  ('#<procedure #6 ##car>
                                                   method-vars))))
                                       (cv rest?
                                           dsssl?
                                           set-included?
                                           set-equal?
                                           ('#<procedure #7 ##cdr>
                                            generic-vars)
                                           ('#<procedure #7 ##cdr>
                                            method-vars))
                                       (if (let ((thing ('#<procedure #6 ##car>
                                                         generic-vars)))
                                             ('#<procedure #3 ##eq?>
                                              thing
                                              #!optional))
                                           (let ((begin-temp.168
                                                  ('#<procedure #63 ##set-box!>
                                                   dsssl?
                                                   #t)))
                                             (and ('#<procedure #25 equal?>
                                                   ('#<procedure #6 ##car>
                                                    generic-vars)
                                                   ('#<procedure #6 ##car>
                                                    method-vars))
                                                  (cv rest?
                                                      dsssl?
                                                      set-included?
                                                      set-equal?
                                                      ('#<procedure #7 ##cdr>
                                                       generic-vars)
                                                      ('#<procedure #7 ##cdr>
                                                       method-vars))))
                                           (if (let ((thing ('#<procedure #6 ##car>
                                                             generic-vars)))
                                                 ('#<procedure #3 ##eq?>
                                                  thing
                                                  #!rest))
                                               (let ((begin-temp.170
                                                      ('#<procedure #63 ##set-box!>
                                                       dsssl?
                                                       #t)))
                                                 (let ((begin-temp.169
                                                        ('#<procedure #63 ##set-box!>
                                                         rest?
                                                         #t)))
                                                   (and ('#<procedure #25 equal?>
                                                         ('#<procedure #6 ##car>
                                                          generic-vars)
                                                         ('#<procedure #6 ##car>
                                                          method-vars))
                                                        (cv rest?
                                                            dsssl?
                                                            set-included?
                                                            set-equal?
                                                            ('#<procedure #7 ##cdr>
                                                             generic-vars)
                                                            ('#<procedure #7 ##cdr>
                                                             method-vars)))))
                                               (if (let ((thing ('#<procedure #6 ##car>
                                                                 generic-vars)))
                                                     ('#<procedure #3 ##eq?>
                                                      thing
                                                      #!key))
                                                   (and ('#<procedure #25 equal?>
                                                         ('#<procedure #6 ##car>
                                                          generic-vars)
                                                         ('#<procedure #6 ##car>
                                                          method-vars))
                                                        ((if ('#<procedure #62 ##unbox>
                                                              rest?)
                                                             set-included?
                                                             set-equal?)
                                                         (extract-keywords
                                                          ('#<procedure #7 ##cdr>
                                                           generic-vars))
                                                         (extract-keywords
                                                          ('#<procedure #7 ##cdr>
                                                           method-vars))))
                                                   (if ('#<procedure #5 ##not>
                                                        ('#<procedure #62 ##unbox>
                                                         dsssl?))
                                                       (and ('#<procedure #16 ##symbol?>
                                                             ('#<procedure #6 ##car>
                                                              generic-vars))
                                                            (and ('#<procedure #16 ##symbol?>
                                                                  ('#<procedure #6 ##car>
                                                                   method-vars))
                                                                 (cv rest?
                                                                     dsssl?
                                                                     set-included?
                                                                     set-equal?
                                                                     ('#<procedure #7 ##cdr>
                                                                      generic-vars)
                                                                     ('#<procedure #7 ##cdr>
                                                                      method-vars))))
                                                       (cv rest?
                                                           dsssl?
                                                           set-included?
                                                           set-equal?
                                                           ('#<procedure #7 ##cdr>
                                                            generic-vars)
                                                           ('#<procedure #7 ##cdr>
                                                            method-vars)))))))
                                   #f)
                               (or (and ('#<procedure #24 ##null?>
                                         generic-vars)
                                        ('#<procedure #24 ##null?>
                                         method-vars))
                                   (and ('#<procedure #5 ##not>
                                         ('#<procedure #62 ##unbox> dsssl?))
                                        (and ('#<procedure #16 ##symbol?>
                                              generic-vars)
                                             ('#<procedure #16 ##symbol?>
                                              method-vars))))))))
              (cv rest?
                  dsssl?
                  set-included?
                  set-equal?
                  generic-vars
                  method-vars))))))))

(define Generic-update!
  (lambda (generic class)
    (if (Generic-1? generic)
        (set-Generic-dispatcher!
         generic
         (update-dispatcher! (Generic-dispatcher generic) class))
        (if (Generic-N? generic)
            generic
            (report-meroon-error
             'internal
             'Generic-update!
             "No such method"
             generic
             class)))))

(set! Generic-update! Generic-update!)

'Generic-update!

(define Generic-N-update! (lambda (generic class) generic))

(define Generic-1-update!
  (lambda (generic class)
    (set-Generic-dispatcher!
     generic
     (update-dispatcher! (Generic-dispatcher generic) class))))

(define update-dispatcher!
  (lambda (d class)
    ((if (Immediate-Dispatcher? d)
         Immediate-Dispatcher-update-dispatcher!
         (if (Subclass-Dispatcher? d)
             Subclass-Dispatcher-update-dispatcher!
             (if (Indexed-Dispatcher? d)
                 Indexed-Dispatcher-update-dispatcher!
                 (if (Global-Dispatcher? d)
                     Global-Dispatcher-update-dispatcher!
                     (if (Tracing-Dispatcher? d)
                         Tracing-Dispatcher-update-dispatcher!
                         internal-meroon-error)))))
     d
     class)))

(set! update-dispatcher! update-dispatcher!)

'update-dispatcher!

(define default-update-dispatcher! internal-meroon-error)

(define Immediate-Dispatcher-update-dispatcher! (lambda (d class) d))

(define Subclass-Dispatcher-update-dispatcher!
  (lambda (d class)
    (let ((number ('#<procedure #32 ##vector-ref> d 2))
          (depth ('#<procedure #32 ##vector-ref> d 3)))
      (let ((begin-temp.171
             (if (and ('#<procedure #36 ##fx>=>
                       ('#<procedure #32 ##vector-ref> class 4)
                       depth)
                      ('#<procedure #50 ##fx=>
                       (if (and ('#<procedure #36 ##fx>=> depth 0)
                                ('#<procedure #49 ##fx<=>
                                 depth
                                 ('#<procedure #32 ##vector-ref> class 4)))
                           (let ((offset ('#<procedure #21 ##fx+>
                                          10
                                          ('#<procedure #21 ##fx+> 1 depth))))
                             (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                               ('#<procedure #32 ##vector-ref> class i)))
                           (report-bad-index 'super class depth))
                       number))
                 (let ((v (update-dispatcher!
                           ('#<procedure #32 ##vector-ref> d 5)
                           class)))
                   ('#<procedure #33 ##vector-set!> d 5 v))
                 (let ((v (update-dispatcher!
                           ('#<procedure #32 ##vector-ref> d 4)
                           class)))
                   ('#<procedure #33 ##vector-set!> d 4 v)))))
        d))))

(define Indexed-Dispatcher-update-dispatcher!
  (lambda (d class)
    (let ((depth ('#<procedure #32 ##vector-ref> d 3)))
      (let ((number ('#<procedure #32 ##vector-ref> d 2)))
        (let ((d (if ('#<procedure #53 ##fx>>
                      ('#<procedure #32 ##vector-ref> d 5)
                      (let ((class ('#<procedure #32 ##vector-ref>
                                    *classes*
                                    number)))
                        ('#<procedure #32 ##vector-ref> class 7)))
                     d
                     (extend-Indexed-Dispatcher d))))
          (let ((begin-temp.173
                 (if (and ('#<procedure #36 ##fx>=>
                           ('#<procedure #32 ##vector-ref> class 4)
                           depth)
                          ('#<procedure #50 ##fx=>
                           (if (and ('#<procedure #36 ##fx>=> depth 0)
                                    ('#<procedure #49 ##fx<=>
                                     depth
                                     ('#<procedure #32 ##vector-ref> class 4)))
                               (let ((offset ('#<procedure #21 ##fx+>
                                              10
                                              ('#<procedure #21 ##fx+>
                                               1
                                               depth))))
                                 (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                                   ('#<procedure #32 ##vector-ref> class i)))
                               (report-bad-index 'super class depth))
                           number))
                     (let ((supercl (let ((i ('#<procedure #32 ##vector-ref>
                                              class
                                              5)))
                                      ('#<procedure #32 ##vector-ref>
                                       *classes*
                                       i))))
                       (let ((method (find-method1 d supercl)))
                         (let ((old-method (find-method1 d class)))
                           (letrec ((fill! (lambda (depth
                                                    d
                                                    method
                                                    old-method
                                                    cn)
                                             (let ((cl ('#<procedure #32 ##vector-ref>
                                                        *classes*
                                                        cn)))
                                               (let ((content (find-method1
                                                               d
                                                               cl)))
                                                 (if ('#<procedure #3 ##eq?>
                                                      content
                                                      old-method)
                                                     (let ((begin-temp.172
                                                            (let ((i (if (and ('#<procedure #36 ##fx>=>
                                                                               depth
                                                                               0)
                                                                              ('#<procedure #49 ##fx<=>
                                                                               depth
                                                                               ('#<procedure #32 ##vector-ref>
                                                                                cl
                                                                                4)))
                                                                         (let ((offset ('#<procedure #21 ##fx+>
                                                                                        10
                                                                                        ('#<procedure #21 ##fx+>
                                                                                         1
                                                                                         ('#<procedure #21 ##fx+>
                                                                                          ('#<procedure #32 ##vector-ref>
                                                                                           cl
                                                                                           4)
                                                                                          depth)))))
                                                                           (let ((i ('#<procedure #21 ##fx+>
                                                                                     1
                                                                                     offset)))
                                                                             ('#<procedure #32 ##vector-ref>
                                                                              cl
                                                                              i)))
                                                                         (report-bad-index
                                                                          'super
                                                                          cl
                                                                          depth))))
                                                              (let ((offset ('#<procedure #21 ##fx+>
                                                                             5
                                                                             i)))
                                                                (let ((i ('#<procedure #21 ##fx+>
                                                                          1
                                                                          offset)))
                                                                  ('#<procedure #33 ##vector-set!>
                                                                   d
                                                                   i
                                                                   method))))))
                                                       (let ((temp.974
                                                              (let ((class ('#<procedure #32 ##vector-ref>
                                                                            *classes*
                                                                            cn)))
                                                                ('#<procedure #32 ##vector-ref>
                                                                 class
                                                                 6))))
                                                         (letrec ((loop2.975
                                                                   (lambda (depth
                                                                            d
                                                                            method
                                                                            old-method
                                                                            lst2.976)
                                                                     (if ('#<procedure #4 ##pair?>
                                                                          lst2.976)
                                                                         (let ((x.977 (fill! depth
                                                                                             d
                                                                                             method
                                                                                             old-method
                                                                                             ('#<procedure #6 ##car>
                                                                                              lst2.976))))
                                                                           (let ((lst2.976
                                                                                  ('#<procedure #7 ##cdr>
                                                                                   lst2.976)))
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  lst2.976)
                                                                                 (let ((x.977 (fill! depth
                                                                                                     d
                                                                                                     method
                                                                                                     old-method
                                                                                                     ('#<procedure #6 ##car>
                                                                                                      lst2.976))))
                                                                                   (loop2.975
                                                                                    depth
                                                                                    d
                                                                                    method
                                                                                    old-method
                                                                                    ('#<procedure #7 ##cdr>
                                                                                     lst2.976)))
                                                                                 #!void)))
                                                                         #!void))))
                                                           (loop2.975
                                                            depth
                                                            d
                                                            method
                                                            old-method
                                                            temp.974))))
                                                     #!void))))))
                             (fill! depth
                                    d
                                    method
                                    old-method
                                    ('#<procedure #32 ##vector-ref>
                                     class
                                     2))))))
                     (let ((v (update-dispatcher!
                               ('#<procedure #32 ##vector-ref> d 4)
                               class)))
                       ('#<procedure #33 ##vector-set!> d 4 v)))))
            d))))))

(define Global-Dispatcher-update-dispatcher!
  (lambda (d class)
    (let ((supercl (let ((i ('#<procedure #32 ##vector-ref> class 5)))
                     ('#<procedure #32 ##vector-ref> *classes* i))))
      (let ((method (find-method1 d supercl)))
        (let ((old-method (find-method1 d class)))
          (letrec ((fill! (lambda (d method old-method cn)
                            (let ((cl ('#<procedure #32 ##vector-ref>
                                       *classes*
                                       cn)))
                              (let ((content (find-method1 d cl)))
                                (if ('#<procedure #3 ##eq?> content old-method)
                                    (let ((begin-temp.174
                                           (let ((offset ('#<procedure #21 ##fx+>
                                                          2
                                                          cn)))
                                             (let ((i ('#<procedure #21 ##fx+>
                                                       1
                                                       offset)))
                                               ('#<procedure #33 ##vector-set!>
                                                d
                                                i
                                                method)))))
                                      (let ((temp.979
                                             (let ((class ('#<procedure #32 ##vector-ref>
                                                           *classes*
                                                           cn)))
                                               ('#<procedure #32 ##vector-ref>
                                                class
                                                6))))
                                        (letrec ((loop2.980
                                                  (lambda (d
                                                           method
                                                           old-method
                                                           lst2.981)
                                                    (if ('#<procedure #4 ##pair?>
                                                         lst2.981)
                                                        (let ((x.982 (fill! d
                                                                            method
                                                                            old-method
                                                                            ('#<procedure #6 ##car>
                                                                             lst2.981))))
                                                          (let ((lst2.981
                                                                 ('#<procedure #7 ##cdr>
                                                                  lst2.981)))
                                                            (if ('#<procedure #4 ##pair?>
                                                                 lst2.981)
                                                                (let ((x.982 (fill! d
                                                                                    method
                                                                                    old-method
                                                                                    ('#<procedure #6 ##car>
                                                                                     lst2.981))))
                                                                  (loop2.980
                                                                   d
                                                                   method
                                                                   old-method
                                                                   ('#<procedure #7 ##cdr>
                                                                    lst2.981)))
                                                                #!void)))
                                                        #!void))))
                                          (loop2.980
                                           d
                                           method
                                           old-method
                                           temp.979))))
                                    #!void))))))
            (let ((begin-temp.175
                   (fill! d
                          method
                          old-method
                          ('#<procedure #32 ##vector-ref> class 2))))
              d)))))))

(define Tracing-Dispatcher-update-dispatcher!
  (lambda (d class)
    (let ((begin-temp.176
           (set-Tracing-Dispatcher-dispatcher!
            d
            (update-dispatcher! (Tracing-Dispatcher-dispatcher d) class))))
      d)))

(define add-1-method!
  (lambda (generic class method)
    (let ((dd (Generic-dispatcher generic)))
      (let ((d ('#<procedure #61 ##box>
                (augment-dispatcher! dd class method))))
        (let ((begin-temp.178
               ('#<procedure #63 ##set-box!>
                d
                (compress-dispatcher!
                 ('#<procedure #62 ##unbox> d)
                 3
                 Object-class))))
          (let ((begin-temp.177
                 (set-Generic-dispatcher!
                  generic
                  ('#<procedure #62 ##unbox> d))))
            (Generic-name generic)))))))

(define augment-dispatcher!
  (lambda (d class method)
    ((if (Immediate-Dispatcher? d)
         Immediate-Dispatcher-augment-dispatcher!
         (if (Subclass-Dispatcher? d)
             Subclass-Dispatcher-augment-dispatcher!
             (if (Indexed-Dispatcher? d)
                 Indexed-Dispatcher-augment-dispatcher!
                 (if (Global-Dispatcher? d)
                     Global-Dispatcher-augment-dispatcher!
                     (if (Tracing-Dispatcher? d)
                         Tracing-Dispatcher-augment-dispatcher!
                         internal-meroon-error)))))
     d
     class
     method)))

(set! augment-dispatcher! augment-dispatcher!)

'augment-dispatcher!

(define default-augment-dispatcher! internal-meroon-error)

(define Immediate-Dispatcher-augment-dispatcher!
  (lambda (d class method)
    (if ('#<procedure #3 ##eq?> method (Immediate-Dispatcher-method d))
        d
        (if ('#<procedure #3 ##eq?> class Object-class)
            (make-Immediate-Dispatcher Immediate-Dispatcher-find-method method)
            (let ((yes (make-Immediate-Dispatcher
                        Immediate-Dispatcher-find-method
                        method)))
              (let ((cn (Class-number class)))
                (let ((cl ('#<procedure #32 ##vector-ref> *classes* cn)))
                  (make-Subclass-Dispatcher
                   Subclass-Dispatcher-find-method
                   cn
                   ('#<procedure #32 ##vector-ref> cl 4)
                   d
                   yes))))))))

(define Indexed-Dispatcher-augment-dispatcher!
  (lambda (d class method)
    (let ((cn (Indexed-Dispatcher-class-number d)))
      (let ((depth (Indexed-Dispatcher-class-depth d)))
        (let ((cl ('#<procedure #32 ##vector-ref> *classes* cn)))
          (let ((d (if ('#<procedure #53 ##fx>>
                        (Indexed-Dispatcher-method-length d)
                        ('#<procedure #32 ##vector-ref> cl 7))
                       d
                       (extend-Indexed-Dispatcher d))))
            (if (careless-subclass? class cl)
                (let ((old-method (find-method1 d class)))
                  (letrec ((fill! (lambda (method depth d old-method cn)
                                    (let ((cl ('#<procedure #32 ##vector-ref>
                                               *classes*
                                               cn)))
                                      (let ((content (find-method1 d cl)))
                                        (if ('#<procedure #3 ##eq?>
                                             content
                                             old-method)
                                            (let ((begin-temp.179
                                                   (set-Indexed-Dispatcher-method!
                                                    d
                                                    (if (and ('#<procedure #36 ##fx>=>
                                                              depth
                                                              0)
                                                             ('#<procedure #49 ##fx<=>
                                                              depth
                                                              ('#<procedure #32 ##vector-ref>
                                                               cl
                                                               4)))
                                                        (let ((offset ('#<procedure #21 ##fx+>
                                                                       10
                                                                       ('#<procedure #21 ##fx+>
                                                                        1
                                                                        ('#<procedure #21 ##fx+>
                                                                         ('#<procedure #32 ##vector-ref>
                                                                          cl
                                                                          4)
                                                                         depth)))))
                                                          (let ((i ('#<procedure #21 ##fx+>
                                                                    1
                                                                    offset)))
                                                            ('#<procedure #32 ##vector-ref>
                                                             cl
                                                             i)))
                                                        (report-bad-index
                                                         'super
                                                         cl
                                                         depth))
                                                    method)))
                                              (let ((temp.984
                                                     (Class-subclass-numbers
                                                      ('#<procedure #32 ##vector-ref>
                                                       *classes*
                                                       cn))))
                                                (letrec ((loop2.985
                                                          (lambda (method
                                                                   depth
                                                                   d
                                                                   old-method
                                                                   lst2.986)
                                                            (if ('#<procedure #4 ##pair?>
                                                                 lst2.986)
                                                                (let ((x.987 (fill! method
                                                                                    depth
                                                                                    d
                                                                                    old-method
                                                                                    ('#<procedure #6 ##car>
                                                                                     lst2.986))))
                                                                  (let ((lst2.986
                                                                         ('#<procedure #7 ##cdr>
                                                                          lst2.986)))
                                                                    (if ('#<procedure #4 ##pair?>
                                                                         lst2.986)
                                                                        (let ((x.987 (fill! method
                                                                                            depth
                                                                                            d
                                                                                            old-method
                                                                                            ('#<procedure #6 ##car>
                                                                                             lst2.986))))
                                                                          (loop2.985
                                                                           method
                                                                           depth
                                                                           d
                                                                           old-method
                                                                           ('#<procedure #7 ##cdr>
                                                                            lst2.986)))
                                                                        #!void)))
                                                                #!void))))
                                                  (loop2.985
                                                   method
                                                   depth
                                                   d
                                                   old-method
                                                   temp.984))))
                                            #!void))))))
                    (let ((begin-temp.180
                           (fill! method
                                  depth
                                  d
                                  old-method
                                  (Class-number class))))
                      d)))
                (if (careless-subclass? cl class)
                    (let ((no-d (Indexed-Dispatcher-no d)))
                      (let ((begin-temp.181
                             (set-Indexed-Dispatcher-no!
                              d
                              (make-Immediate-Dispatcher
                               Immediate-Dispatcher-find-method
                               method))))
                        (make-Subclass-Dispatcher
                         Subclass-Dispatcher-find-method
                         ('#<procedure #32 ##vector-ref> class 2)
                         ('#<procedure #32 ##vector-ref> class 4)
                         no-d
                         d)))
                    (let ((no-d (augment-dispatcher!
                                 (Indexed-Dispatcher-no d)
                                 class
                                 method)))
                      (let ((begin-temp.182
                             (set-Indexed-Dispatcher-no! d no-d)))
                        d))))))))))

(define Global-Dispatcher-augment-dispatcher!
  (lambda (d class method)
    (let ((begin-temp.184
           (let ((old-method (find-method1 d class)))
             (letrec ((fill! (lambda (d method old-method cn)
                               (let ((cl ('#<procedure #32 ##vector-ref>
                                          *classes*
                                          cn)))
                                 (let ((content (find-method1 d cl)))
                                   (if ('#<procedure #3 ##eq?>
                                        content
                                        old-method)
                                       (let ((begin-temp.183
                                              (set-Global-Dispatcher-method!
                                               d
                                               cn
                                               method)))
                                         (let ((temp.989
                                                (Class-subclass-numbers cl)))
                                           (letrec ((loop2.990
                                                     (lambda (d
                                                              method
                                                              old-method
                                                              lst2.991)
                                                       (if ('#<procedure #4 ##pair?>
                                                            lst2.991)
                                                           (let ((x.992 (fill! d
                                                                               method
                                                                               old-method
                                                                               ('#<procedure #6 ##car>
                                                                                lst2.991))))
                                                             (let ((lst2.991
                                                                    ('#<procedure #7 ##cdr>
                                                                     lst2.991)))
                                                               (if ('#<procedure #4 ##pair?>
                                                                    lst2.991)
                                                                   (let ((x.992 (fill! d
                                                                                       method
                                                                                       old-method
                                                                                       ('#<procedure #6 ##car>
                                                                                        lst2.991))))
                                                                     (loop2.990
                                                                      d
                                                                      method
                                                                      old-method
                                                                      ('#<procedure #7 ##cdr>
                                                                       lst2.991)))
                                                                   #!void)))
                                                           #!void))))
                                             (loop2.990
                                              d
                                              method
                                              old-method
                                              temp.989))))
                                       #!void))))))
               (fill! d
                      method
                      old-method
                      ('#<procedure #32 ##vector-ref> class 2))))))
      d)))

(define Tracing-Dispatcher-augment-dispatcher!
  (lambda (d class method)
    (let ((begin-temp.185
           (set-Tracing-Dispatcher-dispatcher!
            d
            (augment-dispatcher!
             (Tracing-Dispatcher-dispatcher d)
             class
             method))))
      d)))

(define Subclass-Dispatcher-augment-dispatcher!
  (lambda (d class method)
    (let ((cl (let ((i (Subclass-Dispatcher-class-number d)))
                ('#<procedure #32 ##vector-ref> *classes* i))))
      (if ('#<procedure #3 ##eq?> cl class)
          (let ((yes-d (augment-dispatcher!
                        (Subclass-Dispatcher-yes d)
                        class
                        method)))
            (let ((begin-temp.186
                   (if (and (Subclass-Dispatcher? yes-d)
                            ('#<procedure #50 ##fx=>
                             (Subclass-Dispatcher-class-number d)
                             (Subclass-Dispatcher-class-number yes-d)))
                       (set-Subclass-Dispatcher-yes!
                        d
                        (Subclass-Dispatcher-yes yes-d))
                       (set-Subclass-Dispatcher-yes! d yes-d))))
              d))
          (if (careless-subclass? class cl)
              (let ((begin-temp.187
                     (set-Subclass-Dispatcher-yes!
                      d
                      (augment-dispatcher!
                       (Subclass-Dispatcher-yes d)
                       class
                       method))))
                d)
              (if (careless-subclass? cl class)
                  (let ((newd (let ((yes (let ((yes (Subclass-Dispatcher-yes
                                                     d))
                                               (no (make-Immediate-Dispatcher
                                                    Immediate-Dispatcher-find-method
                                                    method))
                                               (cn (Subclass-Dispatcher-class-number
                                                    d)))
                                           (let ((cl ('#<procedure #32 ##vector-ref>
                                                      *classes*
                                                      cn)))
                                             (make-Subclass-Dispatcher
                                              Subclass-Dispatcher-find-method
                                              cn
                                              ('#<procedure #32 ##vector-ref>
                                               cl
                                               4)
                                              no
                                              yes))))
                                    (no (Subclass-Dispatcher-no d))
                                    (cn (Class-number class)))
                                (let ((cl ('#<procedure #32 ##vector-ref>
                                           *classes*
                                           cn)))
                                  (make-Subclass-Dispatcher
                                   Subclass-Dispatcher-find-method
                                   cn
                                   ('#<procedure #32 ##vector-ref> cl 4)
                                   no
                                   yes)))))
                    (let ((begin-temp.188
                           (set-Subclass-Dispatcher-no!
                            newd
                            (rebalance-dispatcher!
                             newd
                             (Subclass-Dispatcher-no newd)))))
                      newd))
                  (let ((begin-temp.189
                         (set-Subclass-Dispatcher-no!
                          d
                          (augment-dispatcher!
                           (Subclass-Dispatcher-no d)
                           class
                           method))))
                    d)))))))

(define rebalance-dispatcher!
  (lambda (d dno)
    ((if (Subclass-Dispatcher? dno)
         Subclass-Dispatcher-rebalance-dispatcher!
         (if (Immediate-Dispatcher? dno)
             Immediate-Dispatcher-rebalance-dispatcher!
             (if (Indexed-Dispatcher? dno)
                 Indexed-Dispatcher-rebalance-dispatcher!
                 (if (Global-Dispatcher? dno)
                     Global-Dispatcher-rebalance-dispatcher!
                     (if (Tracing-Dispatcher? dno)
                         Tracing-Dispatcher-rebalance-dispatcher!
                         internal-meroon-error)))))
     d
     dno)))

(set! rebalance-dispatcher! rebalance-dispatcher!)

'rebalance-dispatcher!

(define Subclass-Dispatcher-rebalance-dispatcher!
  (lambda (d dno)
    (let ((clno (let ((i (Subclass-Dispatcher-class-number dno)))
                  ('#<procedure #32 ##vector-ref> *classes* i)))
          (cl (let ((i (Subclass-Dispatcher-class-number d)))
                ('#<procedure #32 ##vector-ref> *classes* i))))
      (if (careless-subclass? clno cl)
          (let ((no (Subclass-Dispatcher-no dno)))
            (let ((begin-temp.191
                   (set-Subclass-Dispatcher-no!
                    dno
                    (Subclass-Dispatcher-yes d))))
              (let ((begin-temp.190 (set-Subclass-Dispatcher-yes! d dno)))
                (rebalance-dispatcher! d no))))
          (set-Subclass-Dispatcher-no!
           dno
           (rebalance-dispatcher! d (Subclass-Dispatcher-no dno)))))))

(define Immediate-Dispatcher-rebalance-dispatcher! (lambda (d dno) dno))

(define Indexed-Dispatcher-rebalance-dispatcher!
  (lambda (d dno)
    (let ((clno (let ((i (Indexed-Dispatcher-class-number dno)))
                  ('#<procedure #32 ##vector-ref> *classes* i)))
          (cl (let ((i (Subclass-Dispatcher-class-number d)))
                ('#<procedure #32 ##vector-ref> *classes* i))))
      (if (careless-subclass? clno cl)
          (let ((no (Indexed-Dispatcher-no dno)))
            (let ((begin-temp.193
                   (set-Indexed-Dispatcher-no!
                    dno
                    (Subclass-Dispatcher-yes d))))
              (let ((begin-temp.192 (set-Subclass-Dispatcher-yes! d dno)))
                (rebalance-dispatcher! d no))))
          (set-Indexed-Dispatcher-no!
           dno
           (rebalance-dispatcher! d (Indexed-Dispatcher-no dno)))))))

(define Global-Dispatcher-rebalance-dispatcher! (lambda (d dno) dno))

(define Tracing-Dispatcher-rebalance-dispatcher! (lambda (d dno) dno))

(define compress-dispatcher!
  (lambda (d level top-class)
    ((if (Immediate-Dispatcher? d)
         Immediate-Dispatcher-compress-dispatcher!
         (if (Indexed-Dispatcher? d)
             Indexed-Dispatcher-compress-dispatcher!
             (if (Subclass-Dispatcher? d)
                 Subclass-Dispatcher-compress-dispatcher!
                 (if (Global-Dispatcher? d)
                     Global-Dispatcher-compress-dispatcher!
                     (if (Tracing-Dispatcher? d)
                         Tracing-Dispatcher-compress-dispatcher!
                         internal-meroon-error)))))
     d
     level
     top-class)))

(set! compress-dispatcher! compress-dispatcher!)

'compress-dispatcher!

(define indexize-dispatcher
  (lambda (dispatcher class)
    (if ('#<procedure #3 ##eq?> class Object-class)
        (globalize-dispatcher dispatcher)
        (really-indexize-dispatcher dispatcher class))))

(define really-indexize-dispatcher
  (lambda (dispatcher class)
    (let ((depth ('#<procedure #32 ##vector-ref> class 4)))
      (let ((number ('#<procedure #32 ##vector-ref> class 2)))
        (let ((newd (create-Indexed-Dispatcher
                     number
                     (make-Immediate-Dispatcher
                      Immediate-Dispatcher-find-method
                      #f))))
          (let ((begin-temp.195
                 (letrec ((fill! (lambda (dispatcher depth newd cn)
                                   (let ((cl ('#<procedure #32 ##vector-ref>
                                              *classes*
                                              cn)))
                                     (let ((begin-temp.194
                                            (set-Indexed-Dispatcher-method!
                                             newd
                                             (if (and ('#<procedure #36 ##fx>=>
                                                       depth
                                                       0)
                                                      ('#<procedure #49 ##fx<=>
                                                       depth
                                                       ('#<procedure #32 ##vector-ref>
                                                        cl
                                                        4)))
                                                 (let ((offset ('#<procedure #21 ##fx+>
                                                                10
                                                                ('#<procedure #21 ##fx+>
                                                                 1
                                                                 ('#<procedure #21 ##fx+>
                                                                  ('#<procedure #32 ##vector-ref>
                                                                   cl
                                                                   4)
                                                                  depth)))))
                                                   (let ((i ('#<procedure #21 ##fx+>
                                                             1
                                                             offset)))
                                                     ('#<procedure #32 ##vector-ref>
                                                      cl
                                                      i)))
                                                 (report-bad-index
                                                  'super
                                                  cl
                                                  depth))
                                             (find-method1 dispatcher cl))))
                                       (let ((temp.994
                                              (Class-subclass-numbers cl)))
                                         (letrec ((loop2.995
                                                   (lambda (dispatcher
                                                            depth
                                                            newd
                                                            lst2.996)
                                                     (if ('#<procedure #4 ##pair?>
                                                          lst2.996)
                                                         (let ((x.997 (fill! dispatcher
                                                                             depth
                                                                             newd
                                                                             ('#<procedure #6 ##car>
                                                                              lst2.996))))
                                                           (let ((lst2.996
                                                                  ('#<procedure #7 ##cdr>
                                                                   lst2.996)))
                                                             (if ('#<procedure #4 ##pair?>
                                                                  lst2.996)
                                                                 (let ((x.997 (fill! dispatcher
                                                                                     depth
                                                                                     newd
                                                                                     ('#<procedure #6 ##car>
                                                                                      lst2.996))))
                                                                   (loop2.995
                                                                    dispatcher
                                                                    depth
                                                                    newd
                                                                    ('#<procedure #7 ##cdr>
                                                                     lst2.996)))
                                                                 #!void)))
                                                         #!void))))
                                           (loop2.995
                                            dispatcher
                                            depth
                                            newd
                                            temp.994))))))))
                   (fill! dispatcher depth newd number))))
            newd))))))

(define globalize-dispatcher
  (lambda (dispatcher)
    (let ((size ('#<procedure #29 ##vector-length> *classes*)))
      (let ((newd ((Class-allocator Global-Dispatcher-class) size)))
        (let ((begin-temp.201
               ('#<procedure #33 ##vector-set!>
                newd
                1
                Global-Dispatcher-find-method)))
          (let ((begin-temp.200
                 (letrec ((do-temp.196
                           (lambda (size newd i)
                             (if ('#<procedure #36 ##fx>=> i size)
                                 #!void
                                 (let ((begin-temp.197
                                        (set-Global-Dispatcher-method!
                                         newd
                                         i
                                         #f)))
                                   (let ((i ('#<procedure #21 ##fx+> i 1)))
                                     (if ('#<procedure #36 ##fx>=> i size)
                                         #!void
                                         (let ((begin-temp.197
                                                (set-Global-Dispatcher-method!
                                                 newd
                                                 i
                                                 #f)))
                                           (do-temp.196
                                            size
                                            newd
                                            ('#<procedure #21 ##fx+>
                                             i
                                             1))))))))))
                   (do-temp.196 size newd 0))))
            (let ((begin-temp.199
                   (letrec ((fill! (lambda (dispatcher newd cn)
                                     (let ((cl ('#<procedure #32 ##vector-ref>
                                                *classes*
                                                cn)))
                                       (let ((begin-temp.198
                                              (set-Global-Dispatcher-method!
                                               newd
                                               cn
                                               (find-method1 dispatcher cl))))
                                         (let ((temp.999
                                                (Class-subclass-numbers cl)))
                                           (letrec ((loop2.1000
                                                     (lambda (dispatcher
                                                              newd
                                                              lst2.1001)
                                                       (if ('#<procedure #4 ##pair?>
                                                            lst2.1001)
                                                           (let ((x.1002 (fill! dispatcher
                                                                                newd
                                                                                ('#<procedure #6 ##car>
                                                                                 lst2.1001))))
                                                             (let ((lst2.1001
                                                                    ('#<procedure #7 ##cdr>
                                                                     lst2.1001)))
                                                               (if ('#<procedure #4 ##pair?>
                                                                    lst2.1001)
                                                                   (let ((x.1002 (fill! dispatcher
                                                                                        newd
                                                                                        ('#<procedure #6 ##car>
                                                                                         lst2.1001))))
                                                                     (loop2.1000
                                                                      dispatcher
                                                                      newd
                                                                      ('#<procedure #7 ##cdr>
                                                                       lst2.1001)))
                                                                   #!void)))
                                                           #!void))))
                                             (loop2.1000
                                              dispatcher
                                              newd
                                              temp.999))))))))
                     (fill! dispatcher
                            newd
                            ('#<procedure #32 ##vector-ref> Object-class 2)))))
              newd)))))))

(define Global-Dispatcher-compress-dispatcher! (lambda (d level top-class) d))

(define Immediate-Dispatcher-compress-dispatcher!
  (lambda (d level top-class) d))

(define Indexed-Dispatcher-compress-dispatcher! (lambda (d level top-class) d))

(define Tracing-Dispatcher-compress-dispatcher! (lambda (d level top-class) d))

(define Subclass-Dispatcher-compress-dispatcher!
  (lambda (d level top-class)
    (if ('#<procedure #49 ##fx<=> level 0)
        (if ('#<procedure #3 ##eq?> top-class Object-class)
            (globalize-dispatcher d)
            (really-indexize-dispatcher d top-class))
        (let ((no-d (compress-dispatcher!
                     (Subclass-Dispatcher-no d)
                     ('#<procedure #39 ##fx-> level 1)
                     top-class)))
          (if (or (Indexed-Dispatcher? no-d) (Global-Dispatcher? no-d))
              (if ('#<procedure #3 ##eq?> top-class Object-class)
                  (globalize-dispatcher d)
                  (really-indexize-dispatcher d top-class))
              (let ((yes-d (compress-dispatcher!
                            (Subclass-Dispatcher-yes d)
                            ('#<procedure #39 ##fx-> level 1)
                            (let ((i (Subclass-Dispatcher-class-number d)))
                              ('#<procedure #32 ##vector-ref> *classes* i)))))
                (if (and (Indexed-Dispatcher? yes-d)
                         ('#<procedure #50 ##fx=>
                          (Subclass-Dispatcher-class-number d)
                          (Indexed-Dispatcher-class-number yes-d)))
                    (let ((begin-temp.202
                           (set-Indexed-Dispatcher-no! yes-d no-d)))
                      yes-d)
                    (let ((begin-temp.204
                           (set-Subclass-Dispatcher-yes! d yes-d)))
                      (let ((begin-temp.203
                             (set-Subclass-Dispatcher-no! d no-d)))
                        d)))))))))

(define Handy-Class-generate-accompanying-functions
  (lambda (class class-options)
    ('#<procedure #44 ##quasi-list>
     'begin
     (generate-accessors class class-options)
     (generate-predicate class class-options)
     (generate-maker class class-options)
     (generate-allocator class class-options)
     (generate-coercer class class-options))))

(define Handy-Class-generate-predicate
  (lambda (class class-options)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (let ((class-variable (symbol-concatenate classname '- 'class)))
        ('#<procedure #44 ##quasi-list>
         'meroon-define
         (symbol-concatenate classname "?")
         ('#<procedure #44 ##quasi-list> 'create-predicate class-variable))))))

(define generate-predicate Handy-Class-generate-predicate)

(set! generate-predicate generate-predicate)

'generate-predicate

(define Handy-Class-generate-coercer
  (lambda (class class-options)
    (let ((name ('#<procedure #32 ##vector-ref> class 1)))
      (let ((coercer-name (symbol-concatenate '- '> name)))
        (if (find-option-present? 'virtual class-options)
            ''**no-coercer**
            ('#<procedure #44 ##quasi-list>
             'begin
             ('#<procedure #44 ##quasi-list>
              'define-generic
              ('#<procedure #43 ##quasi-cons> coercer-name '((o))))
             ('#<procedure #43 ##quasi-cons>
              'define-method
              ('#<procedure #43 ##quasi-cons>
               ('#<procedure #44 ##quasi-list>
                coercer-name
                ('#<procedure #44 ##quasi-list> 'o name))
               '(o)))))))))

(define generate-coercer Handy-Class-generate-coercer)

(set! generate-coercer generate-coercer)

'generate-coercer

(define Handy-Class-generate-allocator
  (lambda (class class-options)
    (let ((name ('#<procedure #32 ##vector-ref> class 1)))
      (let ((class-variable (symbol-concatenate name '- 'class)))
        (if (find-option-present? 'virtual class-options)
            ''**no-allocator**
            ('#<procedure #44 ##quasi-list>
             'meroon-define
             (symbol-concatenate 'allocate- name)
             ('#<procedure #44 ##quasi-list>
              'Class-allocator
              class-variable)))))))

(define generate-allocator
  (lambda (class class-options)
    (if (Handy-Class? class)
        (Handy-Class-generate-allocator class class-options)
        (if (Class? class) #t #!void))))

(set! generate-allocator generate-allocator)

'generate-allocator

(define Handy-Class-generate-maker
  (lambda (class class-options)
    (let ((classname (Class-name class)))
      (let ((class-variable (symbol-concatenate classname '- 'class)))
        (if (find-option-present? 'virtual class-options)
            ''**no-maker**
            ('#<procedure #44 ##quasi-list>
             'meroon-define
             (symbol-concatenate 'make- classname)
             ('#<procedure #44 ##quasi-list> 'make-maker class-variable)))))))

(define generate-maker Handy-Class-generate-maker)

(set! generate-maker generate-maker)

'generate-maker

(define Handy-Class-generate-accessors
  (lambda (class class-options)
    ('#<procedure #43 ##quasi-cons>
     'begin
     ('#<procedure #43 ##quasi-cons>
      #t
      (meroon-reduce
       (lambda (code field)
         (if ('#<procedure #50 ##fx=>
              (Field-class-number field)
              (Class-number class))
             ('#<procedure #10 ##cons>
              (Field-generate-Handy-accessors field class)
              code)
             code))
       '()
       (Class-fields class))))))

(define Field-generate-Handy-accessors
  (lambda (field class)
    ((if (Mono-Field? field)
         Mono-Field-generate-Handy-accessors
         (if (Poly-Field? field)
             Poly-Field-generate-Handy-accessors
             internal-meroon-error))
     field
     class)))

(set! Field-generate-Handy-accessors Field-generate-Handy-accessors)

'Field-generate-Handy-accessors

(define default-Field-generate-Handy-accessors internal-meroon-error)

(define Mono-Field-generate-Handy-accessors
  (lambda (field class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (let ((class-variable (symbol-concatenate classname '- 'class)))
        (let ((fieldname ('#<procedure #32 ##vector-ref> field 1)))
          ('#<procedure #43 ##quasi-cons>
           'begin
           ('#<procedure #43 ##quasi-cons>
            ('#<procedure #44 ##quasi-list>
             'meroon-define
             (symbol-concatenate 'get- fieldname)
             ('#<procedure #44 ##quasi-list>
              'Mono-Field-create-careful-reader
              class-variable
              ('#<procedure #44 ##quasi-list> 'quote fieldname)))
            (if (Field-immutable? field)
                '()
                ('#<procedure #44 ##quasi-list>
                 ('#<procedure #44 ##quasi-list>
                  'meroon-define
                  (symbol-concatenate 'set- fieldname "!")
                  ('#<procedure #44 ##quasi-list>
                   'Mono-Field-create-careful-writer
                   class-variable
                   ('#<procedure #44 ##quasi-list> 'quote fieldname))))))))))))

(define Poly-Field-generate-Handy-accessors
  (lambda (field class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (let ((class-variable (symbol-concatenate classname '- 'class)))
        (let ((fieldname ('#<procedure #32 ##vector-ref> field 1)))
          ('#<procedure #43 ##quasi-cons>
           'begin
           ('#<procedure #43 ##quasi-cons>
            ('#<procedure #44 ##quasi-list>
             'meroon-define
             (symbol-concatenate 'get- fieldname '- 'length)
             ('#<procedure #44 ##quasi-list>
              'Poly-Field-create-careful-lengther
              class-variable
              ('#<procedure #44 ##quasi-list> 'quote fieldname)))
            ('#<procedure #43 ##quasi-cons>
             ('#<procedure #44 ##quasi-list>
              'meroon-define
              (symbol-concatenate 'get- fieldname)
              ('#<procedure #44 ##quasi-list>
               'Poly-Field-create-careful-reader
               class-variable
               ('#<procedure #44 ##quasi-list> 'quote fieldname)))
             (if (Field-immutable? field)
                 '()
                 ('#<procedure #44 ##quasi-list>
                  ('#<procedure #44 ##quasi-list>
                   'meroon-define
                   (symbol-concatenate 'set- fieldname "!")
                   ('#<procedure #44 ##quasi-list>
                    'Poly-Field-create-careful-writer
                    class-variable
                    ('#<procedure #44 ##quasi-list>
                     'quote
                     fieldname)))))))))))))

(define MeroonV2-Class-generate-accessors
  (lambda (class class-options)
    ('#<procedure #43 ##quasi-cons>
     'begin
     ('#<procedure #43 ##quasi-cons>
      #t
      (let ((temp.1004 (Class-fields class)))
        (letrec ((loop2.1005
                  (lambda (class lst2.1006)
                    (if ('#<procedure #4 ##pair?> lst2.1006)
                        (let ((x.1007 (let ((field ('#<procedure #6 ##car>
                                                    lst2.1006)))
                                        (Field-generate-MeroonV2-accessors
                                         field
                                         class))))
                          ('#<procedure #10 ##cons>
                           x.1007
                           (loop2.1005
                            class
                            ('#<procedure #7 ##cdr> lst2.1006))))
                        '()))))
          (loop2.1005 class temp.1004)))))))

(define generate-accessors
  (lambda (class class-options)
    (if (MeroonV2-Class? class)
        (MeroonV2-Class-generate-accessors class class-options)
        (if (Handy-Class? class)
            (Handy-Class-generate-accessors class class-options)
            (if (Class? class)
                ''**no-accessors**
                (report-meroon-error
                 'internal
                 'generate-accessors
                 "Unknown metaclass"
                 class
                 class-options))))))

(set! generate-accessors generate-accessors)

'generate-accessors

(define Class-generate-accessors
  (lambda (class class-options) ''**no-accessors**))

(define Field-generate-MeroonV2-accessors
  (lambda (field class)
    ((if (Mono-Field? field)
         Mono-Field-generate-MeroonV2-accessors
         (if (Poly-Field? field)
             Poly-Field-generate-MeroonV2-accessors
             internal-meroon-error))
     field
     class)))

(set! Field-generate-MeroonV2-accessors Field-generate-MeroonV2-accessors)

'Field-generate-MeroonV2-accessors

(define default-Field-generate-MeroonV2-accessors internal-meroon-error)

(define Mono-Field-generate-MeroonV2-accessors
  (lambda (field class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (let ((class-variable (symbol-concatenate classname '- 'class)))
        (let ((fieldname ('#<procedure #32 ##vector-ref> field 1)))
          ('#<procedure #43 ##quasi-cons>
           'begin
           ('#<procedure #43 ##quasi-cons>
            ('#<procedure #44 ##quasi-list>
             'meroon-define
             (symbol-concatenate classname '- fieldname)
             ('#<procedure #44 ##quasi-list>
              'Mono-Field-create-careful-reader
              class-variable
              ('#<procedure #44 ##quasi-list> 'quote fieldname)))
            (if (Field-immutable? field)
                '()
                ('#<procedure #44 ##quasi-list>
                 ('#<procedure #44 ##quasi-list>
                  'meroon-define
                  (symbol-concatenate 'set- classname '- fieldname "!")
                  ('#<procedure #44 ##quasi-list>
                   'Mono-Field-create-careful-writer
                   class-variable
                   ('#<procedure #44 ##quasi-list> 'quote fieldname))))))))))))

(define Poly-Field-generate-MeroonV2-accessors
  (lambda (field class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (let ((class-variable (symbol-concatenate classname '- 'class)))
        (let ((fieldname ('#<procedure #32 ##vector-ref> field 1)))
          ('#<procedure #43 ##quasi-cons>
           'begin
           ('#<procedure #43 ##quasi-cons>
            ('#<procedure #44 ##quasi-list>
             'meroon-define
             (symbol-concatenate classname '- fieldname '- 'length)
             ('#<procedure #44 ##quasi-list>
              'Poly-Field-create-careful-lengther
              class-variable
              ('#<procedure #44 ##quasi-list> 'quote fieldname)))
            ('#<procedure #43 ##quasi-cons>
             ('#<procedure #44 ##quasi-list>
              'meroon-define
              (symbol-concatenate classname '- fieldname)
              ('#<procedure #44 ##quasi-list>
               'Poly-Field-create-careful-reader
               class-variable
               ('#<procedure #44 ##quasi-list> 'quote fieldname)))
             (if (Field-immutable? field)
                 '()
                 ('#<procedure #44 ##quasi-list>
                  ('#<procedure #44 ##quasi-list>
                   'meroon-define
                   (symbol-concatenate 'set- classname '- fieldname "!")
                   ('#<procedure #44 ##quasi-list>
                    'Poly-Field-create-careful-writer
                    class-variable
                    ('#<procedure #44 ##quasi-list>
                     'quote
                     fieldname)))))))))))))

(define check-and-process-class-definition
  (lambda (definition)
    (let ((begin-temp.207
           (if ('#<procedure #36 ##fx>=>
                ('#<procedure #23 length> definition)
                3)
               #!void
               (report-meroon-error
                'Syntax
                'define-class
                "Incomplete definition"
                definition))))
      (let ((class-options ('#<procedure #65 ##cdddr> definition))
            (own-field-descs ('#<procedure #66 ##caddr> definition))
            (super-name ('#<procedure #67 ##cadr> definition))
            (name ('#<procedure #6 ##car> definition)))
        (let ((begin-temp.206
               (if ('#<procedure #16 ##symbol?> name)
                   #!void
                   (report-meroon-error
                    'Syntax
                    'define-class
                    "Incorrect name for a class"
                    name))))
          (let ((begin-temp.205
                 (if (or ('#<procedure #16 ##symbol?> super-name)
                         (and ('#<procedure #4 ##pair?> super-name)
                              (and ('#<procedure #16 ##symbol?>
                                    ('#<procedure #6 ##car> super-name))
                                   ('#<procedure #24 ##null?>
                                    ('#<procedure #7 ##cdr> super-name)))))
                     #!void
                     (report-meroon-error
                      'Syntax
                      'define-class
                      "Incorrect name for a super class"
                      super-name))))
            (let ((sn (if ('#<procedure #4 ##pair?> super-name)
                          ('#<procedure #6 ##car> super-name)
                          super-name)))
              (let ((super-class
                     (symbol->class sn complain-if-missing-super-class)))
                (process-class-definition
                 name
                 super-class
                 own-field-descs
                 class-options)))))))))

(define make-complainer-if-missing-class
  (lambda (msg)
    (lambda (name) (report-meroon-error 'Syntax 'define-class msg name))))

(define complain-if-missing-super-class
  (lambda (name)
    (report-meroon-error 'Syntax 'define-class "No such super class" name)))

(define complain-if-missing-meta-class
  (lambda (name)
    (report-meroon-error 'Syntax 'define-class "No such meta class" name)))

(define complain-if-missing-super-view
  (lambda (name)
    (report-meroon-error 'Syntax 'define-view "No such super view" name)))

(define *default-class-options* '())

(define *standard-class-metaclass-name* 'MeroonV2-Class)

(define *standard-mono-field-metaclass-name* 'Mono-Field)

(define *standard-poly-field-metaclass-name* 'Poly-Field)

(define process-class-definition
  (lambda (name super-class own-field-descs class-options)
    (let ((metaclass-options
           (let ((kw+values
                  (find-option-plus-values 'metaclass class-options)))
             (if ('#<procedure #4 ##pair?> kw+values)
                 ('#<procedure #7 ##cdr> kw+values)
                 ('#<procedure #34 ##list> *standard-class-metaclass-name*)))))
      (let ((metaclass-name ('#<procedure #6 ##car> metaclass-options)))
        (let ((metaclass-allocation-args
               ('#<procedure #7 ##cdr> metaclass-options)))
          (let ((metaclass
                 (symbol->class
                  metaclass-name
                  complain-if-missing-meta-class)))
            (let ((depth ('#<procedure #21 ##fx+>
                          1
                          ('#<procedure #32 ##vector-ref> super-class 4))))
              (let ((class ('#<procedure #8 apply>
                            (Class-allocator metaclass)
                            ('#<procedure #21 ##fx+>
                             1
                             ('#<procedure #38 ##fx*> 2 depth))
                            metaclass-allocation-args)))
                (let ((begin-temp.209
                       ('#<procedure #33 ##vector-set!> class 1 name)))
                  (let ((begin-temp.208
                         (let ((scn ('#<procedure #32 ##vector-ref>
                                     super-class
                                     2)))
                           ('#<procedure #33 ##vector-set!> class 5 scn))))
                    (Class-parse!
                     class
                     own-field-descs
                     ('#<procedure #46 append> class-options '()))))))))))))

(define Class-parse!
  (lambda (class own-fields-desc class-options)
    (let ((class-variable (symbol-concatenate (Class-name class) '- 'class)))
      (let ((super-class (Class-super-class class)))
        (let ((super-fields (Class-fields (Class-super-class class))))
          (let ((preceding-fields
                 ('#<procedure #10 ##cons>
                  'fields
                  ('#<procedure #46 append>
                   (letrec ((loop2.1010
                             (lambda (lst2.1011)
                               (if ('#<procedure #4 ##pair?> lst2.1011)
                                   (let ((x.1012 (instance-clone
                                                  ('#<procedure #6 ##car>
                                                   lst2.1011))))
                                     ('#<procedure #10 ##cons>
                                      x.1012
                                      (loop2.1010
                                       ('#<procedure #7 ##cdr> lst2.1011))))
                                   '()))))
                     (loop2.1010 super-fields))
                   '()))))
            (let ((own-fields-code
                   (letrec ((scan (lambda (class-options
                                           preceding-fields
                                           descs)
                                    (if ('#<procedure #4 ##pair?> descs)
                                        (let ((field-code
                                               (parse-field!
                                                ('#<procedure #6 ##car> descs)
                                                preceding-fields
                                                class-options)))
                                          ('#<procedure #10 ##cons>
                                           field-code
                                           (scan class-options
                                                 preceding-fields
                                                 ('#<procedure #7 ##cdr>
                                                  descs))))
                                        '()))))
                     (scan class-options preceding-fields own-fields-desc))))
              (let ((begin-temp.212
                     (let ((fields ('#<procedure #7 ##cdr> preceding-fields)))
                       ('#<procedure #33 ##vector-set!> class 3 fields))))
                (if (find-option-present? 'prototype class-options)
                    (let ((begin-temp.210
                           (if ((lambda (name . default)
                                  (letrec ((scan (lambda (name default i)
                                                   (let ((class ('#<procedure #32 ##vector-ref>
                                                                 *classes*
                                                                 i)))
                                                     (if ('#<procedure #3 ##eq?>
                                                          ('#<procedure #32 ##vector-ref>
                                                           class
                                                           1)
                                                          name)
                                                         class
                                                         (if ('#<procedure #53 ##fx>>
                                                              i
                                                              0)
                                                             (scan name
                                                                   default
                                                                   ('#<procedure #39 ##fx->
                                                                    i
                                                                    1))
                                                             (if ('#<procedure #4 ##pair?>
                                                                  default)
                                                                 (('#<procedure #6 ##car>
                                                                   default)
                                                                  name)
                                                                 (report-meroon-error
                                                                  'Anomaly
                                                                  'symbol->class
                                                                  "No such class"
                                                                  name))))))))
                                    (scan name
                                          default
                                          ('#<procedure #39 ##fx->
                                           *class-number*
                                           1))))
                                ('#<procedure #32 ##vector-ref> class 1)
                                (lambda (name) #f))
                               #!void
                               (register-class
                                meroon-revision
                                class
                                (Class-name class)
                                super-class
                                'void))))
                      (generate-class-prototype-check class class-options))
                    (let ((begin-temp.211
                           (register-class
                            meroon-revision
                            class
                            (Class-name class)
                            super-class
                            'void)))
                      (generate-class-registration
                       class
                       own-fields-code
                       class-options)))))))))))

(define generate-class-registration
  (lambda (class own-fields-code class-options)
    (let ((name (Class-name class)))
      (let ((class-variable (symbol-concatenate name '- 'class)))
        ('#<procedure #44 ##quasi-list>
         'begin
         (generate-class-definition class own-fields-code class-options)
         (generate-accompanying-functions class class-options)
         ('#<procedure #44 ##quasi-list> 'quote name))))))

(define generate-accompanying-functions
  (lambda (class class-options)
    (if (Handy-Class? class)
        (Handy-Class-generate-accompanying-functions class class-options)
        (if (Class? class)
            ''**no-accompanying-functions**
            (report-meroon-error
             'internal
             'domain
             "No such method"
             'generate-accompanying-functions)))))

(set! generate-accompanying-functions generate-accompanying-functions)

'generate-accompanying-functions

(define Class-generate-accompanying-functions
  (lambda (class class-options) ''**no-accompanying-functions**))

(define generate-class-definition
  (lambda (class own-fields-code class-options)
    (let ((name (Class-name class)))
      (let ((class-variable (symbol-concatenate name '- 'class)))
        (let ((metaclass-name
               (symbol-concatenate
                (Class-name
                 ('#<procedure #32 ##vector-ref>
                  *classes*
                  ('#<procedure #32 ##vector-ref> class 0)))
                '-
                'class)))
          (let ((super-class (Class-super-class class)))
            (let ((super-name (Class-name super-class)))
              (let ((super-variable (symbol-concatenate super-name '- 'class)))
                (let ((metaclass-options
                       (let ((kw+values
                              (find-option-plus-values
                               'metaclass
                               class-options)))
                         (if ('#<procedure #4 ##pair?> kw+values)
                             ('#<procedure #7 ##cdr> kw+values)
                             '(Class)))))
                  (let ((metaclass-allocation-args
                         ('#<procedure #7 ##cdr> metaclass-options)))
                    ('#<procedure #44 ##quasi-list>
                     'meroon-define
                     class-variable
                     ('#<procedure #44 ##quasi-list>
                      'initialize!
                      ('#<procedure #44 ##quasi-list>
                       'fill-other-fields!
                       ('#<procedure #44 ##quasi-list>
                        'register-class
                        ('#<procedure #44 ##quasi-list> 'quote meroon-revision)
                        ('#<procedure #43 ##quasi-cons>
                         ('#<procedure #44 ##quasi-list>
                          'Class-allocator
                          metaclass-name)
                         ('#<procedure #43 ##quasi-cons>
                          (Class-suprel-length class)
                          metaclass-allocation-args))
                        ('#<procedure #44 ##quasi-list> 'quote name)
                        super-variable
                        ('#<procedure #43 ##quasi-cons>
                         '(let () (declare (standard-bindings)) list)
                         own-fields-code)))))))))))))))

(define generate-class-prototype-check
  (lambda (class class-options)
    (let ((super-name (Class-name (Class-super-class class)))
          (name (Class-name class)))
      ('#<procedure #44 ##quasi-list>
       'let
       ('#<procedure #44 ##quasi-list>
        ('#<procedure #44 ##quasi-list>
         'c
         ('#<procedure #43 ##quasi-cons>
          'symbol->class
          ('#<procedure #43 ##quasi-cons>
           ('#<procedure #44 ##quasi-list> 'quote name)
           '((lambda (name) #f))))))
       ('#<procedure #44 ##quasi-list>
        'if
        'c
        ('#<procedure #44 ##quasi-list>
         'check-fields
         'c
         ('#<procedure #44 ##quasi-list> 'quote super-name)
         ('#<procedure #44 ##quasi-list>
          'quote
          (let ((temp.1014 (Class-fields class)))
            (letrec ((loop2.1015
                      (lambda (lst2.1016)
                        (if ('#<procedure #4 ##pair?> lst2.1016)
                            (let ((x.1017 (let ((f ('#<procedure #6 ##car>
                                                    lst2.1016)))
                                            ('#<procedure #10 ##cons>
                                             (Field-name f)
                                             (Class-name
                                              ('#<procedure #32 ##vector-ref>
                                               *classes*
                                               ('#<procedure #32 ##vector-ref>
                                                f
                                                0)))))))
                              ('#<procedure #10 ##cons>
                               x.1017
                               (loop2.1015
                                ('#<procedure #7 ##cdr> lst2.1016))))
                            '()))))
              (loop2.1015 temp.1014))))))
       ('#<procedure #44 ##quasi-list> 'quote name)))))

(define parse-field!
  (lambda (field-desc preceding-fields class-options)
    (let ((path-length
           ('#<procedure #21 ##fx+> 1 (count-Poly-Fields preceding-fields))))
      (if ('#<procedure #16 ##symbol?> field-desc)
          (let ((field-class
                 (symbol->class *standard-mono-field-metaclass-name*)))
            (let ((field ((Class-allocator field-class) path-length)))
              (Field-parse!
               field
               ('#<procedure #10 ##cons> field-desc class-options)
               preceding-fields)))
          (if (and ('#<procedure #4 ##pair?> field-desc)
                   ('#<procedure #4 ##pair?>
                    ('#<procedure #7 ##cdr> field-desc)))
              (let ((case-temp.214 ('#<procedure #6 ##car> field-desc)))
                (if (or ('#<procedure #3 ##eq?> case-temp.214 '=)
                        ('#<procedure #3 ##eq?> case-temp.214 'mono))
                    (let ((begin-temp.215
                           (if (let ((kw+values
                                      (find-option-plus-values
                                       'metaclass
                                       field-desc)))
                                 (if ('#<procedure #4 ##pair?> kw+values)
                                     ('#<procedure #7 ##cdr> kw+values)
                                     ((lambda ignore #f) 'metaclass)))
                               (report-meroon-error
                                'Syntax
                                'define-class
                                "Superfluous (or contradictory) :metaclass option"
                                field-desc)
                               #!void)))
                      (let ((field-class
                             (symbol->class
                              *standard-mono-field-metaclass-name*)))
                        (let ((field ((Class-allocator field-class)
                                      path-length)))
                          (Field-parse!
                           field
                           ('#<procedure #46 append>
                            ('#<procedure #7 ##cdr> field-desc)
                            class-options)
                           preceding-fields))))
                    (if (or ('#<procedure #3 ##eq?> case-temp.214 '*)
                            ('#<procedure #3 ##eq?> case-temp.214 'poly))
                        (let ((begin-temp.216
                               (if (let ((kw+values
                                          (find-option-plus-values
                                           'metaclass
                                           field-desc)))
                                     (if ('#<procedure #4 ##pair?> kw+values)
                                         ('#<procedure #7 ##cdr> kw+values)
                                         ((lambda ignore #f) 'metaclass)))
                                   (report-meroon-error
                                    'Syntax
                                    'define-class
                                    "Superfluous (or contradictory) :metaclass option"
                                    field-desc)
                                   #!void)))
                          (let ((field-class
                                 (symbol->class
                                  *standard-poly-field-metaclass-name*)))
                            (let ((field ((Class-allocator field-class)
                                          path-length)))
                              (Field-parse!
                               field
                               ('#<procedure #46 append>
                                ('#<procedure #7 ##cdr> field-desc)
                                class-options)
                               preceding-fields))))
                        (let ((values (let ((kw+values
                                             (find-option-plus-values
                                              'metaclass
                                              field-desc)))
                                        (if ('#<procedure #4 ##pair?>
                                             kw+values)
                                            ('#<procedure #7 ##cdr> kw+values)
                                            meroon-option-not-there))))
                          (if ('#<procedure #4 ##pair?> values)
                              (let ((field ('#<procedure #8 apply>
                                            (Class-allocator
                                             (symbol->class
                                              ('#<procedure #6 ##car> values)))
                                            path-length
                                            ('#<procedure #7 ##cdr> values))))
                                (Field-parse!
                                 field
                                 ('#<procedure #46 append>
                                  field-desc
                                  class-options)
                                 preceding-fields))
                              (report-meroon-error
                               'Syntax
                               'define-class
                               "Invalid field descriptor"
                               field-desc))))))
              (report-meroon-error
               'Syntax
               'define-class
               "Invalid field description"
               field-desc))))))

(define Field-parse!
  (lambda (field field-options preceding-fields)
    (let ((name ('#<procedure #6 ##car> field-options)))
      (let ((begin-temp.225
             (if ('#<procedure #16 ##symbol?> name)
                 #!void
                 (report-meroon-error
                  'Syntax
                  'define-class
                  "Not a field name"
                  name))))
        (let ((begin-temp.224
               (if (sequence-find
                    name
                    ('#<procedure #7 ##cdr> preceding-fields)
                    Field-name
                    (lambda (field) #t)
                    (lambda (name) #f))
                   (report-meroon-error
                    'Syntax
                    'define-class
                    "Field redefinition"
                    name)
                   #!void)))
          (let ((begin-temp.223
                 ('#<procedure #33 ##vector-set!> field 1 name)))
            (let ((begin-temp.222
                   (set-important-offsets!
                    field
                    ('#<procedure #7 ##cdr> preceding-fields))))
              (let ((begin-temp.221
                     (append! preceding-fields
                              ('#<procedure #34 ##list> field))))
                (let ((begin-temp.220
                       (if (and (find-option-present? 'immutable field-options)
                                (find-option-present? 'mutable field-options))
                           (report-meroon-error
                            'Syntax
                            'define-class
                            "Incompatible mutability options"
                            field-options)
                           #!void)))
                  (let ((begin-temp.219
                         (if (field-defined? field 'immutable?)
                             #!void
                             (let ((bool (find-option-present?
                                          'immutable
                                          field-options)))
                               ('#<procedure #33 ##vector-set!>
                                field
                                2
                                bool)))))
                    (let ((initer (find-option-single-value
                                   'initializer
                                   field-options
                                   (lambda (kw) #f)))
                          (uninit (find-option-present?
                                   'maybe-uninitialized
                                   field-options)))
                      (let ((begin-temp.218
                             (let ((bool (or initer
                                             ('#<procedure #5 ##not> uninit))))
                               ('#<procedure #33 ##vector-set!>
                                field
                                4
                                bool))))
                        (let ((begin-temp.217
                               (if initer
                                   (let ((fun (lambda ignore
                                                (report-meroon-error
                                                 'Syntax
                                                 'instantiate
                                                 "Unavailable initializer for this field"
                                                 field))))
                                     ('#<procedure #33 ##vector-set!>
                                      field
                                      5
                                      fun))
                                   #!void)))
                          ('#<procedure #43 ##quasi-cons>
                           'instantiate
                           ('#<procedure #43 ##quasi-cons>
                            (Class-name
                             ('#<procedure #32 ##vector-ref>
                              *classes*
                              ('#<procedure #32 ##vector-ref> field 0)))
                            ('#<procedure #43 ##quasi-cons>
                             ('#<procedure #27 string->keyword>
                              ('#<procedure #17 symbol->string> 'name))
                             ('#<procedure #43 ##quasi-cons>
                              ('#<procedure #44 ##quasi-list> 'quote name)
                              ('#<procedure #43 ##quasi-cons>
                               ('#<procedure #27 string->keyword>
                                ('#<procedure #17 symbol->string> 'immutable?))
                               ('#<procedure #43 ##quasi-cons>
                                (Field-immutable? field)
                                ('#<procedure #43 ##quasi-cons>
                                 ('#<procedure #27 string->keyword>
                                  ('#<procedure #17 symbol->string>
                                   'initialized?))
                                 ('#<procedure #43 ##quasi-cons>
                                  (Field-initialized? field)
                                  ('#<procedure #45 ##quasi-append>
                                   (if initer
                                       ('#<procedure #44 ##quasi-list>
                                        ('#<procedure #27 string->keyword>
                                         ('#<procedure #17 symbol->string>
                                          'initializer))
                                        initer)
                                       '())
                                   ('#<procedure #43 ##quasi-cons>
                                    ('#<procedure #27 string->keyword>
                                     ('#<procedure #17 symbol->string> 'path))
                                    (let ((limit (Field-path-length field)))
                                      (letrec ((enum (lambda (field limit i)
                                                       (if ('#<procedure #20 ##fx<>
                                                            i
                                                            limit)
                                                           ('#<procedure #10 ##cons>
                                                            (Field-path
                                                             field
                                                             i)
                                                            (let ((i ('#<procedure #21 ##fx+>
                                                                      i
                                                                      1)))
                                                              (if ('#<procedure #20 ##fx<>
                                                                   i
                                                                   limit)
                                                                  ('#<procedure #10 ##cons>
                                                                   (Field-path
                                                                    field
                                                                    i)
                                                                   (enum field
                                                                         limit
                                                                         ('#<procedure #21 ##fx+>
                                                                          i
                                                                          1)))
                                                                  '())))
                                                           '()))))
                                        (enum field
                                              limit
                                              0))))))))))))))))))))))))))

(define extract-discriminant
  (lambda (specs)
    (if ('#<procedure #4 ##pair?> specs)
        (if (or (let ((thing ('#<procedure #6 ##car> specs)))
                  ('#<procedure #3 ##eq?> thing #!optional))
                (or (let ((thing ('#<procedure #6 ##car> specs)))
                      ('#<procedure #3 ##eq?> thing #!rest))
                    (let ((thing ('#<procedure #6 ##car> specs)))
                      ('#<procedure #3 ##eq?> thing #!key))))
            '()
            (if ('#<procedure #4 ##pair?> ('#<procedure #6 ##car> specs))
                ('#<procedure #10 ##cons>
                 ('#<procedure #6 ##car> specs)
                 (extract-discriminant ('#<procedure #7 ##cdr> specs)))
                (extract-discriminant ('#<procedure #7 ##cdr> specs))))
        '())))

(define reduce-variables
  (lambda (specs)
    (if ('#<procedure #4 ##pair?> specs)
        (if (or (let ((thing ('#<procedure #6 ##car> specs)))
                  ('#<procedure #3 ##eq?> thing #!optional))
                (or (let ((thing ('#<procedure #6 ##car> specs)))
                      ('#<procedure #3 ##eq?> thing #!rest))
                    (let ((thing ('#<procedure #6 ##car> specs)))
                      ('#<procedure #3 ##eq?> thing #!key))))
            (if ('#<procedure #4 ##pair?> ('#<procedure #7 ##cdr> specs))
                (letrec ((search-symbol
                          (lambda (specs s)
                            (if ('#<procedure #16 ##symbol?> s)
                                s
                                (if ('#<procedure #4 ##pair?> s)
                                    (search-symbol
                                     specs
                                     ('#<procedure #6 ##car> s))
                                    (report-meroon-error
                                     'Syntax
                                     'define-generic
                                     "Bad variable list"
                                     specs))))))
                  (search-symbol specs ('#<procedure #67 ##cadr> specs)))
                (report-meroon-error
                 'Syntax
                 'define-generic
                 "Very bad variable list"
                 specs))
            (if ('#<procedure #4 ##pair?> ('#<procedure #6 ##car> specs))
                ('#<procedure #10 ##cons>
                 ('#<procedure #47 ##caar> specs)
                 (reduce-variables ('#<procedure #7 ##cdr> specs)))
                ('#<procedure #10 ##cons>
                 ('#<procedure #6 ##car> specs)
                 (reduce-variables ('#<procedure #7 ##cdr> specs)))))
        specs)))

(define flat-formals
  (lambda (formals)
    (if ('#<procedure #4 ##pair?> formals)
        ('#<procedure #10 ##cons>
         ('#<procedure #6 ##car> formals)
         (flat-formals ('#<procedure #7 ##cdr> formals)))
        (if ('#<procedure #24 ##null?> formals)
            formals
            ('#<procedure #34 ##list> formals)))))

(define extract-formals
  (lambda (formals)
    (if ('#<procedure #4 ##pair?> formals)
        (if (or (let ((thing ('#<procedure #6 ##car> formals)))
                  ('#<procedure #3 ##eq?> thing #!optional))
                (or (let ((thing ('#<procedure #6 ##car> formals)))
                      ('#<procedure #3 ##eq?> thing #!rest))
                    (let ((thing ('#<procedure #6 ##car> formals)))
                      ('#<procedure #3 ##eq?> thing #!key))))
            (extract-formals ('#<procedure #7 ##cdr> formals))
            (if ('#<procedure #4 ##pair?> ('#<procedure #6 ##car> formals))
                ('#<procedure #10 ##cons>
                 ('#<procedure #47 ##caar> formals)
                 (extract-formals ('#<procedure #7 ##cdr> formals)))
                ('#<procedure #10 ##cons>
                 ('#<procedure #6 ##car> formals)
                 (extract-formals ('#<procedure #7 ##cdr> formals)))))
        (if ('#<procedure #24 ##null?> formals)
            formals
            ('#<procedure #34 ##list> formals)))))

(define rebuild-method-variable-list
  (lambda (specs)
    (if ('#<procedure #4 ##pair?> specs)
        (if (or (let ((thing ('#<procedure #6 ##car> specs)))
                  ('#<procedure #3 ##eq?> thing #!optional))
                (or (let ((thing ('#<procedure #6 ##car> specs)))
                      ('#<procedure #3 ##eq?> thing #!rest))
                    (let ((thing ('#<procedure #6 ##car> specs)))
                      ('#<procedure #3 ##eq?> thing #!key))))
            specs
            (if ('#<procedure #4 ##pair?> ('#<procedure #6 ##car> specs))
                ('#<procedure #10 ##cons>
                 ('#<procedure #47 ##caar> specs)
                 (rebuild-method-variable-list ('#<procedure #7 ##cdr> specs)))
                ('#<procedure #10 ##cons>
                 ('#<procedure #6 ##car> specs)
                 (rebuild-method-variable-list
                  ('#<procedure #7 ##cdr> specs)))))
        specs)))

(define check-generic-definition
  (lambda (call body)
    (if (and ('#<procedure #4 ##pair?> call)
             (and ('#<procedure #16 ##symbol?> ('#<procedure #6 ##car> call))
                  ('#<procedure #4 ##pair?> ('#<procedure #7 ##cdr> call))))
        #f
        (report-meroon-error
         'Syntax
         'define-generic
         "Incorrect definition"
         call))))

(define process-define-generic-form
  (lambda (call body)
    (let ((begin-temp.232 (check-generic-definition call body)))
      (let ((rest-var (gensym))
            (generic (gensym))
            (variables-for-default-method ('#<procedure #7 ##cdr> call))
            (dsssl? ('#<procedure #61 ##box> #f))
            (variables-for-generic
             (reduce-variables ('#<procedure #7 ##cdr> call)))
            (disc-specs (extract-discriminant ('#<procedure #7 ##cdr> call))))
        (let ((begin-temp.231
               (if ('#<procedure #20 ##fx<>
                    ('#<procedure #23 length> disc-specs)
                    1)
                   (report-meroon-error
                    'Syntax
                    'define-generic
                    "No discriminating variable"
                    call)
                   #!void)))
          (let ((begin-temp.230
                 ('#<procedure #63 ##set-box!>
                  dsssl?
                  (or (any? dsssl-optional? ('#<procedure #7 ##cdr> call))
                      (or (any? dsssl-rest? ('#<procedure #7 ##cdr> call))
                          (any? dsssl-key? ('#<procedure #7 ##cdr> call)))))))
            ('#<procedure #44 ##quasi-list>
             'begin
             ('#<procedure #44 ##quasi-list>
              'meroon-define
              ('#<procedure #6 ##car> call)
              ('#<procedure #44 ##quasi-list>
               'let
               ('#<procedure #44 ##quasi-list>
                ('#<procedure #43 ##quasi-cons> generic '('wait)))
               ('#<procedure #44 ##quasi-list>
                'set!
                generic
                ('#<procedure #43 ##quasi-cons>
                 (let ((case-temp.226 ('#<procedure #23 length> disc-specs)))
                   (if ('#<procedure #3 ##eq?> case-temp.226 1)
                       'register-Generic-1
                       'register-Generic-N))
                 ('#<procedure #43 ##quasi-cons>
                  ('#<procedure #44 ##quasi-list> 'quote meroon-revision)
                  ('#<procedure #43 ##quasi-cons>
                   ('#<procedure #44 ##quasi-list>
                    'quote
                    ('#<procedure #6 ##car> call))
                   ('#<procedure #43 ##quasi-cons>
                    (if ('#<procedure #4 ##pair?> body)
                        ('#<procedure #43 ##quasi-cons>
                         'lambda
                         ('#<procedure #43 ##quasi-cons>
                          (if ('#<procedure #62 ##unbox> dsssl?)
                              (rebuild-method-variable-list
                               ('#<procedure #7 ##cdr> call))
                              (flat-formals variables-for-generic))
                          body))
                        'meroon-uninitialized)
                    ('#<procedure #43 ##quasi-cons>
                     ('#<procedure #44 ##quasi-list>
                      'quote
                      ('#<procedure #7 ##cdr> call))
                     (letrec ((loop2.1020
                               (lambda (lst2.1021)
                                 (if ('#<procedure #4 ##pair?> lst2.1021)
                                     (let ((x.1022 (let ((spec ('#<procedure #6 ##car>
                                                                lst2.1021)))
                                                     (if ('#<procedure #4 ##pair?>
                                                          ('#<procedure #7 ##cdr>
                                                           spec))
                                                         ('#<procedure #34 ##list>
                                                          'quote
                                                          ('#<procedure #67 ##cadr>
                                                           spec))
                                                         #f))))
                                       ('#<procedure #10 ##cons>
                                        x.1022
                                        (loop2.1020
                                         ('#<procedure #7 ##cdr> lst2.1021))))
                                     '()))))
                       (loop2.1020 disc-specs))))))))
               ('#<procedure #43 ##quasi-cons>
                'lambda
                ('#<procedure #43 ##quasi-cons>
                 variables-for-generic
                 ('#<procedure #45 ##quasi-append>
                  '()
                  ('#<procedure #44 ##quasi-list>
                   ('#<procedure #45 ##quasi-append>
                    (if ('#<procedure #62 ##unbox> dsssl?) '(apply) '())
                    ('#<procedure #43 ##quasi-cons>
                     ('#<procedure #43 ##quasi-cons>
                      (let ((case-temp.228
                             ('#<procedure #23 length> disc-specs)))
                        (if ('#<procedure #3 ##eq?> case-temp.228 1)
                            'careless-determine-method1
                            'determine-method))
                      ('#<procedure #43 ##quasi-cons>
                       generic
                       (letrec ((loop2.1025
                                 (lambda (lst2.1026)
                                   (if ('#<procedure #4 ##pair?> lst2.1026)
                                       (let ((x.1027 ('#<procedure #9 car>
                                                      ('#<procedure #6 ##car>
                                                       lst2.1026))))
                                         ('#<procedure #10 ##cons>
                                          x.1027
                                          (loop2.1025
                                           ('#<procedure #7 ##cdr>
                                            lst2.1026))))
                                       '()))))
                         (loop2.1025 disc-specs))))
                     (flat-formals variables-for-generic))))))))))))))))

(define *generic-call-counter* 0)

(define check-method-definition
  (lambda (call body)
    (let ((begin-temp.233
           (if (and ('#<procedure #4 ##pair?> call)
                    ('#<procedure #16 ##symbol?>
                     ('#<procedure #6 ##car> call)))
               #!void
               (report-meroon-error
                'Syntax
                'define-method
                "Incorrect definition"
                call))))
      (if ('#<procedure #4 ##pair?> body)
          #f
          (report-meroon-error 'Syntax 'define-method "Empty body" call)))))

(define process-define-method-form
  (lambda (call body)
    (let ((begin-temp.237 (check-method-definition call body)))
      (let ((d (gensym))
            (c (gensym))
            (g (gensym))
            (dsssl? ('#<procedure #61 ##box> #f))
            (variables-for-method ('#<procedure #7 ##cdr> call))
            (variables-for-generic
             (reduce-variables ('#<procedure #7 ##cdr> call)))
            (disc-specs (extract-discriminant ('#<procedure #7 ##cdr> call))))
        (let ((begin-temp.236
               (if ('#<procedure #36 ##fx>=>
                    ('#<procedure #23 length> disc-specs)
                    1)
                   #!void
                   (report-meroon-error
                    'Syntax
                    'define-method
                    "No discriminating variables"
                    call))))
          (let ((begin-temp.235
                 (letrec ((loop2.1030
                           (lambda (disc-specs lst2.1031)
                             (if ('#<procedure #4 ##pair?> lst2.1031)
                                 (let ((x.1032 (let ((spec ('#<procedure #6 ##car>
                                                            lst2.1031)))
                                                 (if ('#<procedure #4 ##pair?>
                                                      ('#<procedure #7 ##cdr>
                                                       spec))
                                                     #f
                                                     (report-meroon-error
                                                      'Syntax
                                                      'define-method
                                                      "No discriminating class"
                                                      disc-specs)))))
                                   (let ((lst2.1031
                                          ('#<procedure #7 ##cdr> lst2.1031)))
                                     (if ('#<procedure #4 ##pair?> lst2.1031)
                                         (let ((x.1032 (let ((spec ('#<procedure #6 ##car>
                                                                    lst2.1031)))
                                                         (if ('#<procedure #4 ##pair?>
                                                              ('#<procedure #7 ##cdr>
                                                               spec))
                                                             #f
                                                             (report-meroon-error
                                                              'Syntax
                                                              'define-method
                                                              "No discriminating class"
                                                              disc-specs)))))
                                           (loop2.1030
                                            disc-specs
                                            ('#<procedure #7 ##cdr>
                                             lst2.1031)))
                                         #!void)))
                                 #!void))))
                   (loop2.1030 disc-specs disc-specs))))
            (let ((begin-temp.234
                   ('#<procedure #63 ##set-box!>
                    dsssl?
                    (or (any? dsssl-optional? ('#<procedure #7 ##cdr> call))
                        (or (any? dsssl-rest? ('#<procedure #7 ##cdr> call))
                            (any? dsssl-key?
                                  ('#<procedure #7 ##cdr> call)))))))
              ('#<procedure #43 ##quasi-cons>
               'register-method
               ('#<procedure #43 ##quasi-cons>
                ('#<procedure #44 ##quasi-list>
                 'quote
                 ('#<procedure #6 ##car> call))
                ('#<procedure #43 ##quasi-cons>
                 ('#<procedure #44 ##quasi-list>
                  'quote
                  ('#<procedure #7 ##cdr> call))
                 ('#<procedure #43 ##quasi-cons>
                  ('#<procedure #44 ##quasi-list> 'quote meroon-revision)
                  ('#<procedure #43 ##quasi-cons>
                   ('#<procedure #44 ##quasi-list>
                    'lambda
                    ('#<procedure #44 ##quasi-list> g c d)
                    ('#<procedure #43 ##quasi-cons>
                     'lambda
                     ('#<procedure #43 ##quasi-cons>
                      (if ('#<procedure #62 ##unbox> dsssl?)
                          (rebuild-method-variable-list variables-for-method)
                          (flat-formals variables-for-generic))
                      ('#<procedure #45 ##quasi-append>
                       (next-method-code-if-needed
                        ('#<procedure #62 ##unbox> dsssl?)
                        ('#<procedure #7 ##cdr> call)
                        body
                        g
                        c
                        d
                        disc-specs)
                       body))))
                   (letrec ((loop2.1035
                             (lambda (lst2.1036)
                               (if ('#<procedure #4 ##pair?> lst2.1036)
                                   (let ((x.1037 (let ((spec ('#<procedure #6 ##car>
                                                              lst2.1036)))
                                                   ('#<procedure #44 ##quasi-list>
                                                    'quote
                                                    ('#<procedure #67 ##cadr>
                                                     spec)))))
                                     ('#<procedure #10 ##cons>
                                      x.1037
                                      (loop2.1035
                                       ('#<procedure #7 ##cdr> lst2.1036))))
                                   '()))))
                     (loop2.1035 disc-specs))))))))))))))

(define process-define-handy-method
  (lambda (call body)
    (let ((begin-temp.241 (check-method-definition call body)))
      (let ((d (gensym))
            (c (gensym))
            (g (gensym))
            (dsssl? ('#<procedure #61 ##box> #f))
            (variables-for-method ('#<procedure #7 ##cdr> call))
            (variables-for-generic
             (reduce-variables ('#<procedure #7 ##cdr> call)))
            (disc-specs (extract-discriminant ('#<procedure #7 ##cdr> call))))
        (let ((begin-temp.240
               (if ('#<procedure #50 ##fx=>
                    ('#<procedure #23 length> disc-specs)
                    1)
                   #!void
                   (report-meroon-error
                    'Syntax
                    'define-handy-method
                    "Only one discriminating variable is supported"
                    call))))
          (let ((begin-temp.239
                 (letrec ((loop2.1040
                           (lambda (disc-specs lst2.1041)
                             (if ('#<procedure #4 ##pair?> lst2.1041)
                                 (let ((x.1042 (let ((spec ('#<procedure #6 ##car>
                                                            lst2.1041)))
                                                 (if ('#<procedure #4 ##pair?>
                                                      ('#<procedure #7 ##cdr>
                                                       spec))
                                                     #f
                                                     (report-meroon-error
                                                      'Syntax
                                                      'define-method
                                                      "No discriminating class"
                                                      disc-specs)))))
                                   (let ((lst2.1041
                                          ('#<procedure #7 ##cdr> lst2.1041)))
                                     (if ('#<procedure #4 ##pair?> lst2.1041)
                                         (let ((x.1042 (let ((spec ('#<procedure #6 ##car>
                                                                    lst2.1041)))
                                                         (if ('#<procedure #4 ##pair?>
                                                              ('#<procedure #7 ##cdr>
                                                               spec))
                                                             #f
                                                             (report-meroon-error
                                                              'Syntax
                                                              'define-method
                                                              "No discriminating class"
                                                              disc-specs)))))
                                           (loop2.1040
                                            disc-specs
                                            ('#<procedure #7 ##cdr>
                                             lst2.1041)))
                                         #!void)))
                                 #!void))))
                   (loop2.1040 disc-specs disc-specs))))
            (let ((begin-temp.238
                   ('#<procedure #63 ##set-box!>
                    dsssl?
                    (or (any? dsssl-optional? ('#<procedure #7 ##cdr> call))
                        (or (any? dsssl-rest? ('#<procedure #7 ##cdr> call))
                            (any? dsssl-key?
                                  ('#<procedure #7 ##cdr> call)))))))
              ('#<procedure #43 ##quasi-cons>
               'register-method
               ('#<procedure #43 ##quasi-cons>
                ('#<procedure #44 ##quasi-list>
                 'quote
                 ('#<procedure #6 ##car> call))
                ('#<procedure #43 ##quasi-cons>
                 ('#<procedure #44 ##quasi-list>
                  'quote
                  ('#<procedure #7 ##cdr> call))
                 ('#<procedure #43 ##quasi-cons>
                  ('#<procedure #44 ##quasi-list> 'quote meroon-revision)
                  ('#<procedure #43 ##quasi-cons>
                   ('#<procedure #44 ##quasi-list>
                    'lambda
                    ('#<procedure #44 ##quasi-list> g c d)
                    ('#<procedure #43 ##quasi-cons>
                     'lambda
                     ('#<procedure #43 ##quasi-cons>
                      (if ('#<procedure #62 ##unbox> dsssl?)
                          (rebuild-method-variable-list variables-for-method)
                          (flat-formals variables-for-generic))
                      ('#<procedure #45 ##quasi-append>
                       (next-method-code-if-needed
                        ('#<procedure #62 ##unbox> dsssl?)
                        ('#<procedure #7 ##cdr> call)
                        body
                        g
                        c
                        d
                        disc-specs)
                       ('#<procedure #44 ##quasi-list>
                        (let ((env (extract-formals
                                    ('#<procedure #7 ##cdr> call)))
                              (fields (Class-fields
                                       (->Class ('#<procedure #67 ##cadr>
                                                 ('#<procedure #6 ##car>
                                                  disc-specs)))))
                              (class (->Class ('#<procedure #67 ##cadr>
                                               ('#<procedure #6 ##car>
                                                disc-specs))))
                              (ins-tance
                               ('#<procedure #6 ##car>
                                ('#<procedure #6 ##car> disc-specs))))
                          (let ((class-var
                                 (symbol-concatenate
                                  (Class-name class)
                                  '-
                                  'class))
                                (o (gensym)))
                            (let ((walk* (make-expander* o class fields)))
                              ('#<procedure #43 ##quasi-cons>
                               'let
                               ('#<procedure #43 ##quasi-cons>
                                ('#<procedure #44 ##quasi-list>
                                 ('#<procedure #44 ##quasi-list> o ins-tance))
                                ('#<procedure #45 ##quasi-append>
                                 '()
                                 ('#<procedure #44 ##quasi-list>
                                  ('#<procedure #44 ##quasi-list>
                                   ('#<procedure #43 ##quasi-cons>
                                    'lambda
                                    ('#<procedure #43 ##quasi-cons>
                                     '()
                                     (walk* body env))))))))))))))))
                   (letrec ((loop2.1045
                             (lambda (lst2.1046)
                               (if ('#<procedure #4 ##pair?> lst2.1046)
                                   (let ((x.1047 (let ((spec ('#<procedure #6 ##car>
                                                              lst2.1046)))
                                                   ('#<procedure #44 ##quasi-list>
                                                    'quote
                                                    ('#<procedure #67 ##cadr>
                                                     spec)))))
                                     ('#<procedure #10 ##cons>
                                      x.1047
                                      (loop2.1045
                                       ('#<procedure #7 ##cdr> lst2.1046))))
                                   '()))))
                     (loop2.1045 disc-specs))))))))))))))

(define next-method-code-if-needed
  (lambda (dsssl? variables body g c d disc-specs)
    (let ((csn (gensym)))
      (let ((case-temp.242 ('#<procedure #23 length> disc-specs)))
        (if ('#<procedure #3 ##eq?> case-temp.242 1)
            ('#<procedure #46 append>
             (if (appear? 'call-next-method body)
                 ('#<procedure #34 ##list>
                  ('#<procedure #44 ##quasi-list>
                   'define
                   '(call-next-method)
                   ('#<procedure #44 ##quasi-list>
                    'let
                    ('#<procedure #44 ##quasi-list>
                     ('#<procedure #44 ##quasi-list>
                      csn
                      ('#<procedure #44 ##quasi-list> 'Class-super-number c)))
                    ('#<procedure #45 ##quasi-append>
                     (if dsssl? '(apply) '())
                     ('#<procedure #43 ##quasi-cons>
                      ('#<procedure #44 ##quasi-list>
                       'or
                       ('#<procedure #44 ##quasi-list>
                        'and
                        csn
                        ('#<procedure #44 ##quasi-list>
                         'find-method1
                         ('#<procedure #44 ##quasi-list>
                          'careless-Generic-dispatcher
                          g)
                         ('#<procedure #44 ##quasi-list> 'number->class csn)))
                       ('#<procedure #44 ##quasi-list> 'Generic-default g))
                      (reduce-variables variables))))))
                 '())
             (if (appear? 'next-method? body)
                 ('#<procedure #34 ##list>
                  ('#<procedure #44 ##quasi-list>
                   'define
                   '(next-method?)
                   ('#<procedure #44 ##quasi-list>
                    'let
                    ('#<procedure #44 ##quasi-list>
                     ('#<procedure #44 ##quasi-list>
                      csn
                      ('#<procedure #44 ##quasi-list> 'Class-super-number c)))
                    ('#<procedure #44 ##quasi-list>
                     'and
                     csn
                     ('#<procedure #44 ##quasi-list>
                      'find-method1
                      ('#<procedure #44 ##quasi-list>
                       'careless-Generic-dispatcher
                       g)
                      ('#<procedure #44 ##quasi-list> 'number->class csn))))))
                 '()))
            ('#<procedure #46 append>
             (if (appear? 'call-next-method body)
                 ('#<procedure #34 ##list>
                  ('#<procedure #44 ##quasi-list>
                   'define
                   '(call-next-method)
                   ('#<procedure #45 ##quasi-append>
                    (if dsssl? '(apply) '())
                    ('#<procedure #43 ##quasi-cons>
                     ('#<procedure #44 ##quasi-list>
                      'or
                      ('#<procedure #44 ##quasi-list>
                       'find-multi-method
                       ('#<procedure #44 ##quasi-list> 'Linear-Dispatcher-no d)
                       ('#<procedure #44 ##quasi-list>
                        'Linear-Dispatcher-signature
                        d))
                      ('#<procedure #44 ##quasi-list> 'Generic-default g))
                     (reduce-variables variables)))))
                 '())
             (if (appear? 'next-method? body)
                 ('#<procedure #34 ##list>
                  ('#<procedure #44 ##quasi-list>
                   'define
                   '(next-method?)
                   ('#<procedure #44 ##quasi-list>
                    'find-multi-method
                    ('#<procedure #44 ##quasi-list> 'Linear-Dispatcher-no d)
                    ('#<procedure #44 ##quasi-list>
                     'Linear-Dispatcher-signature
                     d))))
                 '())))))))

(define appear?
  (lambda (kw e)
    (letrec ((appear (lambda (kw e)
                       (or ('#<procedure #3 ##eq?> e kw)
                           (and ('#<procedure #4 ##pair?> e)
                                (or (appear kw ('#<procedure #6 ##car> e))
                                    (appear kw
                                            ('#<procedure #7 ##cdr> e))))))))
      (appear kw e))))

(define make-maker
  (lambda (class)
    (let ((poly-fields-number
           (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
             (letrec ((count (lambda (fields)
                               (if ('#<procedure #4 ##pair?> fields)
                                   (if (Poly-Field?
                                        ('#<procedure #6 ##car> fields))
                                       ('#<procedure #21 ##fx+>
                                        1
                                        (let ((fields ('#<procedure #7 ##cdr>
                                                       fields)))
                                          (if ('#<procedure #4 ##pair?> fields)
                                              (if (Poly-Field?
                                                   ('#<procedure #6 ##car>
                                                    fields))
                                                  ('#<procedure #21 ##fx+>
                                                   1
                                                   (count ('#<procedure #7 ##cdr>
                                                           fields)))
                                                  (count ('#<procedure #7 ##cdr>
                                                          fields)))
                                              0)))
                                       (count ('#<procedure #7 ##cdr> fields)))
                                   0))))
               (count fields)))))
      (if ('#<procedure #3 ##eq?> poly-fields-number 0)
          (create-zero-poly-maker class)
          (if ('#<procedure #3 ##eq?> poly-fields-number 1)
              (if (let ((o ('#<procedure #6 ##car>
                            (last-pair
                             ('#<procedure #32 ##vector-ref> class 3)))))
                    (and ('#<procedure #28 ##meroon?> o)
                         (let ((class1 ('#<procedure #32 ##vector-ref>
                                        *classes*
                                        ('#<procedure #32 ##vector-ref> o 0))))
                           (let ((depth2 ('#<procedure #32 ##vector-ref>
                                          Poly-Field-class
                                          4))
                                 (cn2 ('#<procedure #32 ##vector-ref>
                                       Poly-Field-class
                                       2)))
                             (and ('#<procedure #36 ##fx>=>
                                   ('#<procedure #32 ##vector-ref> class1 4)
                                   depth2)
                                  ('#<procedure #50 ##fx=>
                                   cn2
                                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                                            ('#<procedure #49 ##fx<=>
                                             depth2
                                             ('#<procedure #32 ##vector-ref>
                                              class1
                                              4)))
                                       (let ((offset ('#<procedure #21 ##fx+>
                                                      10
                                                      ('#<procedure #21 ##fx+>
                                                       1
                                                       depth2))))
                                         (let ((i ('#<procedure #21 ##fx+>
                                                   1
                                                   offset)))
                                           ('#<procedure #32 ##vector-ref>
                                            class1
                                            i)))
                                       (report-bad-index
                                        'super
                                        class1
                                        depth2))))))))
                  (create-one-final-poly-maker class)
                  (lambda args (general-make class args)))
              (lambda args (general-make class args)))))))

(define create-zero-poly-maker
  (lambda (class)
    (let ((case-temp.244
           ('#<procedure #23 length>
            ('#<procedure #32 ##vector-ref> class 3))))
      (if ('#<procedure #3 ##eq?> case-temp.244 0)
          (lambda ()
            (initialize!
             ('#<procedure #31 ##subtype-set!>
              ('#<procedure #68 ##vector>
               ('#<procedure #32 ##vector-ref> class 2))
              6)))
          (if ('#<procedure #3 ##eq?> case-temp.244 1)
              (lambda (a0)
                (initialize!
                 ('#<procedure #31 ##subtype-set!>
                  ('#<procedure #68 ##vector>
                   ('#<procedure #32 ##vector-ref> class 2)
                   a0)
                  6)))
              (if ('#<procedure #3 ##eq?> case-temp.244 2)
                  (lambda (a0 a1)
                    (initialize!
                     ('#<procedure #31 ##subtype-set!>
                      ('#<procedure #68 ##vector>
                       ('#<procedure #32 ##vector-ref> class 2)
                       a0
                       a1)
                      6)))
                  (if ('#<procedure #3 ##eq?> case-temp.244 3)
                      (lambda (a0 a1 a2)
                        (initialize!
                         ('#<procedure #31 ##subtype-set!>
                          ('#<procedure #68 ##vector>
                           ('#<procedure #32 ##vector-ref> class 2)
                           a0
                           a1
                           a2)
                          6)))
                      (if ('#<procedure #3 ##eq?> case-temp.244 4)
                          (lambda (a0 a1 a2 a3)
                            (initialize!
                             ('#<procedure #31 ##subtype-set!>
                              ('#<procedure #68 ##vector>
                               ('#<procedure #32 ##vector-ref> class 2)
                               a0
                               a1
                               a2
                               a3)
                              6)))
                          (if ('#<procedure #3 ##eq?> case-temp.244 5)
                              (lambda (a0 a1 a2 a3 a4)
                                (initialize!
                                 ('#<procedure #31 ##subtype-set!>
                                  ('#<procedure #68 ##vector>
                                   ('#<procedure #32 ##vector-ref> class 2)
                                   a0
                                   a1
                                   a2
                                   a3
                                   a4)
                                  6)))
                              (if ('#<procedure #3 ##eq?> case-temp.244 6)
                                  (lambda (a0 a1 a2 a3 a4 a5)
                                    (initialize!
                                     ('#<procedure #31 ##subtype-set!>
                                      ('#<procedure #68 ##vector>
                                       ('#<procedure #32 ##vector-ref> class 2)
                                       a0
                                       a1
                                       a2
                                       a3
                                       a4
                                       a5)
                                      6)))
                                  (if ('#<procedure #3 ##eq?> case-temp.244 7)
                                      (lambda (a0 a1 a2 a3 a4 a5 a6)
                                        (initialize!
                                         ('#<procedure #31 ##subtype-set!>
                                          ('#<procedure #68 ##vector>
                                           ('#<procedure #32 ##vector-ref>
                                            class
                                            2)
                                           a0
                                           a1
                                           a2
                                           a3
                                           a4
                                           a5
                                           a6)
                                          6)))
                                      (if ('#<procedure #3 ##eq?>
                                           case-temp.244
                                           8)
                                          (lambda (a0 a1 a2 a3 a4 a5 a6 a7)
                                            (initialize!
                                             ('#<procedure #31 ##subtype-set!>
                                              ('#<procedure #68 ##vector>
                                               ('#<procedure #32 ##vector-ref>
                                                class
                                                2)
                                               a0
                                               a1
                                               a2
                                               a3
                                               a4
                                               a5
                                               a6
                                               a7)
                                              6)))
                                          (if ('#<procedure #3 ##eq?>
                                               case-temp.244
                                               9)
                                              (lambda (a0
                                                       a1
                                                       a2
                                                       a3
                                                       a4
                                                       a5
                                                       a6
                                                       a7
                                                       a8)
                                                (initialize!
                                                 ('#<procedure #31 ##subtype-set!>
                                                  ('#<procedure #68 ##vector>
                                                   ('#<procedure #32 ##vector-ref>
                                                    class
                                                    2)
                                                   a0
                                                   a1
                                                   a2
                                                   a3
                                                   a4
                                                   a5
                                                   a6
                                                   a7
                                                   a8)
                                                  6)))
                                              (lambda args
                                                (general-make
                                                 class
                                                 args)))))))))))))))

(define create-one-final-poly-maker
  (lambda (class)
    (let ((case-temp.245
           ('#<procedure #23 length>
            ('#<procedure #32 ##vector-ref> class 3))))
      (if ('#<procedure #3 ##eq?> case-temp.245 1)
          (lambda (#:g523 . a0)
            (initialize!
             (let ((#:g522 ('#<procedure #23 length> a0)))
               (let ((v (let ((size ('#<procedure #21 ##fx+> 0 1 #:g522))
                              (cn ('#<procedure #32 ##vector-ref> class 2)))
                          (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                  1
                                                  size)))
                                          (let ((result ('#<procedure #30 ##make-vector>
                                                         n
                                                         meroon-uninitialized)))
                                            (let ((begin-temp.246
                                                   ('#<procedure #31 ##subtype-set!>
                                                    result
                                                    6)))
                                              result)))))
                            (let ((begin-temp.247
                                   ('#<procedure #33 ##vector-set!>
                                    result
                                    0
                                    cn)))
                              result)))))
                 (let ((begin-temp.249
                        (check-appropriate-size #:g522 #:g523 v)))
                   (let ((begin-temp.248
                          ('#<procedure #33 ##vector-set!> v 1 #:g523)))
                     (fill-instance! v 1 a0)))))))
          (if ('#<procedure #3 ##eq?> case-temp.245 2)
              (lambda (a0 #:g525 . a1)
                (initialize!
                 (let ((#:g524 ('#<procedure #23 length> a1)))
                   (let ((v (let ((size ('#<procedure #21 ##fx+> 1 1 #:g524))
                                  (cn ('#<procedure #32 ##vector-ref>
                                       class
                                       2)))
                              (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                      1
                                                      size)))
                                              (let ((result ('#<procedure #30 ##make-vector>
                                                             n
                                                             meroon-uninitialized)))
                                                (let ((begin-temp.250
                                                       ('#<procedure #31 ##subtype-set!>
                                                        result
                                                        6)))
                                                  result)))))
                                (let ((begin-temp.251
                                       ('#<procedure #33 ##vector-set!>
                                        result
                                        0
                                        cn)))
                                  result)))))
                     (let ((begin-temp.254
                            (check-appropriate-size #:g524 #:g525 v)))
                       (let ((begin-temp.253
                              ('#<procedure #33 ##vector-set!> v 1 a0)))
                         (let ((begin-temp.252
                                ('#<procedure #33 ##vector-set!> v 2 #:g525)))
                           (fill-instance! v 2 a1))))))))
              (if ('#<procedure #3 ##eq?> case-temp.245 3)
                  (lambda (a0 a1 #:g527 . a2)
                    (initialize!
                     (let ((#:g526 ('#<procedure #23 length> a2)))
                       (let ((v (let ((size ('#<procedure #21 ##fx+>
                                             2
                                             1
                                             #:g526))
                                      (cn ('#<procedure #32 ##vector-ref>
                                           class
                                           2)))
                                  (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                          1
                                                          size)))
                                                  (let ((result ('#<procedure #30 ##make-vector>
                                                                 n
                                                                 meroon-uninitialized)))
                                                    (let ((begin-temp.255
                                                           ('#<procedure #31 ##subtype-set!>
                                                            result
                                                            6)))
                                                      result)))))
                                    (let ((begin-temp.256
                                           ('#<procedure #33 ##vector-set!>
                                            result
                                            0
                                            cn)))
                                      result)))))
                         (let ((begin-temp.260
                                (check-appropriate-size #:g526 #:g527 v)))
                           (let ((begin-temp.259
                                  ('#<procedure #33 ##vector-set!> v 1 a0)))
                             (let ((begin-temp.258
                                    ('#<procedure #33 ##vector-set!> v 2 a1)))
                               (let ((begin-temp.257
                                      ('#<procedure #33 ##vector-set!>
                                       v
                                       3
                                       #:g527)))
                                 (fill-instance! v 3 a2)))))))))
                  (if ('#<procedure #3 ##eq?> case-temp.245 4)
                      (lambda (a0 a1 a2 #:g529 . a3)
                        (initialize!
                         (let ((#:g528 ('#<procedure #23 length> a3)))
                           (let ((v (let ((size ('#<procedure #21 ##fx+>
                                                 3
                                                 1
                                                 #:g528))
                                          (cn ('#<procedure #32 ##vector-ref>
                                               class
                                               2)))
                                      (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                              1
                                                              size)))
                                                      (let ((result ('#<procedure #30 ##make-vector>
                                                                     n
                                                                     meroon-uninitialized)))
                                                        (let ((begin-temp.261
                                                               ('#<procedure #31 ##subtype-set!>
                                                                result
                                                                6)))
                                                          result)))))
                                        (let ((begin-temp.262
                                               ('#<procedure #33 ##vector-set!>
                                                result
                                                0
                                                cn)))
                                          result)))))
                             (let ((begin-temp.267
                                    (check-appropriate-size #:g528 #:g529 v)))
                               (let ((begin-temp.266
                                      ('#<procedure #33 ##vector-set!>
                                       v
                                       1
                                       a0)))
                                 (let ((begin-temp.265
                                        ('#<procedure #33 ##vector-set!>
                                         v
                                         2
                                         a1)))
                                   (let ((begin-temp.264
                                          ('#<procedure #33 ##vector-set!>
                                           v
                                           3
                                           a2)))
                                     (let ((begin-temp.263
                                            ('#<procedure #33 ##vector-set!>
                                             v
                                             4
                                             #:g529)))
                                       (fill-instance! v 4 a3))))))))))
                      (if ('#<procedure #3 ##eq?> case-temp.245 5)
                          (lambda (a0 a1 a2 a3 #:g531 . a4)
                            (initialize!
                             (let ((#:g530 ('#<procedure #23 length> a4)))
                               (let ((v (let ((size ('#<procedure #21 ##fx+>
                                                     4
                                                     1
                                                     #:g530))
                                              (cn ('#<procedure #32 ##vector-ref>
                                                   class
                                                   2)))
                                          (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                                  1
                                                                  size)))
                                                          (let ((result ('#<procedure #30 ##make-vector>
                                                                         n
                                                                         meroon-uninitialized)))
                                                            (let ((begin-temp.268
                                                                   ('#<procedure #31 ##subtype-set!>
                                                                    result
                                                                    6)))
                                                              result)))))
                                            (let ((begin-temp.269
                                                   ('#<procedure #33 ##vector-set!>
                                                    result
                                                    0
                                                    cn)))
                                              result)))))
                                 (let ((begin-temp.275
                                        (check-appropriate-size
                                         #:g530
                                         #:g531
                                         v)))
                                   (let ((begin-temp.274
                                          ('#<procedure #33 ##vector-set!>
                                           v
                                           1
                                           a0)))
                                     (let ((begin-temp.273
                                            ('#<procedure #33 ##vector-set!>
                                             v
                                             2
                                             a1)))
                                       (let ((begin-temp.272
                                              ('#<procedure #33 ##vector-set!>
                                               v
                                               3
                                               a2)))
                                         (let ((begin-temp.271
                                                ('#<procedure #33 ##vector-set!>
                                                 v
                                                 4
                                                 a3)))
                                           (let ((begin-temp.270
                                                  ('#<procedure #33 ##vector-set!>
                                                   v
                                                   5
                                                   #:g531)))
                                             (fill-instance! v 5 a4)))))))))))
                          (if ('#<procedure #3 ##eq?> case-temp.245 6)
                              (lambda (a0 a1 a2 a3 a4 #:g533 . a5)
                                (initialize!
                                 (let ((#:g532 ('#<procedure #23 length> a5)))
                                   (let ((v (let ((size ('#<procedure #21 ##fx+>
                                                         5
                                                         1
                                                         #:g532))
                                                  (cn ('#<procedure #32 ##vector-ref>
                                                       class
                                                       2)))
                                              (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                                      1
                                                                      size)))
                                                              (let ((result ('#<procedure #30 ##make-vector>
                                                                             n
                                                                             meroon-uninitialized)))
                                                                (let ((begin-temp.276
                                                                       ('#<procedure #31 ##subtype-set!>
                                                                        result
                                                                        6)))
                                                                  result)))))
                                                (let ((begin-temp.277
                                                       ('#<procedure #33 ##vector-set!>
                                                        result
                                                        0
                                                        cn)))
                                                  result)))))
                                     (let ((begin-temp.284
                                            (check-appropriate-size
                                             #:g532
                                             #:g533
                                             v)))
                                       (let ((begin-temp.283
                                              ('#<procedure #33 ##vector-set!>
                                               v
                                               1
                                               a0)))
                                         (let ((begin-temp.282
                                                ('#<procedure #33 ##vector-set!>
                                                 v
                                                 2
                                                 a1)))
                                           (let ((begin-temp.281
                                                  ('#<procedure #33 ##vector-set!>
                                                   v
                                                   3
                                                   a2)))
                                             (let ((begin-temp.280
                                                    ('#<procedure #33 ##vector-set!>
                                                     v
                                                     4
                                                     a3)))
                                               (let ((begin-temp.279
                                                      ('#<procedure #33 ##vector-set!>
                                                       v
                                                       5
                                                       a4)))
                                                 (let ((begin-temp.278
                                                        ('#<procedure #33 ##vector-set!>
                                                         v
                                                         6
                                                         #:g533)))
                                                   (fill-instance!
                                                    v
                                                    6
                                                    a5))))))))))))
                              (if ('#<procedure #3 ##eq?> case-temp.245 7)
                                  (lambda (a0 a1 a2 a3 a4 a5 #:g535 . a6)
                                    (initialize!
                                     (let ((#:g534 ('#<procedure #23 length>
                                                    a6)))
                                       (let ((v (let ((size ('#<procedure #21 ##fx+>
                                                             6
                                                             1
                                                             #:g534))
                                                      (cn ('#<procedure #32 ##vector-ref>
                                                           class
                                                           2)))
                                                  (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                                          1
                                                                          size)))
                                                                  (let ((result ('#<procedure #30 ##make-vector>
                                                                                 n
                                                                                 meroon-uninitialized)))
                                                                    (let ((begin-temp.285
                                                                           ('#<procedure #31 ##subtype-set!>
                                                                            result
                                                                            6)))
                                                                      result)))))
                                                    (let ((begin-temp.286
                                                           ('#<procedure #33 ##vector-set!>
                                                            result
                                                            0
                                                            cn)))
                                                      result)))))
                                         (let ((begin-temp.294
                                                (check-appropriate-size
                                                 #:g534
                                                 #:g535
                                                 v)))
                                           (let ((begin-temp.293
                                                  ('#<procedure #33 ##vector-set!>
                                                   v
                                                   1
                                                   a0)))
                                             (let ((begin-temp.292
                                                    ('#<procedure #33 ##vector-set!>
                                                     v
                                                     2
                                                     a1)))
                                               (let ((begin-temp.291
                                                      ('#<procedure #33 ##vector-set!>
                                                       v
                                                       3
                                                       a2)))
                                                 (let ((begin-temp.290
                                                        ('#<procedure #33 ##vector-set!>
                                                         v
                                                         4
                                                         a3)))
                                                   (let ((begin-temp.289
                                                          ('#<procedure #33 ##vector-set!>
                                                           v
                                                           5
                                                           a4)))
                                                     (let ((begin-temp.288
                                                            ('#<procedure #33 ##vector-set!>
                                                             v
                                                             6
                                                             a5)))
                                                       (let ((begin-temp.287
                                                              ('#<procedure #33 ##vector-set!>
                                                               v
                                                               7
                                                               #:g535)))
                                                         (fill-instance!
                                                          v
                                                          7
                                                          a6)))))))))))))
                                  (if ('#<procedure #3 ##eq?> case-temp.245 8)
                                      (lambda (a0
                                               a1
                                               a2
                                               a3
                                               a4
                                               a5
                                               a6
                                               #:g537
                                               .
                                               a7)
                                        (initialize!
                                         (let ((#:g536 ('#<procedure #23 length>
                                                        a7)))
                                           (let ((v (let ((size ('#<procedure #21 ##fx+>
                                                                 7
                                                                 1
                                                                 #:g536))
                                                          (cn ('#<procedure #32 ##vector-ref>
                                                               class
                                                               2)))
                                                      (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                                              1
                                                                              size)))
                                                                      (let ((result ('#<procedure #30 ##make-vector>
                                                                                     n
                                                                                     meroon-uninitialized)))
                                                                        (let ((begin-temp.295
                                                                               ('#<procedure #31 ##subtype-set!>
                                                                                result
                                                                                6)))
                                                                          result)))))
                                                        (let ((begin-temp.296
                                                               ('#<procedure #33 ##vector-set!>
                                                                result
                                                                0
                                                                cn)))
                                                          result)))))
                                             (let ((begin-temp.305
                                                    (check-appropriate-size
                                                     #:g536
                                                     #:g537
                                                     v)))
                                               (let ((begin-temp.304
                                                      ('#<procedure #33 ##vector-set!>
                                                       v
                                                       1
                                                       a0)))
                                                 (let ((begin-temp.303
                                                        ('#<procedure #33 ##vector-set!>
                                                         v
                                                         2
                                                         a1)))
                                                   (let ((begin-temp.302
                                                          ('#<procedure #33 ##vector-set!>
                                                           v
                                                           3
                                                           a2)))
                                                     (let ((begin-temp.301
                                                            ('#<procedure #33 ##vector-set!>
                                                             v
                                                             4
                                                             a3)))
                                                       (let ((begin-temp.300
                                                              ('#<procedure #33 ##vector-set!>
                                                               v
                                                               5
                                                               a4)))
                                                         (let ((begin-temp.299
                                                                ('#<procedure #33 ##vector-set!>
                                                                 v
                                                                 6
                                                                 a5)))
                                                           (let ((begin-temp.298
                                                                  ('#<procedure #33 ##vector-set!>
                                                                   v
                                                                   7
                                                                   a6)))
                                                             (let ((begin-temp.297
                                                                    ('#<procedure #33 ##vector-set!>
                                                                     v
                                                                     8
                                                                     #:g537)))
                                                               (fill-instance!
                                                                v
                                                                8
                                                                a7))))))))))))))
                                      (if ('#<procedure #3 ##eq?>
                                           case-temp.245
                                           9)
                                          (lambda (a0
                                                   a1
                                                   a2
                                                   a3
                                                   a4
                                                   a5
                                                   a6
                                                   a7
                                                   #:g539
                                                   .
                                                   a8)
                                            (initialize!
                                             (let ((#:g538 ('#<procedure #23 length>
                                                            a8)))
                                               (let ((v (let ((size ('#<procedure #21 ##fx+>
                                                                     8
                                                                     1
                                                                     #:g538))
                                                              (cn ('#<procedure #32 ##vector-ref>
                                                                   class
                                                                   2)))
                                                          (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                                                  1
                                                                                  size)))
                                                                          (let ((result ('#<procedure #30 ##make-vector>
                                                                                         n
                                                                                         meroon-uninitialized)))
                                                                            (let ((begin-temp.306
                                                                                   ('#<procedure #31 ##subtype-set!>
                                                                                    result
                                                                                    6)))
                                                                              result)))))
                                                            (let ((begin-temp.307
                                                                   ('#<procedure #33 ##vector-set!>
                                                                    result
                                                                    0
                                                                    cn)))
                                                              result)))))
                                                 (let ((begin-temp.317
                                                        (check-appropriate-size
                                                         #:g538
                                                         #:g539
                                                         v)))
                                                   (let ((begin-temp.316
                                                          ('#<procedure #33 ##vector-set!>
                                                           v
                                                           1
                                                           a0)))
                                                     (let ((begin-temp.315
                                                            ('#<procedure #33 ##vector-set!>
                                                             v
                                                             2
                                                             a1)))
                                                       (let ((begin-temp.314
                                                              ('#<procedure #33 ##vector-set!>
                                                               v
                                                               3
                                                               a2)))
                                                         (let ((begin-temp.313
                                                                ('#<procedure #33 ##vector-set!>
                                                                 v
                                                                 4
                                                                 a3)))
                                                           (let ((begin-temp.312
                                                                  ('#<procedure #33 ##vector-set!>
                                                                   v
                                                                   5
                                                                   a4)))
                                                             (let ((begin-temp.311
                                                                    ('#<procedure #33 ##vector-set!>
                                                                     v
                                                                     6
                                                                     a5)))
                                                               (let ((begin-temp.310
                                                                      ('#<procedure #33 ##vector-set!>
                                                                       v
                                                                       7
                                                                       a6)))
                                                                 (let ((begin-temp.309
                                                                        ('#<procedure #33 ##vector-set!>
                                                                         v
                                                                         8
                                                                         a7)))
                                                                   (let ((begin-temp.308
                                                                          ('#<procedure #33 ##vector-set!>
                                                                           v
                                                                           9
                                                                           #:g539)))
                                                                     (fill-instance!
                                                                      v
                                                                      9
                                                                      a8)))))))))))))))
                                          (lambda args
                                            (general-make
                                             class
                                             args))))))))))))))

(define original-Object-class-number (get-new-class-number))

(define original-Pre-Class-class-number (get-new-class-number))

(define original-Class-class-number (get-new-class-number))

(define original-Handy-Class-class-number (get-new-class-number))

(define original-MeroonV2-Class-class-number (get-new-class-number))

(define original-Applyable-Object-class-number (get-new-class-number))

(define original-Generic-class-number (get-new-class-number))

(define original-Generic-1-class-number (get-new-class-number))

(define original-Generic-N-class-number (get-new-class-number))

(define original-Pre-Field-class-number (get-new-class-number))

(define original-Field-class-number (get-new-class-number))

(define original-Mono-Field-class-number (get-new-class-number))

(define original-Poly-Field-class-number (get-new-class-number))

(define original-Dispatcher-class-number (get-new-class-number))

(define original-Immediate-Dispatcher-class-number (get-new-class-number))

(define original-Subclass-Dispatcher-class-number (get-new-class-number))

(define original-Indexed-Dispatcher-class-number (get-new-class-number))

(define original-Linear-Dispatcher-class-number (get-new-class-number))

(define original-Global-Dispatcher-class-number (get-new-class-number))

(define original-Tracing-Dispatcher-class-number (get-new-class-number))

(define original-Anomaly-class-number (get-new-class-number))

(define original-Warning-class-number (get-new-class-number))

(define original-View-class-number (get-new-class-number))

(define original-Virtual-Field-class-number (get-new-class-number))

(define create-Mono-Field
  (lambda (immutable? name cn . path)
    (create-some-field
     original-Mono-Field-class-number
     immutable?
     name
     cn
     path)))

(define create-Poly-Field
  (lambda (immutable? name cn . path)
    (create-some-field
     original-Poly-Field-class-number
     immutable?
     name
     cn
     path)))

(define create-some-field
  (lambda (tcn immutable? name cn path)
    (let ((f (let ((size ('#<procedure #21 ##fx+>
                          5
                          ('#<procedure #21 ##fx+>
                           1
                           ('#<procedure #23 length> path)))))
               (let ((result (let ((n ('#<procedure #21 ##fx+> 1 size)))
                               (let ((result ('#<procedure #30 ##make-vector>
                                              n
                                              meroon-uninitialized)))
                                 (let ((begin-temp.318
                                        ('#<procedure #31 ##subtype-set!>
                                         result
                                         6)))
                                   result)))))
                 (let ((begin-temp.319
                        ('#<procedure #33 ##vector-set!> result 0 tcn)))
                   result)))))
      (let ((begin-temp.325 ('#<procedure #33 ##vector-set!> f 1 name)))
        (let ((begin-temp.324
               ('#<procedure #33 ##vector-set!> f 2 immutable?)))
          (let ((begin-temp.323 ('#<procedure #33 ##vector-set!> f 3 cn)))
            (let ((begin-temp.322 ('#<procedure #33 ##vector-set!> f 4 #f)))
              (let ((begin-temp.321
                     (let ((value ('#<procedure #23 length> path)))
                       ('#<procedure #33 ##vector-set!> f 6 value))))
                (letrec ((stuff (lambda (f args i)
                                  (if ('#<procedure #4 ##pair?> args)
                                      (let ((begin-temp.320
                                             (let ((value ('#<procedure #6 ##car>
                                                           args)))
                                               (let ((i ('#<procedure #21 ##fx+>
                                                         1
                                                         i)))
                                                 ('#<procedure #33 ##vector-set!>
                                                  f
                                                  i
                                                  value)))))
                                        (stuff f
                                               ('#<procedure #7 ##cdr> args)
                                               ('#<procedure #21 ##fx+> i 1)))
                                      f))))
                  (stuff f path 6))))))))))

(define simple-append-fields
  (lambda (fields1 fields2)
    (let ((start ('#<procedure #23 length> fields1)))
      ('#<procedure #46 append>
       (letrec ((loop2.1050
                 (lambda (lst2.1051)
                   (if ('#<procedure #4 ##pair?> lst2.1051)
                       (let ((x.1052 (instance-clone
                                      ('#<procedure #6 ##car> lst2.1051))))
                         ('#<procedure #10 ##cons>
                          x.1052
                          (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                       '()))))
         (loop2.1050 fields1))
       ('#<procedure #69 map>
        (lambda (field index)
          (let ((begin-temp.326
                 ('#<procedure #33 ##vector-set!> field 7 index)))
            field))
        fields2
        (let ((end ('#<procedure #21 ##fx+>
                    start
                    ('#<procedure #23 length> fields2))))
          (if ('#<procedure #20 ##fx<> start end)
              ('#<procedure #10 ##cons>
               start
               (let ((start ('#<procedure #21 ##fx+> 1 start)))
                 (if ('#<procedure #20 ##fx<> start end)
                     ('#<procedure #10 ##cons>
                      start
                      (iota ('#<procedure #21 ##fx+> 1 start) end))
                     '())))
              '())))))))

(define Object-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Object
    original-Object-class-number
    ('#<procedure #34 ##list>)
    0
    #f
    ('#<procedure #34 ##list>
     original-Class-class-number
     original-Applyable-Object-class-number
     original-Pre-Field-class-number
     original-Dispatcher-class-number
     original-Anomaly-class-number
     original-View-class-number)
    ('#<procedure #21 ##fx+> 1 original-Virtual-Field-class-number)
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    1
    original-Object-class-number)
   6))

(define Pre-Class-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Pre-Class
    original-Pre-Class-class-number
    ('#<procedure #34 ##list>
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'name
      original-Pre-Class-class-number
      0)
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'number
      original-Pre-Class-class-number
      1)
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'fields
      original-Pre-Class-class-number
      2))
    1
    original-Object-class-number
    ('#<procedure #34 ##list>
     original-Class-class-number
     original-View-class-number)
    5
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    3
    original-Object-class-number
    original-Pre-Class-class-number
    0)
   6))

(define Class-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Class
    original-Class-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (let ((f (let ((size ('#<procedure #21 ##fx+>
                                             5
                                             ('#<procedure #21 ##fx+>
                                              1
                                              ('#<procedure #23 length>
                                               path)))))
                                  (let ((result (let ((n ('#<procedure #21 ##fx+>
                                                          1
                                                          size)))
                                                  (let ((result ('#<procedure #30 ##make-vector>
                                                                 n
                                                                 meroon-uninitialized)))
                                                    (let ((begin-temp.318
                                                           ('#<procedure #31 ##subtype-set!>
                                                            result
                                                            6)))
                                                      result)))))
                                    (let ((begin-temp.319
                                           ('#<procedure #33 ##vector-set!>
                                            result
                                            0
                                            original-Mono-Field-class-number)))
                                      result)))))
                         (let ((begin-temp.325
                                ('#<procedure #33 ##vector-set!> f 1 name)))
                           (let ((begin-temp.324
                                  ('#<procedure #33 ##vector-set!>
                                   f
                                   2
                                   immutable?)))
                             (let ((begin-temp.323
                                    ('#<procedure #33 ##vector-set!> f 3 cn)))
                               (let ((begin-temp.322
                                      ('#<procedure #33 ##vector-set!>
                                       f
                                       4
                                       #f)))
                                 (let ((begin-temp.321
                                        (let ((value ('#<procedure #23 length>
                                                      path)))
                                          ('#<procedure #33 ##vector-set!>
                                           f
                                           6
                                           value))))
                                   (letrec ((stuff (lambda (f args i)
                                                     (if ('#<procedure #4 ##pair?>
                                                          args)
                                                         (let ((begin-temp.320
                                                                (let ((value ('#<procedure #6 ##car>
                                                                              args)))
                                                                  (let ((i ('#<procedure #21 ##fx+>
                                                                            1
                                                                            i)))
                                                                    ('#<procedure #33 ##vector-set!>
                                                                     f
                                                                     i
                                                                     value)))))
                                                           (let ((i ('#<procedure #21 ##fx+>
                                                                     i
                                                                     1))
                                                                 (args ('#<procedure #7 ##cdr>
                                                                        args)))
                                                             (if ('#<procedure #4 ##pair?>
                                                                  args)
                                                                 (let ((begin-temp.320
                                                                        (let ((value ('#<procedure #6 ##car>
                                                                                      args)))
                                                                          (let ((i ('#<procedure #21 ##fx+>
                                                                                    1
                                                                                    i)))
                                                                            ('#<procedure #33 ##vector-set!>
                                                                             f
                                                                             i
                                                                             value)))))
                                                                   (stuff f
                                                                          ('#<procedure #7 ##cdr>
                                                                           args)
                                                                          ('#<procedure #21 ##fx+>
                                                                           i
                                                                           1)))
                                                                 f)))
                                                         f))))
                                     (stuff f path 6)))))))))
                     #t
                     'depth
                     original-Class-class-number
                     3)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'super-number
                     original-Class-class-number
                     4)
                    (create-Mono-Field
                     #f
                     'subclass-numbers
                     original-Class-class-number
                     5)
                    (create-Mono-Field #f 'next original-Class-class-number 6)
                    (create-Mono-Field
                     #t
                     'allocator
                     original-Class-class-number
                     7)
                    (create-Mono-Field
                     #t
                     'immutable?
                     original-Class-class-number
                     8)
                    (create-Mono-Field #t 'views original-Class-class-number 9)
                    (create-Poly-Field
                     #t
                     'suprel
                     original-Class-class-number
                     10)))
          (fields1 ('#<procedure #32 ##vector-ref> Pre-Class-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (iota start
                ('#<procedure #21 ##fx+>
                 start
                 ('#<procedure #23 length> fields2)))))))
    2
    original-Pre-Class-class-number
    ('#<procedure #34 ##list> original-Handy-Class-class-number)
    3
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Pre-Class-class-number
    original-Class-class-number
    1
    0)
   6))

(define Handy-Class-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Handy-Class
    original-Handy-Class-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Class-class 3)
     ('#<procedure #34 ##list>))
    3
    original-Class-class-number
    ('#<procedure #34 ##list> original-MeroonV2-Class-class-number)
    2
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    7
    original-Object-class-number
    original-Pre-Class-class-number
    original-Class-class-number
    original-Handy-Class-class-number
    2
    1
    0)
   6))

(define MeroonV2-Class-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'MeroonV2-Class
    original-MeroonV2-Class-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Class-class 3)
     ('#<procedure #34 ##list>))
    4
    original-Handy-Class-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    9
    original-Object-class-number
    original-Pre-Class-class-number
    original-Class-class-number
    original-Handy-Class-class-number
    original-MeroonV2-Class-class-number
    3
    2
    1
    0)
   6))

(define Applyable-Object-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Applyable-Object
    original-Applyable-Object-class-number
    ('#<procedure #34 ##list>)
    1
    original-Object-class-number
    ('#<procedure #34 ##list> original-Generic-class-number)
    4
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    3
    original-Object-class-number
    original-Applyable-Object-class-number
    0)
   6))

(define Generic-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Generic
    original-Generic-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'name
                     original-Generic-class-number
                     0)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'default
                     original-Generic-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'variables
                     original-Generic-class-number
                     2)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'dispatcher
                     original-Generic-class-number
                     3)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'top-classes
                     original-Generic-class-number
                     4)))
          (fields1 ('#<procedure #32 ##vector-ref> Applyable-Object-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (let ((o ('#<procedure #6 ##car>
                                                 lst2.1051)))
                                         (let ((n ('#<procedure #29 ##vector-length>
                                                   o)))
                                           (let ((r (let ((result ('#<procedure #30 ##make-vector>
                                                                   n
                                                                   meroon-uninitialized)))
                                                      (let ((begin-temp.4
                                                             ('#<procedure #31 ##subtype-set!>
                                                              result
                                                              6)))
                                                        result))))
                                             (let ((begin-temp.5
                                                    (letrec ((copy (lambda (o
                                                                            n
                                                                            r
                                                                            i)
                                                                     (if ('#<procedure #20 ##fx<>
                                                                          i
                                                                          n)
                                                                         (let ((begin-temp.3
                                                                                (let ((val ('#<procedure #32 ##vector-ref>
                                                                                            o
                                                                                            i)))
                                                                                  ('#<procedure #33 ##vector-set!>
                                                                                   r
                                                                                   i
                                                                                   val))))
                                                                           (copy o
                                                                                 n
                                                                                 r
                                                                                 ('#<procedure #21 ##fx+>
                                                                                  i
                                                                                  1)))
                                                                         #!void))))
                                                      (copy o n r 0))))
                                               r))))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Applyable-Object-class-number
    ('#<procedure #34 ##list>
     original-Generic-1-class-number
     original-Generic-N-class-number)
    3
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Applyable-Object-class-number
    original-Generic-class-number
    1
    0)
   6))

(define Generic-1-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Generic-1
    original-Generic-1-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Generic-class 3)
     ('#<procedure #34 ##list>))
    3
    original-Generic-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    7
    original-Object-class-number
    original-Applyable-Object-class-number
    original-Generic-class-number
    original-Generic-1-class-number
    2
    1
    0)
   6))

(define Generic-N-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Generic-N
    original-Generic-N-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Generic-class 3)
     ('#<procedure #34 ##list>))
    3
    original-Generic-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    7
    original-Object-class-number
    original-Applyable-Object-class-number
    original-Generic-class-number
    original-Generic-N-class-number
    3
    2
    0)
   6))

(define Pre-Field-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Pre-Field
    original-Pre-Field-class-number
    ('#<procedure #34 ##list>
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'name
      original-Pre-Field-class-number
      0))
    1
    original-Object-class-number
    ('#<procedure #34 ##list> original-Field-class-number)
    4
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    3
    original-Object-class-number
    original-Pre-Field-class-number
    0)
   6))

(define Field-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Field
    original-Field-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'immutable?
                     original-Field-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'class-number
                     original-Field-class-number
                     2)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'initialized?
                     original-Field-class-number
                     3)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'initializer
                     original-Field-class-number
                     4)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Poly-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'path
                     original-Field-class-number
                     5)))
          (fields1 ('#<procedure #32 ##vector-ref> Pre-Field-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (let ((o ('#<procedure #6 ##car>
                                                 lst2.1051)))
                                         (let ((n ('#<procedure #29 ##vector-length>
                                                   o)))
                                           (let ((r (let ((result ('#<procedure #30 ##make-vector>
                                                                   n
                                                                   meroon-uninitialized)))
                                                      (let ((begin-temp.4
                                                             ('#<procedure #31 ##subtype-set!>
                                                              result
                                                              6)))
                                                        result))))
                                             (let ((begin-temp.5
                                                    (letrec ((copy (lambda (o
                                                                            n
                                                                            r
                                                                            i)
                                                                     (if ('#<procedure #20 ##fx<>
                                                                          i
                                                                          n)
                                                                         (let ((begin-temp.3
                                                                                (let ((val ('#<procedure #32 ##vector-ref>
                                                                                            o
                                                                                            i)))
                                                                                  ('#<procedure #33 ##vector-set!>
                                                                                   r
                                                                                   i
                                                                                   val))))
                                                                           (copy o
                                                                                 n
                                                                                 r
                                                                                 ('#<procedure #21 ##fx+>
                                                                                  i
                                                                                  1)))
                                                                         #!void))))
                                                      (copy o n r 0))))
                                               r))))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Pre-Field-class-number
    ('#<procedure #34 ##list>
     original-Mono-Field-class-number
     original-Poly-Field-class-number)
    3
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Pre-Field-class-number
    original-Field-class-number
    1
    0)
   6))

(define Mono-Field-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Mono-Field
    original-Mono-Field-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Field-class 3)
     ('#<procedure #34 ##list>))
    3
    original-Field-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    7
    original-Object-class-number
    original-Pre-Field-class-number
    original-Field-class-number
    original-Mono-Field-class-number
    2
    1
    0)
   6))

(define Poly-Field-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Poly-Field
    original-Poly-Field-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Field-class 3)
     ('#<procedure #34 ##list>))
    3
    original-Field-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    7
    original-Object-class-number
    original-Pre-Field-class-number
    original-Field-class-number
    original-Poly-Field-class-number
    3
    2
    0)
   6))

(define Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Dispatcher
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'method-finder
      original-Dispatcher-class-number
      0))
    1
    original-Object-class-number
    ('#<procedure #34 ##list>
     original-Immediate-Dispatcher-class-number
     original-Subclass-Dispatcher-class-number
     original-Indexed-Dispatcher-class-number
     original-Linear-Dispatcher-class-number
     original-Global-Dispatcher-class-number
     original-Tracing-Dispatcher-class-number)
    7
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    3
    original-Object-class-number
    original-Dispatcher-class-number
    0)
   6))

(define Immediate-Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Immediate-Dispatcher
    original-Immediate-Dispatcher-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'method
                     original-Immediate-Dispatcher-class-number
                     1)))
          (fields1 ('#<procedure #32 ##vector-ref> Dispatcher-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Dispatcher-class-number
    original-Immediate-Dispatcher-class-number
    1
    0)
   6))

(define Subclass-Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Subclass-Dispatcher
    original-Subclass-Dispatcher-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'class-number
                     original-Subclass-Dispatcher-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'class-depth
                     original-Subclass-Dispatcher-class-number
                     2)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'no
                     original-Subclass-Dispatcher-class-number
                     3)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'yes
                     original-Subclass-Dispatcher-class-number
                     4)))
          (fields1 ('#<procedure #32 ##vector-ref> Dispatcher-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (let ((lst2.1051
                                   ('#<procedure #7 ##cdr> lst2.1051)))
                              (if ('#<procedure #4 ##pair?> lst2.1051)
                                  (let ((x.1052 (instance-clone
                                                 ('#<procedure #6 ##car>
                                                  lst2.1051))))
                                    ('#<procedure #10 ##cons>
                                     x.1052
                                     (let ((lst2.1051
                                            ('#<procedure #7 ##cdr>
                                             lst2.1051)))
                                       (if ('#<procedure #4 ##pair?> lst2.1051)
                                           (let ((x.1052 (instance-clone
                                                          ('#<procedure #6 ##car>
                                                           lst2.1051))))
                                             ('#<procedure #10 ##cons>
                                              x.1052
                                              (loop2.1050
                                               ('#<procedure #7 ##cdr>
                                                lst2.1051))))
                                           '()))))
                                  '()))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Dispatcher-class-number
    original-Subclass-Dispatcher-class-number
    2
    0)
   6))

(define Indexed-Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Indexed-Dispatcher
    original-Indexed-Dispatcher-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'class-number
                     original-Indexed-Dispatcher-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'class-depth
                     original-Indexed-Dispatcher-class-number
                     2)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'no
                     original-Indexed-Dispatcher-class-number
                     3)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Poly-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'method
                     original-Indexed-Dispatcher-class-number
                     4)))
          (fields1 ('#<procedure #32 ##vector-ref> Dispatcher-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (let ((o ('#<procedure #6 ##car>
                                                 lst2.1051)))
                                         (let ((n ('#<procedure #29 ##vector-length>
                                                   o)))
                                           (let ((r (let ((result ('#<procedure #30 ##make-vector>
                                                                   n
                                                                   meroon-uninitialized)))
                                                      (let ((begin-temp.4
                                                             ('#<procedure #31 ##subtype-set!>
                                                              result
                                                              6)))
                                                        result))))
                                             (let ((begin-temp.5
                                                    (letrec ((copy (lambda (o
                                                                            n
                                                                            r
                                                                            i)
                                                                     (if ('#<procedure #20 ##fx<>
                                                                          i
                                                                          n)
                                                                         (let ((begin-temp.3
                                                                                (let ((val ('#<procedure #32 ##vector-ref>
                                                                                            o
                                                                                            i)))
                                                                                  ('#<procedure #33 ##vector-set!>
                                                                                   r
                                                                                   i
                                                                                   val))))
                                                                           (copy o
                                                                                 n
                                                                                 r
                                                                                 ('#<procedure #21 ##fx+>
                                                                                  i
                                                                                  1)))
                                                                         #!void))))
                                                      (copy o n r 0))))
                                               r))))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (iota start
                ('#<procedure #21 ##fx+>
                 start
                 ('#<procedure #23 length> fields2)))))))
    2
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Dispatcher-class-number
    original-Indexed-Dispatcher-class-number
    3
    0)
   6))

(define Linear-Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Linear-Dispatcher
    original-Linear-Dispatcher-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'no
                     original-Linear-Dispatcher-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'method
                     original-Linear-Dispatcher-class-number
                     2)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'signature
                     original-Linear-Dispatcher-class-number
                     3)))
          (fields1 ('#<procedure #32 ##vector-ref> Dispatcher-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (let ((lst2.1051
                                   ('#<procedure #7 ##cdr> lst2.1051)))
                              (if ('#<procedure #4 ##pair?> lst2.1051)
                                  (let ((x.1052 (instance-clone
                                                 ('#<procedure #6 ##car>
                                                  lst2.1051))))
                                    ('#<procedure #10 ##cons>
                                     x.1052
                                     (loop2.1050
                                      ('#<procedure #7 ##cdr> lst2.1051))))
                                  '()))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Dispatcher-class-number
    original-Linear-Dispatcher-class-number
    4
    0)
   6))

(define Global-Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Global-Dispatcher
    original-Global-Dispatcher-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Poly-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'method
                     original-Global-Dispatcher-class-number
                     1)))
          (fields1 ('#<procedure #32 ##vector-ref> Dispatcher-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (iota start
                ('#<procedure #21 ##fx+>
                 start
                 ('#<procedure #23 length> fields2)))))))
    2
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Dispatcher-class-number
    original-Global-Dispatcher-class-number
    5
    0)
   6))

(define Tracing-Dispatcher-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Tracing-Dispatcher
    original-Tracing-Dispatcher-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'dispatcher
                     original-Tracing-Dispatcher-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'default
                     original-Tracing-Dispatcher-class-number
                     2)))
          (fields1 ('#<procedure #32 ##vector-ref> Dispatcher-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (let ((lst2.1051
                                   ('#<procedure #7 ##cdr> lst2.1051)))
                              (if ('#<procedure #4 ##pair?> lst2.1051)
                                  (let ((x.1052 (instance-clone
                                                 ('#<procedure #6 ##car>
                                                  lst2.1051))))
                                    ('#<procedure #10 ##cons>
                                     x.1052
                                     (loop2.1050
                                      ('#<procedure #7 ##cdr> lst2.1051))))
                                  '()))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Dispatcher-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Dispatcher-class-number
    original-Tracing-Dispatcher-class-number
    6
    0)
   6))

(define Anomaly-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Anomaly
    original-Anomaly-class-number
    ('#<procedure #34 ##list>
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'category
      original-Anomaly-class-number
      0)
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'operator
      original-Anomaly-class-number
      1)
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Mono-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'message
      original-Anomaly-class-number
      2)
     ((lambda (immutable? name cn . path)
        (create-some-field
         original-Poly-Field-class-number
         immutable?
         name
         cn
         path))
      #t
      'hint
      original-Anomaly-class-number
      3))
    1
    original-Object-class-number
    ('#<procedure #34 ##list> original-Warning-class-number)
    2
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    3
    original-Object-class-number
    original-Anomaly-class-number
    0)
   6))

(define Warning-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Warning
    original-Warning-class-number
    (simple-append-fields
     ('#<procedure #32 ##vector-ref> Anomaly-class 3)
     ('#<procedure #34 ##list>))
    2
    original-Anomaly-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Anomaly-class-number
    original-Warning-class-number
    1
    0)
   6))

(define View-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'View
    original-View-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Poly-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'super
                     original-View-class-number
                     3)))
          (fields1 ('#<procedure #32 ##vector-ref> Pre-Class-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (loop2.1050 ('#<procedure #7 ##cdr> lst2.1051))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Pre-Class-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #t
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Pre-Class-class-number
    original-View-class-number
    0
    0)
   6))

(define Virtual-Field-class
  ('#<procedure #31 ##subtype-set!>
   ('#<procedure #68 ##vector>
    original-Class-class-number
    'Virtual-Field
    original-Virtual-Field-class-number
    (let ((fields2 ('#<procedure #34 ##list>
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #t
                     'view
                     original-Virtual-Field-class-number
                     1)
                    ((lambda (immutable? name cn . path)
                       (create-some-field
                        original-Mono-Field-class-number
                        immutable?
                        name
                        cn
                        path))
                     #f
                     'index
                     original-Virtual-Field-class-number
                     2)))
          (fields1 ('#<procedure #32 ##vector-ref> Pre-Field-class 3)))
      (let ((start ('#<procedure #23 length> fields1)))
        ('#<procedure #46 append>
         (letrec ((loop2.1050
                   (lambda (lst2.1051)
                     (if ('#<procedure #4 ##pair?> lst2.1051)
                         (let ((x.1052 (instance-clone
                                        ('#<procedure #6 ##car> lst2.1051))))
                           ('#<procedure #10 ##cons>
                            x.1052
                            (let ((lst2.1051
                                   ('#<procedure #7 ##cdr> lst2.1051)))
                              (if ('#<procedure #4 ##pair?> lst2.1051)
                                  (let ((x.1052 (instance-clone
                                                 ('#<procedure #6 ##car>
                                                  lst2.1051))))
                                    ('#<procedure #10 ##cons>
                                     x.1052
                                     (loop2.1050
                                      ('#<procedure #7 ##cdr> lst2.1051))))
                                  '()))))
                         '()))))
           (loop2.1050 fields1))
         ('#<procedure #69 map>
          (lambda (field index)
            (let ((begin-temp.326
                   ('#<procedure #33 ##vector-set!> field 7 index)))
              field))
          fields2
          (let ((end ('#<procedure #21 ##fx+>
                      start
                      ('#<procedure #23 length> fields2))))
            (if ('#<procedure #20 ##fx<> start end)
                ('#<procedure #10 ##cons>
                 start
                 (let ((start ('#<procedure #21 ##fx+> 1 start)))
                   (if ('#<procedure #20 ##fx<> start end)
                       ('#<procedure #10 ##cons>
                        start
                        (iota ('#<procedure #21 ##fx+> 1 start) end))
                       '())))
                '()))))))
    2
    original-Pre-Field-class-number
    ('#<procedure #34 ##list>)
    1
    meroon-uninitialized
    #f
    ('#<procedure #34 ##list>)
    5
    original-Object-class-number
    original-Pre-Field-class-number
    original-Virtual-Field-class-number
    4
    0)
   6))

(let ((temp.1054
       (let ((classes ('#<procedure #34 ##list>
                       Object-class
                       Pre-Class-class
                       Class-class
                       Handy-Class-class
                       MeroonV2-Class-class
                       Applyable-Object-class
                       Generic-class
                       Generic-1-class
                       Generic-N-class
                       Pre-Field-class
                       Field-class
                       Mono-Field-class
                       Poly-Field-class
                       Dispatcher-class
                       Immediate-Dispatcher-class
                       Subclass-Dispatcher-class
                       Indexed-Dispatcher-class
                       Linear-Dispatcher-class
                       Global-Dispatcher-class
                       Tracing-Dispatcher-class
                       Anomaly-class
                       Warning-class
                       View-class
                       Virtual-Field-class)))
         (let ((begin-temp.328
                (if ('#<procedure #50 ##fx=>
                     *class-number*
                     ('#<procedure #23 length> classes))
                    #!void
                    (oo-error 'genesis "Missed some classes"))))
           classes))))
  (letrec ((loop2.1055
            (lambda (lst2.1056)
              (if ('#<procedure #4 ##pair?> lst2.1056)
                  (let ((x.1057 (let ((class ('#<procedure #6 ##car>
                                              lst2.1056)))
                                  ('#<procedure #33 ##vector-set!>
                                   *classes*
                                   ('#<procedure #32 ##vector-ref> class 2)
                                   class))))
                    (let ((lst2.1056 ('#<procedure #7 ##cdr> lst2.1056)))
                      (if ('#<procedure #4 ##pair?> lst2.1056)
                          (let ((x.1057 (let ((class ('#<procedure #6 ##car>
                                                      lst2.1056)))
                                          ('#<procedure #33 ##vector-set!>
                                           *classes*
                                           ('#<procedure #32 ##vector-ref>
                                            class
                                            2)
                                           class))))
                            (loop2.1055 ('#<procedure #7 ##cdr> lst2.1056)))
                          #!void)))
                  #!void))))
    (loop2.1055 temp.1054)))

(define Pre-Class?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Pre-Class-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Pre-Class-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Class?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (careless-subclass?
          ('#<procedure #32 ##vector-ref>
           *classes*
           ('#<procedure #32 ##vector-ref> o 0))
          Class-class))))

(define Handy-Class?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Handy-Class-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Handy-Class-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define MeroonV2-Class?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          MeroonV2-Class-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref> MeroonV2-Class-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Applyable-Object?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Applyable-Object-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Applyable-Object-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Generic?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Generic-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Generic-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Generic-1?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Generic-1-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Generic-1-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Generic-N?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Generic-N-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Generic-N-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Pre-Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Pre-Field-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Pre-Field-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Field-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Field-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Mono-Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Mono-Field-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Mono-Field-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Poly-Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Poly-Field-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Poly-Field-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Dispatcher-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Dispatcher-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Immediate-Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Immediate-Dispatcher-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Immediate-Dispatcher-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Subclass-Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Subclass-Dispatcher-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Subclass-Dispatcher-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Indexed-Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Indexed-Dispatcher-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Indexed-Dispatcher-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Linear-Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Linear-Dispatcher-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Linear-Dispatcher-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Global-Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Global-Dispatcher-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Global-Dispatcher-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Tracing-Dispatcher?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Tracing-Dispatcher-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Tracing-Dispatcher-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Anomaly?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Anomaly-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Anomaly-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Warning?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> Warning-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> Warning-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define View?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref> View-class 4))
                 (cn2 ('#<procedure #32 ##vector-ref> View-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Virtual-Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Virtual-Field-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref> Virtual-Field-class 2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define Pre-Class-name
  (Mono-Field-create-careful-reader Pre-Class-class 'name))

(define Pre-Class-number
  (Mono-Field-create-careful-reader Pre-Class-class 'number))

(define Pre-Class-fields
  (Mono-Field-create-careful-reader Pre-Class-class 'fields))

(define Class-name (Mono-Field-create-careful-reader Class-class 'name))

(define Class-number (Mono-Field-create-careful-reader Class-class 'number))

(define Class-fields (Mono-Field-create-careful-reader Class-class 'fields))

(define Class-depth (Mono-Field-create-careful-reader Class-class 'depth))

(define Class-super-number
  (Mono-Field-create-careful-reader Class-class 'super-number))

(define Class-subclass-numbers
  (Mono-Field-create-careful-reader Class-class 'subclass-numbers))

(define set-Class-subclass-numbers!
  (Mono-Field-create-careful-writer Class-class 'subclass-numbers))

(define Class-next (Mono-Field-create-careful-reader Class-class 'next))

(define set-Class-next! (Mono-Field-create-careful-writer Class-class 'next))

(define Class-allocator
  (Mono-Field-create-careful-reader Class-class 'allocator))

(define Class-immutable?
  (Mono-Field-create-careful-reader Class-class 'immutable?))

(define Class-views (Mono-Field-create-careful-reader Class-class 'views))

(define Class-suprel-length
  (Poly-Field-create-careful-lengther Class-class 'suprel))

(define Class-suprel (Poly-Field-create-careful-reader Class-class 'suprel))

(define Handy-Class-name
  (Mono-Field-create-careful-reader Handy-Class-class 'name))

(define Handy-Class-number
  (Mono-Field-create-careful-reader Handy-Class-class 'number))

(define Handy-Class-fields
  (Mono-Field-create-careful-reader Handy-Class-class 'fields))

(define Handy-Class-depth
  (Mono-Field-create-careful-reader Handy-Class-class 'depth))

(define Handy-Class-super-number
  (Mono-Field-create-careful-reader Handy-Class-class 'super-number))

(define Handy-Class-subclass-numbers
  (Mono-Field-create-careful-reader Handy-Class-class 'subclass-numbers))

(define set-Handy-Class-subclass-numbers!
  (Mono-Field-create-careful-writer Handy-Class-class 'subclass-numbers))

(define Handy-Class-next
  (Mono-Field-create-careful-reader Handy-Class-class 'next))

(define set-Handy-Class-next!
  (Mono-Field-create-careful-writer Handy-Class-class 'next))

(define Handy-Class-allocator
  (Mono-Field-create-careful-reader Handy-Class-class 'allocator))

(define Handy-Class-immutable?
  (Mono-Field-create-careful-reader Handy-Class-class 'immutable?))

(define Handy-Class-views
  (Mono-Field-create-careful-reader Handy-Class-class 'views))

(define Handy-Class-suprel-length
  (Poly-Field-create-careful-lengther Handy-Class-class 'suprel))

(define Handy-Class-suprel
  (Poly-Field-create-careful-reader Handy-Class-class 'suprel))

(define MeroonV2-Class-name
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'name))

(define MeroonV2-Class-number
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'number))

(define MeroonV2-Class-fields
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'fields))

(define MeroonV2-Class-depth
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'depth))

(define MeroonV2-Class-super-number
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'super-number))

(define MeroonV2-Class-subclass-numbers
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'subclass-numbers))

(define set-MeroonV2-Class-subclass-numbers!
  (Mono-Field-create-careful-writer MeroonV2-Class-class 'subclass-numbers))

(define MeroonV2-Class-next
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'next))

(define set-MeroonV2-Class-next!
  (Mono-Field-create-careful-writer MeroonV2-Class-class 'next))

(define MeroonV2-Class-allocator
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'allocator))

(define MeroonV2-Class-immutable?
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'immutable?))

(define MeroonV2-Class-views
  (Mono-Field-create-careful-reader MeroonV2-Class-class 'views))

(define MeroonV2-Class-suprel-length
  (Poly-Field-create-careful-lengther MeroonV2-Class-class 'suprel))

(define MeroonV2-Class-suprel
  (Poly-Field-create-careful-reader MeroonV2-Class-class 'suprel))

(define Generic-name (Mono-Field-create-careful-reader Generic-class 'name))

(define Generic-default
  (Mono-Field-create-careful-reader Generic-class 'default))

(define set-Generic-default!
  (Mono-Field-create-careful-writer Generic-class 'default))

(define Generic-variables
  (Mono-Field-create-careful-reader Generic-class 'variables))

(define Generic-dispatcher
  (Mono-Field-create-careful-reader Generic-class 'dispatcher))

(define set-Generic-dispatcher!
  (Mono-Field-create-careful-writer Generic-class 'dispatcher))

(define Generic-top-classes
  (Mono-Field-create-careful-reader Generic-class 'top-classes))

(define Generic-1-name
  (Mono-Field-create-careful-reader Generic-1-class 'name))

(define Generic-1-default
  (Mono-Field-create-careful-reader Generic-1-class 'default))

(define set-Generic-1-default!
  (Mono-Field-create-careful-writer Generic-1-class 'default))

(define Generic-1-variables
  (Mono-Field-create-careful-reader Generic-1-class 'variables))

(define Generic-1-dispatcher
  (Mono-Field-create-careful-reader Generic-1-class 'dispatcher))

(define set-Generic-1-dispatcher!
  (Mono-Field-create-careful-writer Generic-1-class 'dispatcher))

(define Generic-1-top-classes
  (Mono-Field-create-careful-reader Generic-1-class 'top-classes))

(define Generic-N-name
  (Mono-Field-create-careful-reader Generic-N-class 'name))

(define Generic-N-default
  (Mono-Field-create-careful-reader Generic-N-class 'default))

(define set-Generic-N-default!
  (Mono-Field-create-careful-writer Generic-N-class 'default))

(define Generic-N-variables
  (Mono-Field-create-careful-reader Generic-N-class 'variables))

(define Generic-N-dispatcher
  (Mono-Field-create-careful-reader Generic-N-class 'dispatcher))

(define set-Generic-N-dispatcher!
  (Mono-Field-create-careful-writer Generic-N-class 'dispatcher))

(define Generic-N-top-classes
  (Mono-Field-create-careful-reader Generic-N-class 'top-classes))

(define Pre-Field-name
  (Mono-Field-create-careful-reader Pre-Field-class 'name))

(define Field-name (Mono-Field-create-careful-reader Field-class 'name))

(define Field-immutable?
  (Mono-Field-create-careful-reader Field-class 'immutable?))

(define Field-class-number
  (Mono-Field-create-careful-reader Field-class 'class-number))

(define set-Field-class-number!
  (Mono-Field-create-careful-writer Field-class 'class-number))

(define Field-initialized?
  (Mono-Field-create-careful-reader Field-class 'initialized?))

(define Field-initializer
  (Mono-Field-create-careful-reader Field-class 'initializer))

(define set-Field-initializer!
  (Mono-Field-create-careful-writer Field-class 'initializer))

(define Field-path-length
  (Poly-Field-create-careful-lengther Field-class 'path))

(define Field-path (Poly-Field-create-careful-reader Field-class 'path))

(define Mono-Field-name
  (Mono-Field-create-careful-reader Mono-Field-class 'name))

(define Mono-Field-immutable?
  (Mono-Field-create-careful-reader Mono-Field-class 'immutable?))

(define Mono-Field-class-number
  (Mono-Field-create-careful-reader Mono-Field-class 'class-number))

(define set-Mono-Field-class-number!
  (Mono-Field-create-careful-writer Mono-Field-class 'class-number))

(define Mono-Field-initialized?
  (Mono-Field-create-careful-reader Mono-Field-class 'initialized?))

(define Mono-Field-initializer
  (Mono-Field-create-careful-reader Mono-Field-class 'initializer))

(define set-Mono-Field-initializer!
  (Mono-Field-create-careful-writer Mono-Field-class 'initializer))

(define Mono-Field-path-length
  (Poly-Field-create-careful-lengther Mono-Field-class 'path))

(define Mono-Field-path
  (Poly-Field-create-careful-reader Mono-Field-class 'path))

(define Poly-Field-name
  (Mono-Field-create-careful-reader Poly-Field-class 'name))

(define Poly-Field-immutable?
  (Mono-Field-create-careful-reader Poly-Field-class 'immutable?))

(define Poly-Field-class-number
  (Mono-Field-create-careful-reader Poly-Field-class 'class-number))

(define set-Poly-Field-class-number!
  (Mono-Field-create-careful-writer Poly-Field-class 'class-number))

(define Poly-Field-initialized?
  (Mono-Field-create-careful-reader Poly-Field-class 'initialized?))

(define Poly-Field-initializer
  (Mono-Field-create-careful-reader Poly-Field-class 'initializer))

(define set-Poly-Field-initializer!
  (Mono-Field-create-careful-writer Poly-Field-class 'initializer))

(define Poly-Field-path-length
  (Poly-Field-create-careful-lengther Poly-Field-class 'path))

(define Poly-Field-path
  (Poly-Field-create-careful-reader Poly-Field-class 'path))

(define Dispatcher-method-finder
  (Mono-Field-create-careful-reader Dispatcher-class 'method-finder))

(define Immediate-Dispatcher-method-finder
  (Mono-Field-create-careful-reader Immediate-Dispatcher-class 'method-finder))

(define Immediate-Dispatcher-method
  (Mono-Field-create-careful-reader Immediate-Dispatcher-class 'method))

(define Subclass-Dispatcher-method-finder
  (Mono-Field-create-careful-reader Subclass-Dispatcher-class 'method-finder))

(define Subclass-Dispatcher-class-number
  (Mono-Field-create-careful-reader Subclass-Dispatcher-class 'class-number))

(define Subclass-Dispatcher-class-depth
  (Mono-Field-create-careful-reader Subclass-Dispatcher-class 'class-depth))

(define Subclass-Dispatcher-no
  (Mono-Field-create-careful-reader Subclass-Dispatcher-class 'no))

(define set-Subclass-Dispatcher-no!
  (Mono-Field-create-careful-writer Subclass-Dispatcher-class 'no))

(define Subclass-Dispatcher-yes
  (Mono-Field-create-careful-reader Subclass-Dispatcher-class 'yes))

(define set-Subclass-Dispatcher-yes!
  (Mono-Field-create-careful-writer Subclass-Dispatcher-class 'yes))

(define Indexed-Dispatcher-method-finder
  (Mono-Field-create-careful-reader Indexed-Dispatcher-class 'method-finder))

(define Indexed-Dispatcher-class-number
  (Mono-Field-create-careful-reader Indexed-Dispatcher-class 'class-number))

(define Indexed-Dispatcher-class-depth
  (Mono-Field-create-careful-reader Indexed-Dispatcher-class 'class-depth))

(define Indexed-Dispatcher-no
  (Mono-Field-create-careful-reader Indexed-Dispatcher-class 'no))

(define set-Indexed-Dispatcher-no!
  (Mono-Field-create-careful-writer Indexed-Dispatcher-class 'no))

(define Indexed-Dispatcher-method-length
  (Poly-Field-create-careful-lengther Indexed-Dispatcher-class 'method))

(define Indexed-Dispatcher-method
  (Poly-Field-create-careful-reader Indexed-Dispatcher-class 'method))

(define set-Indexed-Dispatcher-method!
  (Poly-Field-create-careful-writer Indexed-Dispatcher-class 'method))

(define Linear-Dispatcher-method-finder
  (Mono-Field-create-careful-reader Linear-Dispatcher-class 'method-finder))

(define Linear-Dispatcher-no
  (Mono-Field-create-careful-reader Linear-Dispatcher-class 'no))

(define set-Linear-Dispatcher-no!
  (Mono-Field-create-careful-writer Linear-Dispatcher-class 'no))

(define Linear-Dispatcher-method
  (Mono-Field-create-careful-reader Linear-Dispatcher-class 'method))

(define set-Linear-Dispatcher-method!
  (Mono-Field-create-careful-writer Linear-Dispatcher-class 'method))

(define Linear-Dispatcher-signature
  (Mono-Field-create-careful-reader Linear-Dispatcher-class 'signature))

(define set-Linear-Dispatcher-signature!
  (Mono-Field-create-careful-writer Linear-Dispatcher-class 'signature))

(define Global-Dispatcher-method-finder
  (Mono-Field-create-careful-reader Global-Dispatcher-class 'method-finder))

(define Global-Dispatcher-method-length
  (Poly-Field-create-careful-lengther Global-Dispatcher-class 'method))

(define Global-Dispatcher-method
  (Poly-Field-create-careful-reader Global-Dispatcher-class 'method))

(define set-Global-Dispatcher-method!
  (Poly-Field-create-careful-writer Global-Dispatcher-class 'method))

(define Tracing-Dispatcher-method-finder
  (Mono-Field-create-careful-reader Tracing-Dispatcher-class 'method-finder))

(define Tracing-Dispatcher-dispatcher
  (Mono-Field-create-careful-reader Tracing-Dispatcher-class 'dispatcher))

(define set-Tracing-Dispatcher-dispatcher!
  (Mono-Field-create-careful-writer Tracing-Dispatcher-class 'dispatcher))

(define Tracing-Dispatcher-default
  (Mono-Field-create-careful-reader Tracing-Dispatcher-class 'default))

(define Anomaly-category
  (Mono-Field-create-careful-reader Anomaly-class 'category))

(define Anomaly-operator
  (Mono-Field-create-careful-reader Anomaly-class 'operator))

(define Anomaly-message
  (Mono-Field-create-careful-reader Anomaly-class 'message))

(define Anomaly-hint-length
  (Poly-Field-create-careful-lengther Anomaly-class 'hint))

(define Anomaly-hint (Poly-Field-create-careful-reader Anomaly-class 'hint))

(define Warning-category
  (Mono-Field-create-careful-reader Warning-class 'category))

(define Warning-operator
  (Mono-Field-create-careful-reader Warning-class 'operator))

(define Warning-message
  (Mono-Field-create-careful-reader Warning-class 'message))

(define Warning-hint-length
  (Poly-Field-create-careful-lengther Warning-class 'hint))

(define Warning-hint (Poly-Field-create-careful-reader Warning-class 'hint))

(define View-name (Mono-Field-create-careful-reader View-class 'name))

(define View-number (Mono-Field-create-careful-reader View-class 'number))

(define View-fields (Mono-Field-create-careful-reader View-class 'fields))

(define View-super-length
  (Poly-Field-create-careful-lengther View-class 'super))

(define View-super (Poly-Field-create-careful-reader View-class 'super))

(define Virtual-Field-name
  (Mono-Field-create-careful-reader Virtual-Field-class 'name))

(define Virtual-Field-view
  (Mono-Field-create-careful-reader Virtual-Field-class 'view))

(define Virtual-Field-index
  (Mono-Field-create-careful-reader Virtual-Field-class 'index))

(define set-Virtual-Field-index!
  (Mono-Field-create-careful-writer Virtual-Field-class 'index))

(define make-Object (make-maker Object-class))

(define make-Pre-Class (make-maker Pre-Class-class))

(define make-Class (make-maker Class-class))

(define make-Handy-Class (make-maker Handy-Class-class))

(define make-MeroonV2-Class (make-maker MeroonV2-Class-class))

(define make-Applyable-Object (make-maker Applyable-Object-class))

(define make-Generic (make-maker Generic-class))

(define make-Generic-1 (make-maker Generic-1-class))

(define make-Generic-N (make-maker Generic-N-class))

(define make-Pre-Field (make-maker Pre-Field-class))

(define make-Field (make-maker Field-class))

(define make-Mono-Field (make-maker Mono-Field-class))

(define make-Poly-Field (make-maker Poly-Field-class))

(define make-Dispatcher (make-maker Dispatcher-class))

(define make-Immediate-Dispatcher (make-maker Immediate-Dispatcher-class))

(define make-Subclass-Dispatcher (make-maker Subclass-Dispatcher-class))

(define make-Indexed-Dispatcher (make-maker Indexed-Dispatcher-class))

(define make-Linear-Dispatcher (make-maker Linear-Dispatcher-class))

(define make-Global-Dispatcher (make-maker Global-Dispatcher-class))

(define make-Tracing-Dispatcher (make-maker Tracing-Dispatcher-class))

(define make-Anomaly (make-maker Anomaly-class))

(define make-Warning (make-maker Warning-class))

(define make-View (make-maker View-class))

(define make-Virtual-Field (make-maker Virtual-Field-class))

(sequence-map
 (lambda (class)
   (if class
       (let ((a (create-allocator class)))
         ('#<procedure #33 ##vector-set!> class 8 a))
       #!void))
 *classes*)

(define process-instantiate-form
  (lambda (class-name parms)
    (process-instantiation
     (symbol->class
      class-name
      (lambda (name)
        (report-meroon-error 'Syntax 'instantiate "Unknown class" name)))
     parms)))

(define *maximal-explicit-allocation-size* 25)

(define process-instantiation
  (lambda (class parms)
    (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
      (let ((class-name
             (symbol-concatenate
              ('#<procedure #32 ##vector-ref> class 1)
              '-class)))
        (let ((contents
               (process-initialization fields parms find-initialization)))
          (if (and (every? (lambda (content)
                             ('#<procedure #58 ##fixnum?>
                              ('#<procedure #6 ##car> content)))
                           contents)
                   ('#<procedure #49 ##fx<=>
                    (meroon-reduce
                     (lambda (sum content)
                       ('#<procedure #21 ##fx+>
                        sum
                        ('#<procedure #6 ##car> content)))
                     0
                     contents)
                    25))
              (let ((filling (meroon-reduce
                              (lambda (forms field content)
                                (generate-content field content forms))
                              '()
                              fields
                              contents)))
                (if (letrec ((loop.1060
                              (lambda (lst1.1061)
                                (if ('#<procedure #4 ##pair?> lst1.1061)
                                    (let ((x.1062 ('#<procedure #6 ##car>
                                                   lst1.1061)))
                                      (if ('#<procedure #3 ##eq?>
                                           'meroon-uninitialized
                                           x.1062)
                                          lst1.1061
                                          (loop.1060
                                           ('#<procedure #7 ##cdr>
                                            lst1.1061))))
                                    #f))))
                      (loop.1060 filling))
                    ('#<procedure #44 ##quasi-list>
                     'initialize!
                     ('#<procedure #44 ##quasi-list>
                      'fill-other-fields!
                      ('#<procedure #43 ##quasi-cons>
                       'instance
                       ('#<procedure #43 ##quasi-cons>
                        ('#<procedure #44 ##quasi-list>
                         'careless-Class-number
                         class-name)
                        filling))))
                    ('#<procedure #44 ##quasi-list>
                     'initialize!
                     ('#<procedure #43 ##quasi-cons>
                      'instance
                      ('#<procedure #43 ##quasi-cons>
                       ('#<procedure #44 ##quasi-list>
                        'careless-Class-number
                        class-name)
                       filling)))))
              (let ((index (gensym)) (g (gensym)))
                ('#<procedure #43 ##quasi-cons>
                 'let
                 ('#<procedure #43 ##quasi-cons>
                  ('#<procedure #44 ##quasi-list>
                   ('#<procedure #43 ##quasi-cons> index '(0))
                   ('#<procedure #44 ##quasi-list>
                    g
                    ('#<procedure #43 ##quasi-cons>
                     ('#<procedure #44 ##quasi-list>
                      'careless-Class-allocator
                      class-name)
                     (meroon-reduce
                      (lambda (forms field content)
                        (generate-size field content forms))
                      '()
                      fields
                      contents))))
                  ('#<procedure #45 ##quasi-append>
                   (meroon-reduce
                    (lambda (forms field content)
                      (generate-initialization field content g index forms))
                    '()
                    fields
                    contents)
                   ('#<procedure #44 ##quasi-list>
                    ('#<procedure #44 ##quasi-list>
                     'initialize!
                     ('#<procedure #44 ##quasi-list>
                      'fill-other-fields!
                      g)))))))))))))

(define generate-whole-content
  (lambda (fields contents)
    (meroon-reduce
     (lambda (forms field content) (generate-content field content forms))
     '()
     fields
     contents)))

(define generate-whole-size
  (lambda (fields contents)
    (meroon-reduce
     (lambda (forms field content) (generate-size field content forms))
     '()
     fields
     contents)))

(define generate-whole-initialization
  (lambda (ovar index fields contents)
    (meroon-reduce
     (lambda (forms field content)
       (generate-initialization field content ovar index forms))
     '()
     fields
     contents)))

(define process-initialization
  (lambda (fields parms finder)
    (letrec ((iterate (lambda (finder fields parms)
                        (if ('#<procedure #4 ##pair?> fields)
                            (finder ('#<procedure #6 ##car> fields)
                                    parms
                                    (lambda (init other-parms)
                                      ('#<procedure #10 ##cons>
                                       init
                                       (iterate finder
                                                ('#<procedure #7 ##cdr> fields)
                                                other-parms))))
                            (let ((begin-temp.329
                                   (if ('#<procedure #4 ##pair?> parms)
                                       (report-meroon-error
                                        'Syntax
                                        'instantiate
                                        "Unused options"
                                        parms)
                                       #!void)))
                              '())))))
      (iterate finder fields parms))))

(define find-initialization
  (let ((#:g540 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.330
           ('#<procedure #63 ##set-box!>
            #:g540
            (register-Generic-1
             '(1 . 1)
             'find-initialization
             meroon-uninitialized
             '((f Field) parms k)
             'Field))))
      (lambda (f parms k)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g540) f)
         f
         parms
         k)))))

(register-method
 'find-initialization
 '((f Mono-Field) parms k)
 '(1 . 1)
 (lambda (#:g542 #:g543 #:g544)
   (lambda (f parms k)
     (let ((form (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                   (let ((kw+values (find-option-plus-values keyword parms)))
                     (if ('#<procedure #4 ##pair?> kw+values)
                         (let ((values ('#<procedure #7 ##cdr> kw+values)))
                           (if (and ('#<procedure #4 ##pair?> values)
                                    ('#<procedure #24 ##null?>
                                     ('#<procedure #7 ##cdr> values)))
                               ('#<procedure #6 ##car> values)
                               (report-meroon-error
                                'Syntax
                                'find-option
                                "This option expects a single value"
                                keyword
                                values)))
                         meroon-option-not-there)))))
       (let ((other-parms
              (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                (letrec ((skip (lambda (keyword options)
                                 (if ('#<procedure #4 ##pair?> options)
                                     (if (and (let ((e ('#<procedure #6 ##car>
                                                        options)))
                                                (or ('#<procedure #59 ##keyword?>
                                                     e)
                                                    (and ('#<procedure #16 ##symbol?>
                                                          e)
                                                         ('#<procedure #60 ##char=?>
                                                          ('#<procedure #37 ##string-ref>
                                                           ('#<procedure #17 symbol->string>
                                                            e)
                                                           0)
                                                          #\:))))
                                              (meroon-keyword-eq?
                                               ('#<procedure #6 ##car> options)
                                               keyword))
                                         (skip2next-keyword
                                          ('#<procedure #7 ##cdr> options))
                                         ('#<procedure #10 ##cons>
                                          ('#<procedure #6 ##car> options)
                                          (skip keyword
                                                ('#<procedure #7 ##cdr>
                                                 options))))
                                     '()))))
                  (skip keyword parms)))))
         (if ('#<procedure #3 ##eq?> form meroon-option-not-there)
             (if (and ('#<procedure #32 ##vector-ref> f 4)
                      ('#<procedure #5 ##not> (field-defined? f 'initializer)))
                 (report-meroon-error
                  'Syntax
                  'instantiate
                  "This field should be initialized"
                  f)
                 (k ('#<procedure #34 ##list> 1 'meroon-uninitialized)
                    other-parms))
             (k ('#<procedure #34 ##list> 1 form) other-parms))))))
 'Mono-Field)

(register-method
 'find-initialization
 '((f Poly-Field) parms k)
 '(1 . 1)
 (lambda (#:g546 #:g547 #:g548)
   (lambda (f parms k)
     (let ((content (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                      (let ((kw+values
                             (find-option-plus-values keyword parms)))
                        (if ('#<procedure #4 ##pair?> kw+values)
                            ('#<procedure #7 ##cdr> kw+values)
                            meroon-option-not-there)))))
       (let ((parms (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                      (letrec ((skip (lambda (keyword options)
                                       (if ('#<procedure #4 ##pair?> options)
                                           (if (and (let ((e ('#<procedure #6 ##car>
                                                              options)))
                                                      (or ('#<procedure #59 ##keyword?>
                                                           e)
                                                          (and ('#<procedure #16 ##symbol?>
                                                                e)
                                                               ('#<procedure #60 ##char=?>
                                                                ('#<procedure #37 ##string-ref>
                                                                 ('#<procedure #17 symbol->string>
                                                                  e)
                                                                 0)
                                                                #\:))))
                                                    (meroon-keyword-eq?
                                                     ('#<procedure #6 ##car>
                                                      options)
                                                     keyword))
                                               (skip2next-keyword
                                                ('#<procedure #7 ##cdr>
                                                 options))
                                               ('#<procedure #10 ##cons>
                                                ('#<procedure #6 ##car>
                                                 options)
                                                (skip keyword
                                                      ('#<procedure #7 ##cdr>
                                                       options))))
                                           '()))))
                        (skip keyword parms)))))
         (let ((kw ('#<procedure #34 ##list>
                    ('#<procedure #32 ##vector-ref> f 1)
                    '-length)))
           (if ('#<procedure #3 ##eq?> content meroon-option-not-there)
               (let ((size (find-option-single-value
                            kw
                            parms
                            option-not-there)))
                 (let ((parms (remove-option kw parms)))
                   (if ('#<procedure #3 ##eq?> size meroon-option-not-there)
                       (report-meroon-error
                        'Syntax
                        'instantiate
                        "This field has no size specified"
                        f)
                       (k ('#<procedure #34 ##list> size) parms))))
               (let ((begin-temp.331
                      (if (let ((e (find-option-single-value
                                    kw
                                    parms
                                    option-not-there)))
                            ('#<procedure #3 ##eq?> e meroon-option-not-there))
                          #!void
                          (report-meroon-error
                           'Syntax
                           'instantiate
                           "Simultaneously incompatible options"
                           ('#<procedure #32 ##vector-ref> f 1)
                           kw))))
                 (k ('#<procedure #10 ##cons>
                     ('#<procedure #23 length> content)
                     content)
                    parms))))))))
 'Poly-Field)

(define generate-content
  (let ((#:g550 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.332
           ('#<procedure #63 ##set-box!>
            #:g550
            (register-Generic-1
             '(1 . 1)
             'generate-content
             meroon-uninitialized
             '((field Field) content forms)
             'Field))))
      (lambda (field content forms)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g550) field)
         field
         content
         forms)))))

(register-method
 'generate-content
 '((field Mono-Field) content forms)
 '(1 . 1)
 (lambda (#:g552 #:g553 #:g554)
   (lambda (field content forms)
     ('#<procedure #10 ##cons> ('#<procedure #67 ##cadr> content) forms)))
 'Mono-Field)

(register-method
 'generate-content
 '((field Poly-Field) content forms)
 '(1 . 1)
 (lambda (#:g556 #:g557 #:g558)
   (lambda (field content forms)
     (let ((init-forms ('#<procedure #7 ##cdr> content))
           (size ('#<procedure #6 ##car> content)))
       (if ('#<procedure #50 ##fx=> size ('#<procedure #23 length> init-forms))
           ('#<procedure #46 append> content forms)
           ('#<procedure #10 ##cons>
            size
            (letrec ((make-list
                      (lambda (forms size)
                        (if ('#<procedure #53 ##fx>> size 0)
                            ('#<procedure #10 ##cons>
                             'meroon-uninitialized
                             (let ((size ('#<procedure #39 ##fx-> size 1)))
                               (if ('#<procedure #53 ##fx>> size 0)
                                   ('#<procedure #10 ##cons>
                                    'meroon-uninitialized
                                    (make-list
                                     forms
                                     ('#<procedure #39 ##fx-> size 1)))
                                   forms)))
                            forms))))
              (make-list forms size)))))))
 'Poly-Field)

(define generate-size
  (let ((#:g560 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.333
           ('#<procedure #63 ##set-box!>
            #:g560
            (register-Generic-1
             '(1 . 1)
             'generate-size
             meroon-uninitialized
             '((field Field) content forms)
             'Field))))
      (lambda (field content forms)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g560) field)
         field
         content
         forms)))))

(register-method
 'generate-size
 '((field Mono-Field) content forms)
 '(1 . 1)
 (lambda (#:g562 #:g563 #:g564) (lambda (field content forms) forms))
 'Mono-Field)

(register-method
 'generate-size
 '((field Poly-Field) content forms)
 '(1 . 1)
 (lambda (#:g566 #:g567 #:g568)
   (lambda (field content forms)
     ('#<procedure #10 ##cons> ('#<procedure #6 ##car> content) forms)))
 'Poly-Field)

(define generate-initialization
  (let ((#:g570 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.334
           ('#<procedure #63 ##set-box!>
            #:g570
            (register-Generic-1
             '(1 . 1)
             'generate-initialization
             meroon-uninitialized
             '((field Field) content ovar indexvar forms)
             'Field))))
      (lambda (field content ovar indexvar forms)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g570) field)
         field
         content
         ovar
         indexvar
         forms)))))

(register-method
 'generate-initialization
 '((field Mono-Field) content ovar indexvar forms)
 '(1 . 1)
 (lambda (#:g572 #:g573 #:g574)
   (lambda (field content ovar indexvar forms)
     (if ('#<procedure #3 ##eq?>
          'meroon-uninitialized
          ('#<procedure #67 ##cadr> content))
         (adjust-index
          ('#<procedure #44 ##quasi-list>
           'set!
           indexvar
           ('#<procedure #44 ##quasi-list> 'fx+ 1 indexvar))
          forms)
         ('#<procedure #10 ##cons>
          ('#<procedure #44 ##quasi-list>
           'instance-set!
           ovar
           indexvar
           ('#<procedure #67 ##cadr> content))
          (adjust-index
           ('#<procedure #44 ##quasi-list>
            'set!
            indexvar
            ('#<procedure #44 ##quasi-list> 'fx+ 1 indexvar))
           forms)))))
 'Mono-Field)

(register-method
 'generate-initialization
 '((field Poly-Field) content ovar indexvar forms)
 '(1 . 1)
 (lambda (#:g576 #:g577 #:g578)
   (lambda (field content ovar indexvar forms)
     (if ('#<procedure #24 ##null?> ('#<procedure #7 ##cdr> content))
         (if ('#<procedure #58 ##fixnum?> ('#<procedure #6 ##car> content))
             (adjust-index
              ('#<procedure #44 ##quasi-list>
               'set!
               indexvar
               ('#<procedure #44 ##quasi-list>
                'fx+
                ('#<procedure #21 ##fx+> 1 ('#<procedure #6 ##car> content))
                indexvar))
              forms)
             (adjust-index
              ('#<procedure #44 ##quasi-list>
               'set!
               indexvar
               ('#<procedure #44 ##quasi-list>
                'fx+
                1
                ('#<procedure #44 ##quasi-list> 'instance-ref ovar indexvar)
                indexvar))
              forms))
         ('#<procedure #10 ##cons>
          ('#<procedure #44 ##quasi-list>
           'instance-set!
           ovar
           indexvar
           ('#<procedure #23 length> ('#<procedure #7 ##cdr> content)))
          (let ((forms (letrec ((enum (lambda (ovar indexvar forms contents)
                                        (if ('#<procedure #4 ##pair?> contents)
                                            ('#<procedure #10 ##cons>
                                             ('#<procedure #44 ##quasi-list>
                                              'instance-set!
                                              ovar
                                              indexvar
                                              ('#<procedure #6 ##car>
                                               contents))
                                             (adjust-index
                                              ('#<procedure #44 ##quasi-list>
                                               'set!
                                               indexvar
                                               ('#<procedure #44 ##quasi-list>
                                                'fx+
                                                1
                                                indexvar))
                                              (let ((contents
                                                     ('#<procedure #7 ##cdr>
                                                      contents)))
                                                (if ('#<procedure #4 ##pair?>
                                                     contents)
                                                    ('#<procedure #10 ##cons>
                                                     ('#<procedure #44 ##quasi-list>
                                                      'instance-set!
                                                      ovar
                                                      indexvar
                                                      ('#<procedure #6 ##car>
                                                       contents))
                                                     (adjust-index
                                                      ('#<procedure #44 ##quasi-list>
                                                       'set!
                                                       indexvar
                                                       ('#<procedure #44 ##quasi-list>
                                                        'fx+
                                                        1
                                                        indexvar))
                                                      (let ((contents
                                                             ('#<procedure #7 ##cdr>
                                                              contents)))
                                                        (if ('#<procedure #4 ##pair?>
                                                             contents)
                                                            ('#<procedure #10 ##cons>
                                                             ('#<procedure #44 ##quasi-list>
                                                              'instance-set!
                                                              ovar
                                                              indexvar
                                                              ('#<procedure #6 ##car>
                                                               contents))
                                                             (adjust-index
                                                              ('#<procedure #44 ##quasi-list>
                                                               'set!
                                                               indexvar
                                                               ('#<procedure #44 ##quasi-list>
                                                                'fx+
                                                                1
                                                                indexvar))
                                                              (enum ovar
                                                                    indexvar
                                                                    forms
                                                                    ('#<procedure #7 ##cdr>
                                                                     contents))))
                                                            forms))))
                                                    forms))))
                                            forms))))
                         (enum ovar
                               indexvar
                               forms
                               ('#<procedure #7 ##cdr> content))))
                (expression
                 ('#<procedure #44 ##quasi-list>
                  'set!
                  indexvar
                  ('#<procedure #44 ##quasi-list> 'fx+ 1 indexvar))))
            (if ('#<procedure #24 ##null?> forms)
                forms
                (if (and ('#<procedure #4 ##pair?>
                          ('#<procedure #6 ##car> forms))
                         (and ('#<procedure #3 ##eq?>
                               ('#<procedure #6 ##car>
                                ('#<procedure #6 ##car> forms))
                               'set!)
                              (and ('#<procedure #3 ##eq?>
                                    ('#<procedure #6 ##car>
                                     ('#<procedure #66 ##caddr>
                                      ('#<procedure #6 ##car> forms)))
                                    '+)
                                   (and ('#<procedure #50 ##fx=>
                                         ('#<procedure #23 length>
                                          ('#<procedure #66 ##caddr>
                                           ('#<procedure #6 ##car> forms)))
                                         3)
                                        ('#<procedure #50 ##fx=>
                                         ('#<procedure #23 length>
                                          ('#<procedure #66 ##caddr>
                                           expression))
                                         3)))))
                    (let ((n2 ('#<procedure #67 ##cadr>
                               ('#<procedure #66 ##caddr> expression)))
                          (n1 ('#<procedure #67 ##cadr>
                               ('#<procedure #66 ##caddr>
                                ('#<procedure #6 ##car> forms)))))
                      ('#<procedure #10 ##cons>
                       ('#<procedure #44 ##quasi-list>
                        'set!
                        ('#<procedure #67 ##cadr> expression)
                        ('#<procedure #44 ##quasi-list>
                         'fx+
                         ('#<procedure #21 ##fx+> n1 n2)
                         ('#<procedure #66 ##caddr>
                          ('#<procedure #66 ##caddr>
                           ('#<procedure #6 ##car> forms)))))
                       ('#<procedure #7 ##cdr> forms)))
                    ('#<procedure #10 ##cons> expression forms))))))))
 'Poly-Field)

(define adjust-index
  (lambda (expression forms)
    (if ('#<procedure #24 ##null?> forms)
        forms
        (if (and ('#<procedure #4 ##pair?> ('#<procedure #6 ##car> forms))
                 (and ('#<procedure #3 ##eq?>
                       ('#<procedure #6 ##car> ('#<procedure #6 ##car> forms))
                       'set!)
                      (and ('#<procedure #3 ##eq?>
                            ('#<procedure #6 ##car>
                             ('#<procedure #66 ##caddr>
                              ('#<procedure #6 ##car> forms)))
                            '+)
                           (and ('#<procedure #50 ##fx=>
                                 ('#<procedure #23 length>
                                  ('#<procedure #66 ##caddr>
                                   ('#<procedure #6 ##car> forms)))
                                 3)
                                ('#<procedure #50 ##fx=>
                                 ('#<procedure #23 length>
                                  ('#<procedure #66 ##caddr> expression))
                                 3)))))
            (let ((n2 ('#<procedure #67 ##cadr>
                       ('#<procedure #66 ##caddr> expression)))
                  (n1 ('#<procedure #67 ##cadr>
                       ('#<procedure #66 ##caddr>
                        ('#<procedure #6 ##car> forms)))))
              ('#<procedure #10 ##cons>
               ('#<procedure #44 ##quasi-list>
                'set!
                ('#<procedure #67 ##cadr> expression)
                ('#<procedure #44 ##quasi-list>
                 'fx+
                 ('#<procedure #21 ##fx+> n1 n2)
                 ('#<procedure #66 ##caddr>
                  ('#<procedure #66 ##caddr> ('#<procedure #6 ##car> forms)))))
               ('#<procedure #7 ##cdr> forms)))
            ('#<procedure #10 ##cons> expression forms)))))

(define fill-uninitialized-field!
  (let ((#:g580 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.335
           ('#<procedure #63 ##set-box!>
            #:g580
            (register-Generic-1
             '(1 . 1)
             'fill-uninitialized-field!
             meroon-uninitialized
             '(o (field Field))
             'Field))))
      (lambda (o field)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g580) field)
         o
         field)))))

(register-method
 'fill-uninitialized-field!
 '(o (field Mono-Field))
 '(1 . 1)
 (lambda (#:g582 #:g583 #:g584)
   (lambda (o field)
     (if (field-defined? o field)
         #f
         (if (field-defined? field 'initializer)
             (initialize-field-value!
              o
              (('#<procedure #32 ##vector-ref> field 5))
              field)
             (if ('#<procedure #32 ##vector-ref> field 4)
                 (report-meroon-error
                  'Access
                  'fill-uninitialized-field!
                  "No initializer"
                  field)
                 #!void)))))
 'Mono-Field)

(register-method
 'fill-uninitialized-field!
 '(o (field Poly-Field))
 '(1 . 1)
 (lambda (#:g586 #:g587 #:g588)
   (lambda (o field)
     (let ((len (field-length o field)))
       (if (and ('#<procedure #53 ##fx>> len 0) (field-defined? o field 0))
           #f
           (if (field-defined? field 'initializer)
               (letrec ((do-temp.336
                         (lambda (o field len i)
                           (if ('#<procedure #36 ##fx>=> i len)
                               #!void
                               (let ((begin-temp.337
                                      (initialize-field-value!
                                       o
                                       (('#<procedure #32 ##vector-ref>
                                         field
                                         5)
                                        i)
                                       field
                                       i)))
                                 (do-temp.336
                                  o
                                  field
                                  len
                                  ('#<procedure #21 ##fx+> 1 i)))))))
                 (do-temp.336 o field len 0))
               (if ('#<procedure #32 ##vector-ref> field 4)
                   (report-meroon-error
                    'Access
                    'fill-uninitialized-field!
                    "No initializer"
                    field)
                   #!void))))))
 'Poly-Field)

(set! fill-other-fields!
      (lambda (o)
        (let ((begin-temp.338
               (let ((temp.1064
                      (let ((class ('#<procedure #32 ##vector-ref>
                                    *classes*
                                    ('#<procedure #32 ##vector-ref> o 0))))
                        ('#<procedure #32 ##vector-ref> class 3))))
                 (letrec ((loop2.1065
                           (lambda (o lst2.1066)
                             (if ('#<procedure #4 ##pair?> lst2.1066)
                                 (let ((x.1067 (let ((field ('#<procedure #6 ##car>
                                                             lst2.1066)))
                                                 (fill-uninitialized-field!
                                                  o
                                                  field))))
                                   (let ((lst2.1066
                                          ('#<procedure #7 ##cdr> lst2.1066)))
                                     (if ('#<procedure #4 ##pair?> lst2.1066)
                                         (let ((x.1067 (let ((field ('#<procedure #6 ##car>
                                                                     lst2.1066)))
                                                         (fill-uninitialized-field!
                                                          o
                                                          field))))
                                           (loop2.1065
                                            o
                                            ('#<procedure #7 ##cdr>
                                             lst2.1066)))
                                         #!void)))
                                 #!void))))
                   (loop2.1065 o temp.1064)))))
          o)))

(define process-co-instantiate-form
  (lambda (definitions definer)
    (let ((forms (letrec ((loop2.1070
                           (lambda (lst2.1071)
                             (if ('#<procedure #4 ##pair?> lst2.1071)
                                 (let ((x.1072 (let ((def ('#<procedure #6 ##car>
                                                           lst2.1071)))
                                                 (if (and ('#<procedure #4 ##pair?>
                                                           def)
                                                          ('#<procedure #4 ##pair?>
                                                           ('#<procedure #7 ##cdr>
                                                            def)))
                                                     (let ((parms ('#<procedure #70 ##cddr>
                                                                   def))
                                                           (class-name
                                                            ('#<procedure #67 ##cadr>
                                                             def))
                                                           (name ('#<procedure #6 ##car>
                                                                  def)))
                                                       (process-co-instantiation
                                                        name
                                                        (symbol->class
                                                         class-name
                                                         (lambda (name)
                                                           (report-meroon-error
                                                            'Syntax
                                                            'co-instantiate
                                                            "Unknown class"
                                                            name)))
                                                        parms))
                                                     (report-meroon-error
                                                      'Syntax
                                                      'co-instantiate
                                                      "Missing parameters"
                                                      def)))))
                                   ('#<procedure #10 ##cons>
                                    x.1072
                                    (loop2.1070
                                     ('#<procedure #7 ##cdr> lst2.1071))))
                                 '()))))
                   (loop2.1070 definitions))))
      (let ((names (letrec ((loop2.1075
                             (lambda (lst2.1076)
                               (if ('#<procedure #4 ##pair?> lst2.1076)
                                   (let ((x.1077 ('#<procedure #9 car>
                                                  ('#<procedure #6 ##car>
                                                   lst2.1076))))
                                     ('#<procedure #10 ##cons>
                                      x.1077
                                      (loop2.1075
                                       ('#<procedure #7 ##cdr> lst2.1076))))
                                   '()))))
                     (loop2.1075 definitions))))
        ('#<procedure #43 ##quasi-cons>
         'begin
         ('#<procedure #45 ##quasi-append>
          ('#<procedure #69 map>
           (lambda (name alloc+init)
             ('#<procedure #44 ##quasi-list>
              definer
              name
              ('#<procedure #6 ##car> alloc+init)))
           names
           forms)
          ('#<procedure #45 ##quasi-append>
           (letrec ((loop2.1080
                     (lambda (lst2.1081)
                       (if ('#<procedure #4 ##pair?> lst2.1081)
                           (let ((x.1082 ('#<procedure #11 cdr>
                                          ('#<procedure #6 ##car> lst2.1081))))
                             ('#<procedure #10 ##cons>
                              x.1082
                              (loop2.1080 ('#<procedure #7 ##cdr> lst2.1081))))
                           '()))))
             (loop2.1080 forms))
           ('#<procedure #44 ##quasi-list>
            (if ('#<procedure #4 ##pair?> names)
                ('#<procedure #6 ##car> names)
                #f)))))))))

(define process-co-instantiation-form
  (lambda (name class-name parms)
    (process-co-instantiation
     name
     (symbol->class
      class-name
      (lambda (name)
        (report-meroon-error 'Syntax 'co-instantiate "Unknown class" name)))
     parms)))

(define process-co-instantiation
  (lambda (name class parms)
    (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
      (let ((class-name
             (symbol-concatenate
              ('#<procedure #32 ##vector-ref> class 1)
              '-class)))
        (let ((contents
               (process-initialization fields parms find-initialization)))
          (let ((index (gensym)))
            ('#<procedure #10 ##cons>
             ('#<procedure #43 ##quasi-cons>
              ('#<procedure #44 ##quasi-list>
               'careless-Class-allocator
               class-name)
              (meroon-reduce
               (lambda (forms field content)
                 (generate-size field content forms))
               '()
               fields
               contents))
             ('#<procedure #43 ##quasi-cons>
              'let
              ('#<procedure #43 ##quasi-cons>
               ('#<procedure #44 ##quasi-list>
                ('#<procedure #43 ##quasi-cons> index '(0)))
               ('#<procedure #45 ##quasi-append>
                (meroon-reduce
                 (lambda (forms field content)
                   (generate-initialization field content name index forms))
                 '()
                 fields
                 contents)
                ('#<procedure #44 ##quasi-list>
                 ('#<procedure #44 ##quasi-list>
                  'initialize!
                  ('#<procedure #44 ##quasi-list>
                   'fill-other-fields!
                   name)))))))))))))

(define process-with-co-instantiation-form
  (lambda (definitions body)
    (let ((initforms (process-co-instantiate-form definitions 'define)))
      ('#<procedure #43 ##quasi-cons>
       'let
       ('#<procedure #43 ##quasi-cons>
        '()
        ('#<procedure #45 ##quasi-append>
         ('#<procedure #7 ##cdr> initforms)
         body))))))

(define general-make
  (lambda (class args)
    (let ((ins-tance
           (let ((cn (Class-number class)))
             ('#<procedure #31 ##subtype-set!>
              ('#<procedure #8 apply> '#<procedure #68 ##vector> cn args)
              6))))
      (initialize! (check-conformity ins-tance)))))

(define check-conformity
  (lambda (ins-tance)
    (let ((len ('#<procedure #39 ##fx->
                ('#<procedure #29 ##vector-length> ins-tance)
                1))
          (class ('#<procedure #32 ##vector-ref>
                  *classes*
                  ('#<procedure #32 ##vector-ref> ins-tance 0))))
      (letrec ((check (lambda (ins-tance len class fields index)
                        (if ('#<procedure #4 ##pair?> fields)
                            (if ('#<procedure #20 ##fx<> index len)
                                (let ((new-index
                                       (Field-check-conformity
                                        ('#<procedure #6 ##car> fields)
                                        ins-tance
                                        index)))
                                  (if new-index
                                      (check ins-tance
                                             len
                                             class
                                             ('#<procedure #7 ##cdr> fields)
                                             new-index)
                                      (report-meroon-error
                                       'Syntax
                                       (symbol-concatenate
                                        'make-
                                        (Class-name class))
                                       "Incorrect allocation for"
                                       ('#<procedure #6 ##car> fields))))
                                (report-superfluous-allocation ins-tance))
                            (if ('#<procedure #50 ##fx=> index len)
                                ins-tance
                                (if ('#<procedure #20 ##fx<> index len)
                                    (report-superfluous-allocation ins-tance)
                                    (report-meroon-error
                                     'Syntax
                                     (symbol-concatenate
                                      'make-
                                      (Class-name class))
                                     "Missing allocation arguments")))))))
        (check ins-tance len class (Class-fields class) 0)))))

(define Field-check-conformity
  (let ((#:g590 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.339
           ('#<procedure #63 ##set-box!>
            #:g590
            (register-Generic-1
             '(1 . 1)
             'Field-check-conformity
             meroon-uninitialized
             '((field Field) ins-tance index)
             'Field))))
      (lambda (field ins-tance index)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g590) field)
         field
         ins-tance
         index)))))

(register-method
 'Field-check-conformity
 '((field Mono-Field) ins-tance index)
 '(1 . 1)
 (lambda (#:g592 #:g593 #:g594)
   (lambda (field ins-tance index) ('#<procedure #21 ##fx+> 1 index)))
 'Mono-Field)

(register-method
 'Field-check-conformity
 '((field Poly-Field) ins-tance index)
 '(1 . 1)
 (lambda (#:g596 #:g597 #:g598)
   (lambda (field ins-tance index)
     (let ((content (let ((i ('#<procedure #21 ##fx+> 1 index)))
                      ('#<procedure #32 ##vector-ref> ins-tance i))))
       (let ((begin-temp.340 (check-size content field)))
         ('#<procedure #21 ##fx+> index 1 content)))))
 'Poly-Field)

(define report-superfluous-allocation
  (lambda (ins-tance)
    (report-meroon-error
     'Syntax
     (symbol-concatenate
      'make-
      (Class-name
       ('#<procedure #32 ##vector-ref>
        *classes*
        ('#<procedure #32 ##vector-ref> ins-tance 0))))
     "Superfluous allocation arguments")))

'''(define (check-and-process-view-definition definition)
     (unless (fx>= (length definition) 3)
             (report-meroon-error
              'Syntax
              'define-view
              "Incomplete definition"
              definition))
     (let ((name (car definition))
           (super-names (cadr definition))
           (own-field-descs (caddr definition))
           (view-options (cdddr definition)))
       (unless (symbol? name)
               (report-meroon-error
                'Syntax
                'define-view
                "Incorrect name for a class"
                name))
       (unless (list? super-names)
               (report-meroon-error
                'Syntax
                'define-view
                "Bad super views"
                definition))
       (let ((super-views
              (map (lambda (name)
                     (symbol->class name complain-if-missing-super-view))
                   super-names)))
         (when (pair? view-options)
               (report-meroon-error
                'Syntax
                'define-view
                "MOP options not supported"
                definition))
         (process-view-definition
          name
          super-views
          own-field-descs
          view-options))))

'''(define (process-view-definition
            name
            super-views
            own-field-descs
            view-options)
     (let ((view (oo-apply (Class-allocator View-class) (length super-views))))
       (initialize-Pre-Class-name view name)
       (let ((cn (if already-there?
                     (View-number old-view)
                     (get-new-class-number))))
         (initialize-Pre-Class-number view cn)
         (vector-set! *classes* cn view))
       (report-meroon-error 'Syntax 'define-view "Not yet implemented" name)))

(define View-generate-accessors (lambda (view view-options) ''#f))

(define Virtual-Field-generate-MeroonV2-accessors (lambda (field view) ''#f))

(define Virtual-Field-generate-Handy-accessors (lambda (field view) ''#f))

(define View-generate-predicate (lambda (view view-options) ''#f))

(define View-generate-accompanying-functions (lambda (view view-options) ''#f))

(define ->Object
  (let ((#:g600 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.341
           ('#<procedure #63 ##set-box!>
            #:g600
            (register-Generic-1 '(1 . 1) '->Object (lambda (o) o) '((o)) #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g600) o)
         o)))))

(define ->Class
  (let ((#:g602 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.342
           ('#<procedure #63 ##set-box!>
            #:g602
            (register-Generic-1
             '(1 . 1)
             '->Class
             (lambda (o)
               (if ('#<procedure #16 ##symbol?> o)
                   (symbol->class o)
                   (if (and ('#<procedure #58 ##fixnum?> o)
                            (and ('#<procedure #36 ##fx>=> o 0)
                                 ('#<procedure #20 ##fx<> o *class-number*)))
                       ('#<procedure #32 ##vector-ref> *classes* o)
                       (report-meroon-error
                        'Domain
                        '->Class
                        "Cannot coerce to Class"
                        o))))
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g602) o)
         o)))))

(register-method
 '->Class
 '((o Class))
 '(1 . 1)
 (lambda (#:g604 #:g605 #:g606) (lambda (o) o))
 'Class)

(define ->Generic
  (let ((#:g608 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.343
           ('#<procedure #63 ##set-box!>
            #:g608
            (register-Generic-1
             '(1 . 1)
             '->Generic
             (lambda (o)
               (if ('#<procedure #16 ##symbol?> o)
                   (symbol->generic o)
                   (report-meroon-error
                    'Domain
                    '->Generic
                    "Cannot coerce to Generic"
                    o)))
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g608) o)
         o)))))

(register-method
 '->Generic
 '((o Generic))
 '(1 . 1)
 (lambda (#:g610 #:g611 #:g612) (lambda (o) o))
 'Generic)

(define meroon-is-a?-internal-generic
  (let ((#:g614 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.344
           ('#<procedure #63 ##set-box!>
            #:g614
            (register-Generic-1
             '(1 . 1)
             'meroon-is-a?-internal-generic
             meroon-uninitialized
             '(o (class Pre-Class))
             'Pre-Class))))
      (lambda (o class)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g614) class)
         o
         class)))))

(let ((g (symbol->generic 'meroon-is-a?-internal-generic)))
  (let ((begin-temp.346 ('#<procedure #33 ##vector-set!> g 1 'is-a?)))
    (let ((begin-temp.345 (add-1-method! g Class-class Class-is-a?)))
      (add-1-method! g View-class View-is-a?))))

(set! is-a? meroon-is-a?-internal-generic)

'is-a?

(define meroon-compute-value-offset-internal-generic
  (let ((#:g616 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.348
           ('#<procedure #63 ##set-box!>
            #:g616
            (register-Generic-1
             '(1 . 1)
             'meroon-compute-value-offset-internal-generic
             (lambda (o field index)
               (let ((begin-temp.347
                      (if ('#<procedure #28 ##meroon?> o)
                          #!void
                          (report-meroon-error
                           'Access
                           'compute-value-offset
                           "Not an Object"
                           o))))
                 (let ((field (retrieve-named-field
                               ('#<procedure #32 ##vector-ref>
                                *classes*
                                ('#<procedure #32 ##vector-ref> o 0))
                               field
                               report-bad-coercion-to-field)))
                   (if ('#<procedure #4 ##pair?> index)
                       (compute-value-offset
                        o
                        field
                        ('#<procedure #6 ##car> index))
                       (compute-value-offset o field)))))
             '(o (field Pre-Field) . index)
             'Pre-Field))))
      (lambda (o field . index)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g616) field)
         o
         field
         index)))))

(let ((g (symbol->generic 'meroon-compute-value-offset-internal-generic)))
  (let ((begin-temp.351
         ('#<procedure #33 ##vector-set!> g 1 'compute-value-offset)))
    (let ((begin-temp.350
           (add-1-method! g Mono-Field-class Mono-Field-compute-value-offset)))
      (let ((begin-temp.349
             (add-1-method!
              g
              Poly-Field-class
              Poly-Field-compute-value-offset)))
        (add-1-method!
         g
         Virtual-Field-class
         Virtual-Field-compute-value-offset)))))

(set! compute-value-offset meroon-compute-value-offset-internal-generic)

'compute-value-offset

(define meroon-field-value-internal-generic
  (let ((#:g618 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.353
           ('#<procedure #63 ##set-box!>
            #:g618
            (register-Generic-1
             '(1 . 1)
             'meroon-field-value-internal-generic
             (lambda (o field index)
               (let ((begin-temp.352
                      (if ('#<procedure #28 ##meroon?> o)
                          #!void
                          (report-meroon-error
                           'Access
                           'field-value
                           "Not an Object"
                           o))))
                 (let ((field (retrieve-named-field
                               ('#<procedure #32 ##vector-ref>
                                *classes*
                                ('#<procedure #32 ##vector-ref> o 0))
                               field
                               report-bad-coercion-to-field)))
                   (if ('#<procedure #4 ##pair?> index)
                       (field-value o field ('#<procedure #6 ##car> index))
                       (field-value o field)))))
             '(o (field Pre-Field) . index)
             'Pre-Field))))
      (lambda (o field . index)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g618) field)
         o
         field
         index)))))

(let ((g (symbol->generic 'meroon-field-value-internal-generic)))
  (let ((begin-temp.356 ('#<procedure #33 ##vector-set!> g 1 'field-value)))
    (let ((begin-temp.355
           (add-1-method! g Mono-Field-class Mono-Field-field-value)))
      (let ((begin-temp.354
             (add-1-method! g Poly-Field-class Poly-Field-field-value)))
        (add-1-method! g Virtual-Field-class Virtual-Field-field-value)))))

(set! field-value meroon-field-value-internal-generic)

'field-value

(define meroon-set-field-value!-internal-generic
  (let ((#:g620 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.358
           ('#<procedure #63 ##set-box!>
            #:g620
            (register-Generic-1
             '(1 . 1)
             'meroon-set-field-value!-internal-generic
             (lambda (o value field index)
               (let ((begin-temp.357
                      (if ('#<procedure #28 ##meroon?> o)
                          #!void
                          (report-meroon-error
                           'Access
                           'set-field-value!
                           "Not an Object"
                           o))))
                 (let ((field (retrieve-named-field
                               ('#<procedure #32 ##vector-ref>
                                *classes*
                                ('#<procedure #32 ##vector-ref> o 0))
                               field
                               report-bad-coercion-to-field)))
                   (if ('#<procedure #4 ##pair?> index)
                       (set-field-value!
                        o
                        value
                        field
                        ('#<procedure #6 ##car> index))
                       (set-field-value! o value field)))))
             '(o value (field Pre-Field) . index)
             'Pre-Field))))
      (lambda (o value field . index)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g620) field)
         o
         value
         field
         index)))))

(let ((g (symbol->generic 'meroon-set-field-value!-internal-generic)))
  (let ((begin-temp.361
         ('#<procedure #33 ##vector-set!> g 1 'set-field-value!)))
    (let ((begin-temp.360
           (add-1-method! g Mono-Field-class Mono-Field-set-field-value!)))
      (let ((begin-temp.359
             (add-1-method! g Poly-Field-class Poly-Field-set-field-value!)))
        (add-1-method!
         g
         Virtual-Field-class
         Virtual-Field-set-field-value!)))))

(set! set-field-value! meroon-set-field-value!-internal-generic)

'set-field-value!

(define meroon-initialize-field-value!-internal-generic
  (let ((#:g622 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.363
           ('#<procedure #63 ##set-box!>
            #:g622
            (register-Generic-1
             '(1 . 1)
             'meroon-initialize-field-value!-internal-generic
             (lambda (o value field index)
               (let ((begin-temp.362
                      (if ('#<procedure #28 ##meroon?> o)
                          #!void
                          (report-meroon-error
                           'Access
                           'initialize-field-value!
                           "Not an Object"
                           o))))
                 (let ((field (retrieve-named-field
                               ('#<procedure #32 ##vector-ref>
                                *classes*
                                ('#<procedure #32 ##vector-ref> o 0))
                               field
                               report-bad-coercion-to-field)))
                   (if ('#<procedure #4 ##pair?> index)
                       (initialize-field-value!
                        o
                        value
                        field
                        ('#<procedure #6 ##car> index))
                       (initialize-field-value! o value field)))))
             '(o value (field Pre-Field) . index)
             'Pre-Field))))
      (lambda (o value field . index)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g622) field)
         o
         value
         field
         index)))))

(let ((g (symbol->generic 'meroon-initialize-field-value!-internal-generic)))
  (let ((begin-temp.366
         ('#<procedure #33 ##vector-set!> g 1 'initialize-field-value!)))
    (let ((begin-temp.365
           (add-1-method!
            g
            Mono-Field-class
            Mono-Field-initialize-field-value!)))
      (let ((begin-temp.364
             (add-1-method!
              g
              Poly-Field-class
              Poly-Field-initialize-field-value!)))
        (add-1-method!
         g
         Virtual-Field-class
         Virtual-Field-initialize-field-value!)))))

(set! initialize-field-value! meroon-initialize-field-value!-internal-generic)

'initialize-field-value!

(define meroon-field-defined?-internal-generic
  (let ((#:g624 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.368
           ('#<procedure #63 ##set-box!>
            #:g624
            (register-Generic-1
             '(1 . 1)
             'meroon-field-defined?-internal-generic
             (lambda (o field index)
               (let ((begin-temp.367
                      (if ('#<procedure #28 ##meroon?> o)
                          #!void
                          (report-meroon-error
                           'Access
                           'field-defined?
                           "Not an Object"
                           o))))
                 (let ((field (retrieve-named-field
                               ('#<procedure #32 ##vector-ref>
                                *classes*
                                ('#<procedure #32 ##vector-ref> o 0))
                               field
                               report-bad-coercion-to-field)))
                   (if ('#<procedure #4 ##pair?> index)
                       (field-defined? o field ('#<procedure #6 ##car> index))
                       (field-defined? o field)))))
             '(o (field Pre-Field) . index)
             'Pre-Field))))
      (lambda (o field . index)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g624) field)
         o
         field
         index)))))

(let ((g (symbol->generic 'meroon-field-defined?-internal-generic)))
  (let ((begin-temp.371 ('#<procedure #33 ##vector-set!> g 1 'field-defined?)))
    (let ((begin-temp.370
           (add-1-method! g Mono-Field-class Mono-Field-field-defined?)))
      (let ((begin-temp.369
             (add-1-method! g Poly-Field-class Poly-Field-field-defined?)))
        (add-1-method! g Virtual-Field-class Virtual-Field-field-defined?)))))

(set! field-defined? meroon-field-defined?-internal-generic)

'field-defined?

(define meroon-generate-offset-internal-generic
  (let ((#:g626 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.372
           ('#<procedure #63 ##set-box!>
            #:g626
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-offset-internal-generic
             meroon-uninitialized
             '(ovar (field Pre-Field) fieldvar . indexvar)
             'Pre-Field))))
      (lambda (ovar field fieldvar . indexvar)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g626) field)
         ovar
         field
         fieldvar
         indexvar)))))

(let ((g (symbol->generic 'meroon-generate-offset-internal-generic)))
  (let ((begin-temp.374
         ('#<procedure #33 ##vector-set!> g 1 'generate-offset)))
    (let ((begin-temp.373
           (add-1-method! g Mono-Field-class Mono-Field-generate-offset)))
      (add-1-method! g Poly-Field-class Poly-Field-generate-offset))))

(set! generate-offset meroon-generate-offset-internal-generic)

'generate-offset

(define meroon-add-subclass-internal-generic
  (let ((#:g628 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.375
           ('#<procedure #63 ##set-box!>
            #:g628
            (register-Generic-1
             '(1 . 1)
             'meroon-add-subclass-internal-generic
             meroon-uninitialized
             '(name (super-class Class) own-field-descs class-options)
             'Class))))
      (lambda (name super-class own-field-descs class-options)
        ((careless-determine-method1
          ('#<procedure #62 ##unbox> #:g628)
          super-class)
         name
         super-class
         own-field-descs
         class-options)))))

(let ((g (symbol->generic 'meroon-add-subclass-internal-generic)))
  (let ((begin-temp.376 ('#<procedure #33 ##vector-set!> g 1 'add-subclass)))
    (add-1-method! g Class-class Class-add-subclass)))

(set! add-subclass meroon-add-subclass-internal-generic)

'add-subclass

#t

#f

(define meroon-enlarge-dispatcher!-internal-generic
  (let ((#:g630 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.377
           ('#<procedure #63 ##set-box!>
            #:g630
            (register-Generic-1
             '(1 . 1)
             'meroon-enlarge-dispatcher!-internal-generic
             (lambda (d) d)
             '((d Dispatcher))
             'Dispatcher))))
      (lambda (d)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g630) d)
         d)))))

(let ((g (symbol->generic 'meroon-enlarge-dispatcher!-internal-generic)))
  (let ((begin-temp.378
         ('#<procedure #33 ##vector-set!> g 1 'enlarge-dispatcher!)))
    (add-1-method!
     g
     Global-Dispatcher-class
     Global-Dispatcher-enlarge-dispatcher!)))

(set! enlarge-dispatcher! meroon-enlarge-dispatcher!-internal-generic)

'enlarge-dispatcher!

(define meroon-augment-dispatcher!-internal-generic
  (let ((#:g632 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.379
           ('#<procedure #63 ##set-box!>
            #:g632
            (register-Generic-1
             '(1 . 1)
             'meroon-augment-dispatcher!-internal-generic
             meroon-uninitialized
             '((d Dispatcher) class method)
             'Dispatcher))))
      (lambda (d class method)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g632) d)
         d
         class
         method)))))

(let ((g (symbol->generic 'meroon-augment-dispatcher!-internal-generic)))
  (let ((begin-temp.384
         ('#<procedure #33 ##vector-set!> g 1 'augment-dispatcher!)))
    (let ((begin-temp.383
           (add-1-method!
            g
            Immediate-Dispatcher-class
            Immediate-Dispatcher-augment-dispatcher!)))
      (let ((begin-temp.382
             (add-1-method!
              g
              Subclass-Dispatcher-class
              Subclass-Dispatcher-augment-dispatcher!)))
        (let ((begin-temp.381
               (add-1-method!
                g
                Indexed-Dispatcher-class
                Indexed-Dispatcher-augment-dispatcher!)))
          (let ((begin-temp.380
                 (add-1-method!
                  g
                  Global-Dispatcher-class
                  Global-Dispatcher-augment-dispatcher!)))
            (add-1-method!
             g
             Tracing-Dispatcher-class
             Tracing-Dispatcher-augment-dispatcher!)))))))

(set! augment-dispatcher! meroon-augment-dispatcher!-internal-generic)

'augment-dispatcher!

(define meroon-compress-dispatcher!-internal-generic
  (let ((#:g634 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.385
           ('#<procedure #63 ##set-box!>
            #:g634
            (register-Generic-1
             '(1 . 1)
             'meroon-compress-dispatcher!-internal-generic
             meroon-uninitialized
             '((d Dispatcher) level top-class)
             'Dispatcher))))
      (lambda (d level top-class)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g634) d)
         d
         level
         top-class)))))

(let ((g (symbol->generic 'meroon-compress-dispatcher!-internal-generic)))
  (let ((begin-temp.390
         ('#<procedure #33 ##vector-set!> g 1 'compress-dispatcher!)))
    (let ((begin-temp.389
           (add-1-method!
            g
            Immediate-Dispatcher-class
            Immediate-Dispatcher-compress-dispatcher!)))
      (let ((begin-temp.388
             (add-1-method!
              g
              Subclass-Dispatcher-class
              Subclass-Dispatcher-compress-dispatcher!)))
        (let ((begin-temp.387
               (add-1-method!
                g
                Indexed-Dispatcher-class
                Indexed-Dispatcher-compress-dispatcher!)))
          (let ((begin-temp.386
                 (add-1-method!
                  g
                  Global-Dispatcher-class
                  Global-Dispatcher-compress-dispatcher!)))
            (add-1-method!
             g
             Tracing-Dispatcher-class
             Tracing-Dispatcher-compress-dispatcher!)))))))

(set! compress-dispatcher! meroon-compress-dispatcher!-internal-generic)

'compress-dispatcher!

(define meroon-rebalance-dispatcher!-internal-generic
  (let ((#:g636 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.391
           ('#<procedure #63 ##set-box!>
            #:g636
            (register-Generic-1
             '(1 . 1)
             'meroon-rebalance-dispatcher!-internal-generic
             meroon-uninitialized
             '(d (dno Dispatcher))
             'Dispatcher))))
      (lambda (d dno)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g636) dno)
         d
         dno)))))

(let ((g (symbol->generic 'meroon-rebalance-dispatcher!-internal-generic)))
  (let ((begin-temp.396
         ('#<procedure #33 ##vector-set!> g 1 'rebalance-dispatcher!)))
    (let ((begin-temp.395
           (add-1-method!
            g
            Immediate-Dispatcher-class
            Immediate-Dispatcher-rebalance-dispatcher!)))
      (let ((begin-temp.394
             (add-1-method!
              g
              Subclass-Dispatcher-class
              Subclass-Dispatcher-rebalance-dispatcher!)))
        (let ((begin-temp.393
               (add-1-method!
                g
                Indexed-Dispatcher-class
                Indexed-Dispatcher-rebalance-dispatcher!)))
          (let ((begin-temp.392
                 (add-1-method!
                  g
                  Global-Dispatcher-class
                  Global-Dispatcher-rebalance-dispatcher!)))
            (add-1-method!
             g
             Tracing-Dispatcher-class
             Tracing-Dispatcher-rebalance-dispatcher!)))))))

(set! rebalance-dispatcher! meroon-rebalance-dispatcher!-internal-generic)

'rebalance-dispatcher!

(define meroon-update-dispatcher!-internal-generic
  (let ((#:g638 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.397
           ('#<procedure #63 ##set-box!>
            #:g638
            (register-Generic-1
             '(1 . 1)
             'meroon-update-dispatcher!-internal-generic
             meroon-uninitialized
             '((d Dispatcher) class)
             'Dispatcher))))
      (lambda (d class)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g638) d)
         d
         class)))))

(let ((g (symbol->generic 'meroon-update-dispatcher!-internal-generic)))
  (let ((begin-temp.402
         ('#<procedure #33 ##vector-set!> g 1 'update-dispatcher!)))
    (let ((begin-temp.401
           (add-1-method!
            g
            Immediate-Dispatcher-class
            Immediate-Dispatcher-update-dispatcher!)))
      (let ((begin-temp.400
             (add-1-method!
              g
              Subclass-Dispatcher-class
              Subclass-Dispatcher-update-dispatcher!)))
        (let ((begin-temp.399
               (add-1-method!
                g
                Indexed-Dispatcher-class
                Indexed-Dispatcher-update-dispatcher!)))
          (let ((begin-temp.398
                 (add-1-method!
                  g
                  Global-Dispatcher-class
                  Global-Dispatcher-update-dispatcher!)))
            (add-1-method!
             g
             Tracing-Dispatcher-class
             Tracing-Dispatcher-update-dispatcher!)))))))

(set! update-dispatcher! meroon-update-dispatcher!-internal-generic)

'update-dispatcher!

(define meroon-Generic-update!-internal-generic
  (let ((#:g640 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.403
           ('#<procedure #63 ##set-box!>
            #:g640
            (register-Generic-1
             '(1 . 1)
             'meroon-Generic-update!-internal-generic
             meroon-uninitialized
             '((generic Generic) class)
             'Generic))))
      (lambda (generic class)
        ((careless-determine-method1
          ('#<procedure #62 ##unbox> #:g640)
          generic)
         generic
         class)))))

(let ((g (symbol->generic 'meroon-Generic-update!-internal-generic)))
  (let ((begin-temp.405
         ('#<procedure #33 ##vector-set!> g 1 'Generic-update!)))
    (let ((begin-temp.404 (add-1-method! g Generic-1-class Generic-1-update!)))
      (add-1-method! g Generic-N-class Generic-N-update!))))

(set! Generic-update! meroon-Generic-update!-internal-generic)

'Generic-update!

(define meroon-generate-accessors-internal-generic
  (let ((#:g642 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.406
           ('#<procedure #63 ##set-box!>
            #:g642
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-accessors-internal-generic
             meroon-uninitialized
             '((o Pre-Class) class-options)
             'Pre-Class))))
      (lambda (o class-options)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g642) o)
         o
         class-options)))))

(let ((g (symbol->generic 'meroon-generate-accessors-internal-generic)))
  (let ((begin-temp.410
         ('#<procedure #33 ##vector-set!> g 1 'generate-accessors)))
    (let ((begin-temp.409
           (add-1-method! g Class-class Class-generate-accessors)))
      (let ((begin-temp.408
             (add-1-method!
              g
              Handy-Class-class
              Handy-Class-generate-accessors)))
        (let ((begin-temp.407
               (add-1-method!
                g
                MeroonV2-Class-class
                MeroonV2-Class-generate-accessors)))
          (add-1-method! g View-class View-generate-accessors))))))

(set! generate-accessors meroon-generate-accessors-internal-generic)

'generate-accessors

(define meroon-generate-fast-careful-reader-internal-generic
  (let ((#:g644 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.411
           ('#<procedure #63 ##set-box!>
            #:g644
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-fast-careful-reader-internal-generic
             meroon-uninitialized
             '((field Pre-Field) class-variable)
             'Pre-Field))))
      (lambda (field class-variable)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g644) field)
         field
         class-variable)))))

(let ((g (symbol->generic
          'meroon-generate-fast-careful-reader-internal-generic)))
  (let ((begin-temp.413
         ('#<procedure #33 ##vector-set!> g 1 'generate-fast-careful-reader)))
    (let ((begin-temp.412
           (add-1-method!
            g
            Mono-Field-class
            Mono-Field-generate-fast-careful-reader)))
      (add-1-method!
       g
       Poly-Field-class
       Poly-Field-generate-fast-careful-reader))))

(set! generate-fast-careful-reader
      meroon-generate-fast-careful-reader-internal-generic)

'generate-fast-careful-reader

(define meroon-generate-fast-careful-lengther-internal-generic
  (let ((#:g646 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.414
           ('#<procedure #63 ##set-box!>
            #:g646
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-fast-careful-lengther-internal-generic
             meroon-uninitialized
             '((field Pre-Field) class-variable)
             'Pre-Field))))
      (lambda (field class-variable)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g646) field)
         field
         class-variable)))))

(let ((g (symbol->generic
          'meroon-generate-fast-careful-lengther-internal-generic)))
  (let ((begin-temp.415
         ('#<procedure #33 ##vector-set!>
          g
          1
          'generate-fast-careful-lengther)))
    (add-1-method!
     g
     Poly-Field-class
     Poly-Field-generate-fast-careful-lengther)))

(set! generate-fast-careful-lengther
      meroon-generate-fast-careful-lengther-internal-generic)

'generate-fast-careful-lengther

(define meroon-generate-fast-careful-writer-internal-generic
  (let ((#:g648 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.416
           ('#<procedure #63 ##set-box!>
            #:g648
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-fast-careful-writer-internal-generic
             meroon-uninitialized
             '((field Pre-Field) class-variable)
             'Pre-Field))))
      (lambda (field class-variable)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g648) field)
         field
         class-variable)))))

(let ((g (symbol->generic
          'meroon-generate-fast-careful-writer-internal-generic)))
  (let ((begin-temp.418
         ('#<procedure #33 ##vector-set!> g 1 'generate-fast-careful-writer)))
    (let ((begin-temp.417
           (add-1-method!
            g
            Mono-Field-class
            Mono-Field-generate-fast-careful-writer)))
      (add-1-method!
       g
       Poly-Field-class
       Poly-Field-generate-fast-careful-writer))))

(set! generate-fast-careful-writer
      meroon-generate-fast-careful-writer-internal-generic)

'generate-fast-careful-writer

(define meroon-Field-generate-MeroonV2-accessors-internal-generic
  (let ((#:g650 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.419
           ('#<procedure #63 ##set-box!>
            #:g650
            (register-Generic-1
             '(1 . 1)
             'meroon-Field-generate-MeroonV2-accessors-internal-generic
             meroon-uninitialized
             '((field Pre-Field) class)
             'Pre-Field))))
      (lambda (field class)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g650) field)
         field
         class)))))

(let ((g (symbol->generic
          'meroon-Field-generate-MeroonV2-accessors-internal-generic)))
  (let ((begin-temp.422
         ('#<procedure #33 ##vector-set!>
          g
          1
          'Field-generate-MeroonV2-accessors)))
    (let ((begin-temp.421
           (add-1-method!
            g
            Mono-Field-class
            Mono-Field-generate-MeroonV2-accessors)))
      (let ((begin-temp.420
             (add-1-method!
              g
              Poly-Field-class
              Poly-Field-generate-MeroonV2-accessors)))
        (add-1-method!
         g
         Virtual-Field-class
         Virtual-Field-generate-MeroonV2-accessors)))))

(set! Field-generate-MeroonV2-accessors
      meroon-Field-generate-MeroonV2-accessors-internal-generic)

'Field-generate-MeroonV2-accessors

(define meroon-Field-generate-Handy-accessors-internal-generic
  (let ((#:g652 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.423
           ('#<procedure #63 ##set-box!>
            #:g652
            (register-Generic-1
             '(1 . 1)
             'meroon-Field-generate-Handy-accessors-internal-generic
             meroon-uninitialized
             '((field Pre-Field) class)
             'Pre-Field))))
      (lambda (field class)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g652) field)
         field
         class)))))

(let ((g (symbol->generic
          'meroon-Field-generate-Handy-accessors-internal-generic)))
  (let ((begin-temp.426
         ('#<procedure #33 ##vector-set!>
          g
          1
          'Field-generate-Handy-accessors)))
    (let ((begin-temp.425
           (add-1-method!
            g
            Mono-Field-class
            Mono-Field-generate-Handy-accessors)))
      (let ((begin-temp.424
             (add-1-method!
              g
              Poly-Field-class
              Poly-Field-generate-Handy-accessors)))
        (add-1-method!
         g
         Virtual-Field-class
         Virtual-Field-generate-Handy-accessors)))))

(set! Field-generate-Handy-accessors
      meroon-Field-generate-Handy-accessors-internal-generic)

'Field-generate-Handy-accessors

(define meroon-generate-predicate-internal-generic
  (let ((#:g654 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.427
           ('#<procedure #63 ##set-box!>
            #:g654
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-predicate-internal-generic
             meroon-uninitialized
             '((o Pre-Class) class-options)
             'Pre-Class))))
      (lambda (o class-options)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g654) o)
         o
         class-options)))))

(let ((g (symbol->generic 'meroon-generate-predicate-internal-generic)))
  (let ((begin-temp.430
         ('#<procedure #33 ##vector-set!> g 1 'generate-predicate)))
    (let ((begin-temp.429
           (add-1-method! g Class-class (lambda (o class-options) ''()))))
      (let ((begin-temp.428
             (add-1-method!
              g
              Handy-Class-class
              Handy-Class-generate-predicate)))
        (add-1-method! g View-class View-generate-predicate)))))

(set! generate-predicate meroon-generate-predicate-internal-generic)

'generate-predicate

(define meroon-generate-maker-internal-generic
  (let ((#:g656 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.431
           ('#<procedure #63 ##set-box!>
            #:g656
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-maker-internal-generic
             meroon-uninitialized
             '((o Class) class-options)
             'Class))))
      (lambda (o class-options)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g656) o)
         o
         class-options)))))

(let ((g (symbol->generic 'meroon-generate-maker-internal-generic)))
  (let ((begin-temp.433 ('#<procedure #33 ##vector-set!> g 1 'generate-maker)))
    (let ((begin-temp.432
           (add-1-method! g Class-class (lambda (o class-options) ''()))))
      (add-1-method! g Handy-Class-class Handy-Class-generate-maker))))

(set! generate-maker meroon-generate-maker-internal-generic)

'generate-maker

(define meroon-generate-coercer-internal-generic
  (let ((#:g658 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.434
           ('#<procedure #63 ##set-box!>
            #:g658
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-coercer-internal-generic
             meroon-uninitialized
             '((o Class) class-options)
             'Class))))
      (lambda (o class-options)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g658) o)
         o
         class-options)))))

(let ((g (symbol->generic 'meroon-generate-coercer-internal-generic)))
  (let ((begin-temp.436
         ('#<procedure #33 ##vector-set!> g 1 'generate-coercer)))
    (let ((begin-temp.435
           (add-1-method! g Class-class (lambda (o class-options) ''()))))
      (add-1-method! g Handy-Class-class Handy-Class-generate-coercer))))

(set! generate-coercer meroon-generate-coercer-internal-generic)

'generate-coercer

(define meroon-generate-accompanying-functions-internal-generic
  (let ((#:g660 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.437
           ('#<procedure #63 ##set-box!>
            #:g660
            (register-Generic-1
             '(1 . 1)
             'meroon-generate-accompanying-functions-internal-generic
             meroon-uninitialized
             '((o Pre-Class) class-options)
             'Pre-Class))))
      (lambda (o class-options)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g660) o)
         o
         class-options)))))

(let ((g (symbol->generic
          'meroon-generate-accompanying-functions-internal-generic)))
  (let ((begin-temp.440
         ('#<procedure #33 ##vector-set!>
          g
          1
          'generate-accompanying-functions)))
    (let ((begin-temp.439
           (add-1-method!
            g
            Class-class
            Class-generate-accompanying-functions)))
      (let ((begin-temp.438
             (add-1-method!
              g
              Handy-Class-class
              Handy-Class-generate-accompanying-functions)))
        (add-1-method! g View-class View-generate-accompanying-functions)))))

(set! generate-accompanying-functions
      meroon-generate-accompanying-functions-internal-generic)

'generate-accompanying-functions

(define meroon-initialize!-internal-generic
  (let ((#:g662 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.441
           ('#<procedure #63 ##set-box!>
            #:g662
            (register-Generic-1
             '(1 . 1)
             'meroon-initialize!-internal-generic
             (lambda (o) o)
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g662) o)
         o)))))

(let ((g (symbol->generic 'meroon-initialize!-internal-generic)))
  ('#<procedure #33 ##vector-set!> g 1 'initialize!))

(set! initialize! meroon-initialize!-internal-generic)

'initialize!

(define clone
  (let ((#:g664 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.442
           ('#<procedure #63 ##set-box!>
            #:g664
            (register-Generic-1
             '(1 . 1)
             'clone
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g664) o)
         o)))))

(register-method
 'clone
 '((o Object))
 '(1 . 1)
 (lambda (#:g666 #:g667 #:g668) (lambda (o) (initialize! (instance-clone o))))
 'Object)

(define ->Pre-Class
  (let ((#:g670 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.443
           ('#<procedure #63 ##set-box!>
            #:g670
            (register-Generic-1
             '(1 . 1)
             '->Pre-Class
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g670) o)
         o)))))

(register-method
 '->Pre-Class
 '((o Pre-Class))
 '(1 . 1)
 (lambda (#:g672 #:g673 #:g674) (lambda (o) o))
 'Pre-Class)

(define ->Handy-Class
  (let ((#:g676 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.444
           ('#<procedure #63 ##set-box!>
            #:g676
            (register-Generic-1
             '(1 . 1)
             '->Handy-Class
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g676) o)
         o)))))

(register-method
 '->Handy-Class
 '((o Handy-Class))
 '(1 . 1)
 (lambda (#:g678 #:g679 #:g680) (lambda (o) o))
 'Handy-Class)

(define ->MeroonV2-Class
  (let ((#:g682 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.445
           ('#<procedure #63 ##set-box!>
            #:g682
            (register-Generic-1
             '(1 . 1)
             '->MeroonV2-Class
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g682) o)
         o)))))

(register-method
 '->MeroonV2-Class
 '((o MeroonV2-Class))
 '(1 . 1)
 (lambda (#:g684 #:g685 #:g686) (lambda (o) o))
 'MeroonV2-Class)

(define ->Applyable-Object
  (let ((#:g688 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.446
           ('#<procedure #63 ##set-box!>
            #:g688
            (register-Generic-1
             '(1 . 1)
             '->Applyable-Object
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g688) o)
         o)))))

(register-method
 '->Applyable-Object
 '((o Applyable-Object))
 '(1 . 1)
 (lambda (#:g690 #:g691 #:g692) (lambda (o) o))
 'Applyable-Object)

(define ->Generic-1
  (let ((#:g694 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.447
           ('#<procedure #63 ##set-box!>
            #:g694
            (register-Generic-1
             '(1 . 1)
             '->Generic-1
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g694) o)
         o)))))

(register-method
 '->Generic-1
 '((o Generic-1))
 '(1 . 1)
 (lambda (#:g696 #:g697 #:g698) (lambda (o) o))
 'Generic-1)

(define ->Generic-N
  (let ((#:g700 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.448
           ('#<procedure #63 ##set-box!>
            #:g700
            (register-Generic-1
             '(1 . 1)
             '->Generic-N
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g700) o)
         o)))))

(register-method
 '->Generic-N
 '((o Generic-N))
 '(1 . 1)
 (lambda (#:g702 #:g703 #:g704) (lambda (o) o))
 'Generic-N)

(define ->Pre-Field
  (let ((#:g706 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.449
           ('#<procedure #63 ##set-box!>
            #:g706
            (register-Generic-1
             '(1 . 1)
             '->Pre-Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g706) o)
         o)))))

(register-method
 '->Pre-Field
 '((o Pre-Field))
 '(1 . 1)
 (lambda (#:g708 #:g709 #:g710) (lambda (o) o))
 'Pre-Field)

(define ->Field
  (let ((#:g712 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.450
           ('#<procedure #63 ##set-box!>
            #:g712
            (register-Generic-1
             '(1 . 1)
             '->Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g712) o)
         o)))))

(register-method
 '->Field
 '((o Field))
 '(1 . 1)
 (lambda (#:g714 #:g715 #:g716) (lambda (o) o))
 'Field)

(define ->Mono-Field
  (let ((#:g718 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.451
           ('#<procedure #63 ##set-box!>
            #:g718
            (register-Generic-1
             '(1 . 1)
             '->Mono-Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g718) o)
         o)))))

(register-method
 '->Mono-Field
 '((o Mono-Field))
 '(1 . 1)
 (lambda (#:g720 #:g721 #:g722) (lambda (o) o))
 'Mono-Field)

(define ->Poly-Field
  (let ((#:g724 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.452
           ('#<procedure #63 ##set-box!>
            #:g724
            (register-Generic-1
             '(1 . 1)
             '->Poly-Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g724) o)
         o)))))

(register-method
 '->Poly-Field
 '((o Poly-Field))
 '(1 . 1)
 (lambda (#:g726 #:g727 #:g728) (lambda (o) o))
 'Poly-Field)

(define ->Dispatcher
  (let ((#:g730 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.453
           ('#<procedure #63 ##set-box!>
            #:g730
            (register-Generic-1
             '(1 . 1)
             '->Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g730) o)
         o)))))

(register-method
 '->Dispatcher
 '((o Dispatcher))
 '(1 . 1)
 (lambda (#:g732 #:g733 #:g734) (lambda (o) o))
 'Dispatcher)

(define ->Immediate-Dispatcher
  (let ((#:g736 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.454
           ('#<procedure #63 ##set-box!>
            #:g736
            (register-Generic-1
             '(1 . 1)
             '->Immediate-Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g736) o)
         o)))))

(register-method
 '->Immediate-Dispatcher
 '((o Immediate-Dispatcher))
 '(1 . 1)
 (lambda (#:g738 #:g739 #:g740) (lambda (o) o))
 'Immediate-Dispatcher)

(define ->Subclass-Dispatcher
  (let ((#:g742 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.455
           ('#<procedure #63 ##set-box!>
            #:g742
            (register-Generic-1
             '(1 . 1)
             '->Subclass-Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g742) o)
         o)))))

(register-method
 '->Subclass-Dispatcher
 '((o Subclass-Dispatcher))
 '(1 . 1)
 (lambda (#:g744 #:g745 #:g746) (lambda (o) o))
 'Subclass-Dispatcher)

(define ->Indexed-Dispatcher
  (let ((#:g748 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.456
           ('#<procedure #63 ##set-box!>
            #:g748
            (register-Generic-1
             '(1 . 1)
             '->Indexed-Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g748) o)
         o)))))

(register-method
 '->Indexed-Dispatcher
 '((o Indexed-Dispatcher))
 '(1 . 1)
 (lambda (#:g750 #:g751 #:g752) (lambda (o) o))
 'Indexed-Dispatcher)

(define ->Linear-Dispatcher
  (let ((#:g754 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.457
           ('#<procedure #63 ##set-box!>
            #:g754
            (register-Generic-1
             '(1 . 1)
             '->Linear-Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g754) o)
         o)))))

(register-method
 '->Linear-Dispatcher
 '((o Linear-Dispatcher))
 '(1 . 1)
 (lambda (#:g756 #:g757 #:g758) (lambda (o) o))
 'Linear-Dispatcher)

(define ->Global-Dispatcher
  (let ((#:g760 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.458
           ('#<procedure #63 ##set-box!>
            #:g760
            (register-Generic-1
             '(1 . 1)
             '->Global-Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g760) o)
         o)))))

(register-method
 '->Global-Dispatcher
 '((o Global-Dispatcher))
 '(1 . 1)
 (lambda (#:g762 #:g763 #:g764) (lambda (o) o))
 'Global-Dispatcher)

(define ->Tracing-Dispatcher
  (let ((#:g766 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.459
           ('#<procedure #63 ##set-box!>
            #:g766
            (register-Generic-1
             '(1 . 1)
             '->Tracing-Dispatcher
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g766) o)
         o)))))

(register-method
 '->Tracing-Dispatcher
 '((o Tracing-Dispatcher))
 '(1 . 1)
 (lambda (#:g768 #:g769 #:g770) (lambda (o) o))
 'Tracing-Dispatcher)

(define ->Anomaly
  (let ((#:g772 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.460
           ('#<procedure #63 ##set-box!>
            #:g772
            (register-Generic-1
             '(1 . 1)
             '->Anomaly
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g772) o)
         o)))))

(register-method
 '->Anomaly
 '((o Anomaly))
 '(1 . 1)
 (lambda (#:g774 #:g775 #:g776) (lambda (o) o))
 'Anomaly)

(define ->Warning
  (let ((#:g778 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.461
           ('#<procedure #63 ##set-box!>
            #:g778
            (register-Generic-1
             '(1 . 1)
             '->Warning
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g778) o)
         o)))))

(register-method
 '->Warning
 '((o Warning))
 '(1 . 1)
 (lambda (#:g780 #:g781 #:g782) (lambda (o) o))
 'Warning)

(define ->View
  (let ((#:g784 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.462
           ('#<procedure #63 ##set-box!>
            #:g784
            (register-Generic-1
             '(1 . 1)
             '->View
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g784) o)
         o)))))

(register-method
 '->View
 '((o View))
 '(1 . 1)
 (lambda (#:g786 #:g787 #:g788) (lambda (o) o))
 'View)

(define ->Virtual-Field
  (let ((#:g790 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.463
           ('#<procedure #63 ##set-box!>
            #:g790
            (register-Generic-1
             '(1 . 1)
             '->Virtual-Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g790) o)
         o)))))

(register-method
 '->Virtual-Field
 '((o Virtual-Field))
 '(1 . 1)
 (lambda (#:g792 #:g793 #:g794) (lambda (o) o))
 'Virtual-Field)

(define report-meroon-error
  (lambda (category operator message . hints)
    (meroon-error
     ('#<procedure #8 apply>
      make-Anomaly
      category
      operator
      message
      ('#<procedure #23 length> hints)
      hints))))

(define report-bad-index
  (lambda (field-or-field-name o index)
    (report-meroon-error
     'Domain
     (if (Field? field-or-field-name)
         field-or-field-name
         (retrieve-named-field
          ('#<procedure #32 ##vector-ref>
           *classes*
           ('#<procedure #32 ##vector-ref> o 0))
          field-or-field-name))
     "Index out of bounds"
     o
     index)))

(define report-uninitialized-field
  (lambda (field o . index)
    ('#<procedure #8 apply>
     report-meroon-error
     'Uninitialized
     field
     "Uninitialized field"
     o
     index)))

(define report-immutable-field
  (lambda (field o . index)
    ('#<procedure #8 apply>
     report-meroon-error
     'Access
     field
     "Immutable field"
     o
     index)))

(define report-missing-index
  (lambda (field o) (report-meroon-error 'Access field "Missing index" o)))

(define report-already-initialized
  (lambda (field o value . index)
    ('#<procedure #8 apply>
     report-meroon-error
     'initialize!
     field
     "Already initialized"
     o
     value
     index)))

(define report-meroon-warning
  (lambda (operator message . hints)
    (meroon-error
     ('#<procedure #8 apply>
      make-Warning
      'Warning
      operator
      message
      ('#<procedure #23 length> hints)
      hints))))

(define meroon-error
  (let ((#:g796 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.464
           ('#<procedure #63 ##set-box!>
            #:g796
            (register-Generic-1
             '(1 . 1)
             'meroon-error
             (lambda (anomaly) (oo-error 'meroon "Error" anomaly))
             '((anomaly))
             #f))))
      (lambda (anomaly)
        ((careless-determine-method1
          ('#<procedure #62 ##unbox> #:g796)
          anomaly)
         anomaly)))))

(register-method
 'meroon-error
 '((o Anomaly))
 '(1 . 1)
 (lambda (#:g798 #:g799 #:g800)
   (lambda (o)
     (let ((call-next-method
            (lambda (#:g798 #:g799 o)
              (let ((#:g801 (Class-super-number #:g799)))
                ((or (and #:g801
                          (find-method1
                           ('#<procedure #32 ##vector-ref> #:g798 4)
                           ('#<procedure #32 ##vector-ref> *classes* #:g801)))
                     (Generic-default #:g798))
                 o)))))
       (let ((begin-temp.466 (set! *last-meroon-anomaly* o)))
         (let ((begin-temp.465 (display-meroon-anomaly o)))
           (call-next-method #:g798 #:g799 o))))))
 'Anomaly)

(register-method
 'meroon-error
 '((o Warning))
 '(1 . 1)
 (lambda (#:g802 #:g803 #:g804)
   (lambda (o)
     (let ((begin-temp.467 (set! *last-meroon-anomaly* o)))
       (display-meroon-anomaly o))))
 'Warning)

(define display-meroon-anomaly
  (lambda (o)
    (let ((begin-temp.484 ('#<procedure #42 newline>)))
      (let ((begin-temp.483
             ('#<procedure #41 display> "******************* Meroon ")))
        (let ((begin-temp.482
               ('#<procedure #41 display> (Anomaly-category o))))
          (let ((begin-temp.481
                 ('#<procedure #41 display> " *********************")))
            (let ((begin-temp.480 ('#<procedure #42 newline>)))
              (let ((begin-temp.479
                     ('#<procedure #41 display> "Occurred in: ")))
                (let ((begin-temp.478 (show (Anomaly-operator o))))
                  (let ((begin-temp.477 ('#<procedure #42 newline>)))
                    (let ((begin-temp.476
                           ('#<procedure #41 display> "Reason: ")))
                      (let ((begin-temp.475 (show (Anomaly-message o))))
                        (let ((begin-temp.474 ('#<procedure #42 newline>)))
                          (letrec ((do-temp.468
                                    (lambda (o i)
                                      (if ('#<procedure #50 ##fx=>
                                           i
                                           (Anomaly-hint-length o))
                                          #f
                                          (let ((begin-temp.473
                                                 (let ((begin-temp.472
                                                        ('#<procedure #41 display>
                                                         "Hint[")))
                                                   (let ((begin-temp.471
                                                          ('#<procedure #41 display>
                                                           i)))
                                                     (let ((begin-temp.470
                                                            ('#<procedure #41 display>
                                                             "]: ")))
                                                       (let ((begin-temp.469
                                                              (show (Anomaly-hint
                                                                     o
                                                                     i))))
                                                         ('#<procedure #42 newline>)))))))
                                            (do-temp.468
                                             o
                                             ('#<procedure #21 ##fx+>
                                              1
                                              i)))))))
                            (do-temp.468 o 0)))))))))))))))

(define add-N-method!
  (lambda (g cl* method-maker)
    (let ((d (insert-N-method!
              ('#<procedure #32 ##vector-ref> g 4)
              g
              cl*
              method-maker)))
      ('#<procedure #33 ##vector-set!> g 4 d))))

(define insert-N-method!
  (let ((#:g806 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.485
           ('#<procedure #63 ##set-box!>
            #:g806
            (register-Generic-1
             '(1 . 1)
             'insert-N-method!
             meroon-uninitialized
             '((d Dispatcher) g cl* method-maker)
             'Dispatcher))))
      (lambda (d g cl* method-maker)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g806) d)
         d
         g
         cl*
         method-maker)))))

(register-method
 'insert-N-method!
 '((d Linear-Dispatcher) g cl* method-maker)
 '(1 . 1)
 (lambda (#:g808 #:g809 #:g810)
   (lambda (d g cl* method-maker)
     (let ((r (compare-signatures cl* (Linear-Dispatcher-signature d))))
       (if ('#<procedure #3 ##eq?> r '=)
           (let ((begin-temp.487
                  (set-Linear-Dispatcher-method! d (method-maker g cl* d))))
             d)
           (if ('#<procedure #3 ##eq?> r '<)
               (let ((d (make-Linear-Dispatcher
                         Linear-Dispatcher-find-multi-method
                         d
                         meroon-uninitialized
                         cl*)))
                 (let ((begin-temp.488
                        (let ((m (method-maker g cl* d)))
                          ('#<procedure #33 ##vector-set!> d 3 m))))
                   d))
               (if (or ('#<procedure #3 ##eq?> r '>)
                       ('#<procedure #3 ##eq?> r 'unrelated))
                   (let ((begin-temp.489
                          (set-Linear-Dispatcher-no!
                           d
                           (insert-N-method!
                            (Linear-Dispatcher-no d)
                            g
                            cl*
                            method-maker))))
                     d)
                   (if ('#<procedure #3 ##eq?> r 'clash)
                       (report-meroon-error
                        'Signature
                        'insert-N-method!
                        "Conflicting signatures"
                        cl*
                        (Linear-Dispatcher-signature d))
                       (report-meroon-error
                        'Domain
                        'insert-N-method!
                        "Not a status"
                        r))))))))
 'Linear-Dispatcher)

(register-method
 'insert-N-method!
 '((d Immediate-Dispatcher) g cl* method-maker)
 '(1 . 1)
 (lambda (#:g812 #:g813 #:g814)
   (lambda (d g cl* method-maker)
     (let ((d (make-Linear-Dispatcher
               Linear-Dispatcher-find-multi-method
               d
               meroon-uninitialized
               cl*)))
       (let ((begin-temp.490
              (let ((m (method-maker g cl* d)))
                ('#<procedure #33 ##vector-set!> d 3 m))))
         d))))
 'Immediate-Dispatcher)

(register-method
 'insert-N-method!
 '((d Tracing-Dispatcher) g cl* method-maker)
 '(1 . 1)
 (lambda (#:g816 #:g817 #:g818)
   (lambda (d g cl* method-maker)
     (let ((begin-temp.491
            (set-Tracing-Dispatcher-dispatcher!
             d
             (insert-N-method!
              (Tracing-Dispatcher-dispatcher d)
              g
              cl*
              method-maker))))
       d)))
 'Tracing-Dispatcher)

(define find-multi-method
  (lambda (d classes) (('#<procedure #32 ##vector-ref> d 1) d classes)))

(define Linear-Dispatcher-find-multi-method
  (lambda (d classes)
    (if (let ((r (compare-signatures classes (Linear-Dispatcher-signature d))))
          (or ('#<procedure #3 ##eq?> r '<) ('#<procedure #3 ##eq?> r '=)))
        (Linear-Dispatcher-method d)
        (let ((d (Linear-Dispatcher-no d)))
          (('#<procedure #32 ##vector-ref> d 1) d classes)))))

(define Immediate-Dispatcher-find-multi-method
  (lambda (d classes) (Immediate-Dispatcher-method d)))

(define show
  (let ((#:g820 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.492
           ('#<procedure #63 ##set-box!>
            #:g820
            (register-Generic-1
             '(1 . 1)
             'show
             (lambda (o stream)
               (let ((stream (if ('#<procedure #4 ##pair?> stream)
                                 ('#<procedure #6 ##car> stream)
                                 (current-output-port))))
                 (if ('#<procedure #71 boolean?> o)
                     ('#<procedure #41 display> (if o "#T" "#F") stream)
                     (if ('#<procedure #24 ##null?> o)
                         ('#<procedure #41 display> "()" stream)
                         (if ('#<procedure #4 ##pair?> o)
                             (show-list o stream)
                             (if ('#<procedure #56 ##vector?> o)
                                 (show-vector o stream)
                                 ('#<procedure #41 display> o stream)))))))
             '((o) . stream)
             #f))))
      (lambda (o . stream)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g820) o)
         o
         stream)))))

(define show-list
  (lambda (o . stream)
    (let ((stream (if ('#<procedure #4 ##pair?> stream)
                      ('#<procedure #6 ##car> stream)
                      (current-output-port))))
      (letrec ((show-content
                (lambda (stream o)
                  (let ((begin-temp.495
                         (show ('#<procedure #6 ##car> o) stream)))
                    (if ('#<procedure #24 ##null?> ('#<procedure #7 ##cdr> o))
                        #t
                        (if ('#<procedure #4 ##pair?>
                             ('#<procedure #7 ##cdr> o))
                            (let ((begin-temp.493
                                   ('#<procedure #41 display> " " stream)))
                              (show-content stream ('#<procedure #7 ##cdr> o)))
                            (let ((begin-temp.494
                                   ('#<procedure #41 display> " . " stream)))
                              (show ('#<procedure #7 ##cdr> o) stream))))))))
        (let ((begin-temp.497 ('#<procedure #41 display> "(" stream)))
          (let ((begin-temp.496 (show-content stream o)))
            ('#<procedure #41 display> ")" stream)))))))

(define show-vector
  (lambda (o . stream)
    (let ((n ('#<procedure #29 ##vector-length> o))
          (stream (if ('#<procedure #4 ##pair?> stream)
                      ('#<procedure #6 ##car> stream)
                      (current-output-port))))
      (letrec ((show-content
                (lambda (o n stream i)
                  (if ('#<procedure #20 ##fx<> i n)
                      (let ((begin-temp.499
                             (show ('#<procedure #32 ##vector-ref> o i)
                                   stream)))
                        (let ((begin-temp.498
                               ('#<procedure #41 display> " " stream)))
                          (show-content
                           o
                           n
                           stream
                           ('#<procedure #21 ##fx+> 1 i))))
                      #!void))))
        (let ((begin-temp.501 ('#<procedure #41 display> "#(" stream)))
          (let ((begin-temp.500 (show-content o n stream 0)))
            ('#<procedure #41 display> ")" stream)))))))

(register-method
 'show
 '((o Object) . stream)
 '(1 . 1)
 (lambda (#:g822 #:g823 #:g824)
   (lambda (o stream)
     (let ((name (Class-name
                  ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0))))
           (stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.504 ('#<procedure #41 display> "#<a" stream)))
         (let ((begin-temp.503 ('#<procedure #72 write-char> #\space stream)))
           (let ((begin-temp.502 ('#<procedure #41 display> name stream)))
             ('#<procedure #41 display> ">" stream)))))))
 'Object)

(register-method
 'show
 '((o Class) . stream)
 '(1 . 1)
 (lambda (#:g826 #:g827 #:g828)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.506 ('#<procedure #41 display> "#<Class: " stream)))
         (let ((begin-temp.505
                ('#<procedure #41 display> (Class-name o) stream)))
           ('#<procedure #41 display> ">" stream))))))
 'Class)

(register-method
 'show
 '((o Generic) . stream)
 '(1 . 1)
 (lambda (#:g830 #:g831 #:g832)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.508 ('#<procedure #41 display> "#<Generic: " stream)))
         (let ((begin-temp.507
                ('#<procedure #41 display> (Generic-name o) stream)))
           ('#<procedure #41 display> ">" stream))))))
 'Generic)

(define show-field
  (lambda (status o stream)
    (let ((begin-temp.514 ('#<procedure #41 display> "#<" stream)))
      (let ((begin-temp.513 ('#<procedure #41 display> status stream)))
        (let ((begin-temp.512
               (if (Field-immutable? o)
                   ('#<procedure #41 display> " " stream)
                   ('#<procedure #41 display> "! " stream))))
          (let ((begin-temp.511
                 ('#<procedure #41 display>
                  (Class-name
                   (let ((i (Field-class-number o)))
                     ('#<procedure #32 ##vector-ref> *classes* i)))
                  stream)))
            (let ((begin-temp.510 ('#<procedure #41 display> "." stream)))
              (let ((begin-temp.509
                     ('#<procedure #41 display> (Field-name o) stream)))
                ('#<procedure #41 display> ">" stream)))))))))

(register-method
 'show
 '((o Mono-Field) . stream)
 '(1 . 1)
 (lambda (#:g834 #:g835 #:g836)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (show-field "Mono-Field" o stream))))
 'Mono-Field)

(register-method
 'show
 '((o Poly-Field) . stream)
 '(1 . 1)
 (lambda (#:g838 #:g839 #:g840)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (show-field "Poly-Field" o stream))))
 'Poly-Field)

(register-method
 'show
 '((o Anomaly) . stream)
 '(1 . 1)
 (lambda (#:g842 #:g843 #:g844)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.518 ('#<procedure #41 display> "#<" stream)))
         (let ((begin-temp.517
                ('#<procedure #41 display> (Anomaly-category o) stream)))
           (let ((begin-temp.516
                  ('#<procedure #41 display> "-Anomaly:" stream)))
             (let ((begin-temp.515
                    ('#<procedure #41 display> (Anomaly-message o) stream)))
               ('#<procedure #41 display> ">" stream))))))))
 'Anomaly)

(register-method
 'show
 '((o Subclass-Dispatcher) . stream)
 '(1 . 1)
 (lambda (#:g846 #:g847 #:g848)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.526 ('#<procedure #41 display> "#<" stream)))
         (let ((begin-temp.525
                ('#<procedure #41 display>
                 (Class-name
                  ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0)))
                 stream)))
           (let ((begin-temp.524 ('#<procedure #41 display> " " stream)))
             (let ((begin-temp.523
                    (show (let ((i (Subclass-Dispatcher-class-number o)))
                            ('#<procedure #32 ##vector-ref> *classes* i))
                          stream)))
               (let ((begin-temp.522
                      ('#<procedure #41 display> " No: " stream)))
                 (let ((begin-temp.521
                        (show (Subclass-Dispatcher-no o) stream)))
                   (let ((begin-temp.520
                          ('#<procedure #41 display> " Yes: " stream)))
                     (let ((begin-temp.519
                            (show (Subclass-Dispatcher-yes o) stream)))
                       ('#<procedure #41 display> ">" stream))))))))))))
 'Subclass-Dispatcher)

(register-method
 'show
 '((o Indexed-Dispatcher) . stream)
 '(1 . 1)
 (lambda (#:g850 #:g851 #:g852)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.532 ('#<procedure #41 display> "#<" stream)))
         (let ((begin-temp.531
                ('#<procedure #41 display>
                 (Class-name
                  ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0)))
                 stream)))
           (let ((begin-temp.530 ('#<procedure #41 display> "/" stream)))
             (let ((begin-temp.529
                    (show (let ((i (Indexed-Dispatcher-class-number o)))
                            ('#<procedure #32 ##vector-ref> *classes* i))
                          stream)))
               (let ((begin-temp.528
                      ('#<procedure #41 display> ", no:" stream)))
                 (let ((begin-temp.527
                        (show (Indexed-Dispatcher-no o) stream)))
                   ('#<procedure #41 display> ">" stream))))))))))
 'Indexed-Dispatcher)

(register-method
 'show
 '((o Linear-Dispatcher) . stream)
 '(1 . 1)
 (lambda (#:g854 #:g855 #:g856)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.537 ('#<procedure #41 display> "#<" stream)))
         (let ((begin-temp.536
                ('#<procedure #41 display>
                 (Class-name
                  ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0)))
                 stream)))
           (let ((begin-temp.535
                  (show (Linear-Dispatcher-signature o) stream)))
             (let ((begin-temp.534 ('#<procedure #41 display> ", no:" stream)))
               (let ((begin-temp.533 (show (Linear-Dispatcher-no o) stream)))
                 ('#<procedure #41 display> ">" stream)))))))))
 'Linear-Dispatcher)

(register-method
 'show
 '((o Immediate-Dispatcher) . stream)
 '(1 . 1)
 (lambda (#:g858 #:g859 #:g860)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.541 ('#<procedure #41 display> "#<" stream)))
         (let ((begin-temp.540
                ('#<procedure #41 display>
                 (Class-name
                  ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0)))
                 stream)))
           (let ((begin-temp.539 ('#<procedure #41 display> ":" stream)))
             (let ((begin-temp.538
                    (show (Immediate-Dispatcher-method o) stream)))
               ('#<procedure #41 display> ">" stream))))))))
 'Immediate-Dispatcher)

(register-method
 'show
 '((o Tracing-Dispatcher) . stream)
 '(1 . 1)
 (lambda (#:g862 #:g863 #:g864)
   (lambda (o stream)
     (let ((stream (if ('#<procedure #4 ##pair?> stream)
                       ('#<procedure #6 ##car> stream)
                       (current-output-port))))
       (let ((begin-temp.545 ('#<procedure #41 display> "#<" stream)))
         (let ((begin-temp.544
                ('#<procedure #41 display>
                 (Class-name
                  ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0)))
                 stream)))
           (let ((begin-temp.543 ('#<procedure #41 display> ":" stream)))
             (let ((begin-temp.542
                    (show (Tracing-Dispatcher-dispatcher o) stream)))
               ('#<procedure #41 display> ">" stream))))))))
 'Tracing-Dispatcher)

(define show-hierarchy
  (lambda args
    (let ((arg (if ('#<procedure #4 ##pair?> args)
                   ('#<procedure #6 ##car> args)
                   'Object)))
      (let ((class (->Class arg)))
        (let ((str (if ('#<procedure #4 ##pair?> args)
                       ('#<procedure #7 ##cdr> args)
                       '())))
          (let ((stream (if ('#<procedure #4 ##pair?> str)
                            ('#<procedure #6 ##car> str)
                            (current-output-port))))
            (letrec ((show-class
                      (lambda (stream c indent)
                        (let ((begin-temp.550
                               (letrec ((do-temp.546
                                         (lambda (stream indent i)
                                           (if ('#<procedure #36 ##fx>=>
                                                i
                                                indent)
                                               #!void
                                               (let ((begin-temp.547
                                                      ('#<procedure #41 display>
                                                       " "
                                                       stream)))
                                                 (let ((i ('#<procedure #21 ##fx+>
                                                           1
                                                           i)))
                                                   (if ('#<procedure #36 ##fx>=>
                                                        i
                                                        indent)
                                                       #!void
                                                       (let ((begin-temp.547
                                                              ('#<procedure #41 display>
                                                               " "
                                                               stream)))
                                                         (do-temp.546
                                                          stream
                                                          indent
                                                          ('#<procedure #21 ##fx+>
                                                           1
                                                           i))))))))))
                                 (do-temp.546 stream indent 0))))
                          (let ((begin-temp.549 (show c stream)))
                            (let ((begin-temp.548
                                   ('#<procedure #42 newline> stream)))
                              (let ((temp.1084 (Class-subclasses c)))
                                (letrec ((loop2.1085
                                          (lambda (stream indent lst2.1086)
                                            (if ('#<procedure #4 ##pair?>
                                                 lst2.1086)
                                                (let ((x.1087 (let ((c ('#<procedure #6 ##car>
                                                                        lst2.1086)))
                                                                (show-class
                                                                 stream
                                                                 c
                                                                 ('#<procedure #21 ##fx+>
                                                                  indent
                                                                  1)))))
                                                  (let ((lst2.1086
                                                         ('#<procedure #7 ##cdr>
                                                          lst2.1086)))
                                                    (if ('#<procedure #4 ##pair?>
                                                         lst2.1086)
                                                        (let ((x.1087 (let ((c ('#<procedure #6 ##car>
                                                                                lst2.1086)))
                                                                        (show-class
                                                                         stream
                                                                         c
                                                                         ('#<procedure #21 ##fx+>
                                                                          indent
                                                                          1)))))
                                                          (loop2.1085
                                                           stream
                                                           indent
                                                           ('#<procedure #7 ##cdr>
                                                            lst2.1086)))
                                                        #!void)))
                                                #!void))))
                                  (loop2.1085 stream indent temp.1084)))))))))
              (let ((begin-temp.554
                     ('#<procedure #41 display> "Subclass tree of " stream)))
                (let ((begin-temp.553
                       ('#<procedure #41 display> (Class-name class) stream)))
                  (let ((begin-temp.552 ('#<procedure #42 newline> stream)))
                    (let ((begin-temp.551 (show-class stream class 0)))
                      #t)))))))))))

(define show-generic
  (lambda args
    (if ('#<procedure #4 ##pair?> args)
        ('#<procedure #8 apply> show-generic-function args)
        (sequence-map
         (lambda (generic) (if generic (show-generic-function generic) #!void))
         *generics*))))

(define show-generic-function
  (lambda (name . stream)
    (let ((stream (if ('#<procedure #4 ##pair?> stream)
                      ('#<procedure #6 ##car> stream)
                      (current-output-port))))
      (let ((generic (->Generic name)))
        (let ((name (Generic-name generic)))
          (let ((dispatcher (Generic-dispatcher generic)))
            (letrec ((show-1-method
                      (lambda (stream dispatcher c super-method indent)
                        (let ((current-method (find-method1 dispatcher c)))
                          (let ((begin-temp.562
                                 (if ('#<procedure #3 ##eq?>
                                      super-method
                                      current-method)
                                     #!void
                                     (let ((begin-temp.561
                                            (letrec ((do-temp.558
                                                      (lambda (stream indent i)
                                                        (if ('#<procedure #36 ##fx>=>
                                                             i
                                                             indent)
                                                            #!void
                                                            (let ((begin-temp.559
                                                                   ('#<procedure #41 display>
                                                                    " "
                                                                    stream)))
                                                              (let ((i ('#<procedure #21 ##fx+>
                                                                        1
                                                                        i)))
                                                                (if ('#<procedure #36 ##fx>=>
                                                                     i
                                                                     indent)
                                                                    #!void
                                                                    (let ((begin-temp.559
                                                                           ('#<procedure #41 display>
                                                                            " "
                                                                            stream)))
                                                                      (do-temp.558
                                                                       stream
                                                                       indent
                                                                       ('#<procedure #21 ##fx+>
                                                                        1
                                                                        i))))))))))
                                              (do-temp.558 stream indent 0))))
                                       (let ((begin-temp.560 (show c stream)))
                                         ('#<procedure #42 newline>
                                          stream))))))
                            (let ((temp.1089 (Class-subclasses c)))
                              (letrec ((loop2.1090
                                        (lambda (stream
                                                 dispatcher
                                                 indent
                                                 current-method
                                                 lst2.1091)
                                          (if ('#<procedure #4 ##pair?>
                                               lst2.1091)
                                              (let ((x.1092 (let ((c ('#<procedure #6 ##car>
                                                                      lst2.1091)))
                                                              (show-1-method
                                                               stream
                                                               dispatcher
                                                               c
                                                               current-method
                                                               ('#<procedure #21 ##fx+>
                                                                indent
                                                                1)))))
                                                (let ((lst2.1091
                                                       ('#<procedure #7 ##cdr>
                                                        lst2.1091)))
                                                  (if ('#<procedure #4 ##pair?>
                                                       lst2.1091)
                                                      (let ((x.1092 (let ((c ('#<procedure #6 ##car>
                                                                              lst2.1091)))
                                                                      (show-1-method
                                                                       stream
                                                                       dispatcher
                                                                       c
                                                                       current-method
                                                                       ('#<procedure #21 ##fx+>
                                                                        indent
                                                                        1)))))
                                                        (loop2.1090
                                                         stream
                                                         dispatcher
                                                         indent
                                                         current-method
                                                         ('#<procedure #7 ##cdr>
                                                          lst2.1091)))
                                                      #!void)))
                                              #!void))))
                                (loop2.1090
                                 stream
                                 dispatcher
                                 indent
                                 current-method
                                 temp.1089))))))))
              (letrec ((show-N-method
                        (lambda (stream d)
                          (if (Linear-Dispatcher? d)
                              (let ((begin-temp.557
                                     (let ((temp.1094
                                            (Linear-Dispatcher-signature d)))
                                       (letrec ((loop2.1095
                                                 (lambda (stream lst2.1096)
                                                   (if ('#<procedure #4 ##pair?>
                                                        lst2.1096)
                                                       (let ((x.1097 (let ((c ('#<procedure #6 ##car>
                                                                               lst2.1096)))
                                                                       (let ((begin-temp.555
                                                                              ('#<procedure #41 display>
                                                                               " "
                                                                               stream)))
                                                                         (show c)))))
                                                         (let ((lst2.1096
                                                                ('#<procedure #7 ##cdr>
                                                                 lst2.1096)))
                                                           (if ('#<procedure #4 ##pair?>
                                                                lst2.1096)
                                                               (let ((x.1097 (let ((c ('#<procedure #6 ##car>
                                                                                       lst2.1096)))
                                                                               (let ((begin-temp.555
                                                                                      ('#<procedure #41 display>
                                                                                       " "
                                                                                       stream)))
                                                                                 (show c)))))
                                                                 (loop2.1095
                                                                  stream
                                                                  ('#<procedure #7 ##cdr>
                                                                   lst2.1096)))
                                                               #!void)))
                                                       #!void))))
                                         (loop2.1095 stream temp.1094)))))
                                (let ((begin-temp.556
                                       ('#<procedure #42 newline> stream)))
                                  (show-N-method
                                   stream
                                   (Linear-Dispatcher-no d))))
                              ('#<procedure #42 newline> stream)))))
                (let ((begin-temp.566
                       ('#<procedure #41 display> "Methods on " stream)))
                  (let ((begin-temp.565
                         ('#<procedure #41 display> name stream)))
                    (let ((begin-temp.564 ('#<procedure #42 newline> stream)))
                      (let ((begin-temp.563
                             (if (Generic-1? generic)
                                 (show-1-method
                                  stream
                                  dispatcher
                                  Object-class
                                  #f
                                  0)
                                 (if (Generic-N? generic)
                                     (show-N-method
                                      stream
                                      (Generic-dispatcher generic))
                                     #!void))))
                        #t))))))))))))

(define show-dispatcher
  (lambda g
    (if ('#<procedure #4 ##pair?> g)
        (let ((generic (->Generic ('#<procedure #6 ##car> g))))
          (show (Generic-dispatcher generic)))
        (sequence-map
         (lambda (g)
           (if g
               (let ((begin-temp.570
                      ('#<procedure #41 display> "Dispatcher of ")))
                 (let ((begin-temp.569
                        ('#<procedure #41 display> (Generic-name g))))
                   (let ((begin-temp.568 ('#<procedure #42 newline>)))
                     (let ((begin-temp.567 (show-dispatcher g)))
                       ('#<procedure #42 newline>)))))
               #!void))
         *generics*))))

(define show-methods-for-class
  (lambda (class . stream)
    (let ((stream (if ('#<procedure #4 ##pair?> stream)
                      ('#<procedure #6 ##car> stream)
                      (current-output-port))))
      (let ((class (->Class class)))
        (sequence-map
         (lambda (g) (if g (search-methods-for-class g class stream) #!void))
         *generics*)))))

(define search-methods-for-class
  (let ((#:g866 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.571
           ('#<procedure #63 ##set-box!>
            #:g866
            (register-Generic-1
             '(1 . 1)
             'search-methods-for-class
             meroon-uninitialized
             '((o) c stream)
             #f))))
      (lambda (o c stream)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g866) o)
         o
         c
         stream)))))

(register-method
 'search-methods-for-class
 '((g Generic-1) c stream)
 '(1 . 1)
 (lambda (#:g868 #:g869 #:g870)
   (lambda (g c stream)
     (let ((d (Generic-dispatcher g)) (super (Class-super-class c)))
       (if super
           (let ((m (find-method1 d c)) (superm (find-method1 d super)))
             (if ('#<procedure #3 ##eq?> m superm)
                 #f
                 (let ((begin-temp.574 (show g stream)))
                   (let ((begin-temp.573
                          ('#<procedure #41 display>
                           " has a method for "
                           stream)))
                     (let ((begin-temp.572 (show c stream)))
                       ('#<procedure #42 newline> stream))))))
           #!void))))
 'Generic-1)

(register-method
 'search-methods-for-class
 '((g Generic-N) c stream)
 '(1 . 1)
 (lambda (#:g872 #:g873 #:g874)
   (lambda (g c stream)
     (letrec ((scan (lambda (g c stream d)
                      (if (Linear-Dispatcher? d)
                          (let ((begin-temp.578
                                 (let ((sig (Linear-Dispatcher-signature d)))
                                   (if ('#<procedure #73 member> c sig)
                                       (let ((begin-temp.577 (show g stream)))
                                         (let ((begin-temp.576
                                                ('#<procedure #41 display>
                                                 " has a method for "
                                                 stream)))
                                           (let ((begin-temp.575
                                                  (show sig stream)))
                                             ('#<procedure #42 newline>
                                              stream))))
                                       #!void))))
                            (scan g c stream (Linear-Dispatcher-no d)))
                          #!void))))
       (scan g c stream (Generic-dispatcher g)))))
 'Generic-N)

(define show-detailed-hierarchy
  (lambda message
    (let ((stream (current-output-port)))
      (letrec ((show-class
                (lambda (stream c indent)
                  (let ((begin-temp.585
                         (letrec ((do-temp.579
                                   (lambda (stream indent i)
                                     (if ('#<procedure #36 ##fx>=> i indent)
                                         #!void
                                         (let ((begin-temp.580
                                                ('#<procedure #41 display>
                                                 " "
                                                 stream)))
                                           (let ((i ('#<procedure #21 ##fx+>
                                                     1
                                                     i)))
                                             (if ('#<procedure #36 ##fx>=>
                                                  i
                                                  indent)
                                                 #!void
                                                 (let ((begin-temp.580
                                                        ('#<procedure #41 display>
                                                         " "
                                                         stream)))
                                                   (do-temp.579
                                                    stream
                                                    indent
                                                    ('#<procedure #21 ##fx+>
                                                     1
                                                     i))))))))))
                           (do-temp.579 stream indent 0))))
                    (let ((begin-temp.584
                           ('#<procedure #41 display>
                            ('#<procedure #32 ##vector-ref> c 1)
                            stream)))
                      (let ((begin-temp.583
                             ('#<procedure #41 display> " " stream)))
                        (let ((begin-temp.582
                               ('#<procedure #41 display>
                                ('#<procedure #34 ##list>
                                 ('#<procedure #32 ##vector-ref> c 2))
                                stream)))
                          (let ((begin-temp.581
                                 ('#<procedure #42 newline> stream)))
                            (let ((temp.1099 (Class-subclass-numbers c)))
                              (letrec ((loop2.1100
                                        (lambda (stream indent lst2.1101)
                                          (if ('#<procedure #4 ##pair?>
                                               lst2.1101)
                                              (let ((x.1102 (let ((cn ('#<procedure #6 ##car>
                                                                       lst2.1101)))
                                                              (show-class
                                                               stream
                                                               ('#<procedure #32 ##vector-ref>
                                                                *classes*
                                                                cn)
                                                               ('#<procedure #21 ##fx+>
                                                                indent
                                                                1)))))
                                                (let ((lst2.1101
                                                       ('#<procedure #7 ##cdr>
                                                        lst2.1101)))
                                                  (if ('#<procedure #4 ##pair?>
                                                       lst2.1101)
                                                      (let ((x.1102 (let ((cn ('#<procedure #6 ##car>
                                                                               lst2.1101)))
                                                                      (show-class
                                                                       stream
                                                                       ('#<procedure #32 ##vector-ref>
                                                                        *classes*
                                                                        cn)
                                                                       ('#<procedure #21 ##fx+>
                                                                        indent
                                                                        1)))))
                                                        (loop2.1100
                                                         stream
                                                         indent
                                                         ('#<procedure #7 ##cdr>
                                                          lst2.1101)))
                                                      #!void)))
                                              #!void))))
                                (loop2.1100 stream indent temp.1099)))))))))))
        (let ((begin-temp.591
               ('#<procedure #41 display> "Detailed Class tree of " stream)))
          (let ((begin-temp.590
                 ('#<procedure #41 display>
                  ('#<procedure #32 ##vector-ref> Object-class 1)
                  stream)))
            (let ((begin-temp.589
                   (if ('#<procedure #4 ##pair?> message)
                       (let ((begin-temp.586
                              ('#<procedure #41 display> " " stream)))
                         ('#<procedure #41 display>
                          ('#<procedure #6 ##car> message)
                          stream))
                       #!void)))
              (let ((begin-temp.588 ('#<procedure #42 newline> stream)))
                (let ((begin-temp.587 (show-class stream Object-class 0)))
                  #t)))))))))

(define *traced-generics* ('#<procedure #34 ##list>))

(define generic-trace
  (lambda (generic before after)
    (let ((generic (->Generic generic)))
      (let ((begin-temp.597
             (if ('#<procedure #74 ##procedure?> before)
                 #!void
                 (report-meroon-error
                  'Domain
                  'generic-trace
                  "Not a procedure"
                  before))))
        (let ((begin-temp.596
               (if ('#<procedure #74 ##procedure?> after)
                   #!void
                   (report-meroon-error
                    'Domain
                    'generic-trace
                    "Not a procedure"
                    after))))
          (let ((begin-temp.595
                 (if (let ((temp.1104 *traced-generics*))
                       (letrec ((loop.1105
                                 (lambda (generic lst1.1106)
                                   (if ('#<procedure #4 ##pair?> lst1.1106)
                                       (let ((x.1107 ('#<procedure #6 ##car>
                                                      lst1.1106)))
                                         (if ('#<procedure #3 ##eq?>
                                              generic
                                              ('#<procedure #6 ##car> x.1107))
                                             x.1107
                                             (loop.1105
                                              generic
                                              ('#<procedure #7 ##cdr>
                                               lst1.1106))))
                                       #f))))
                         (loop.1105 generic temp.1104)))
                     #!void
                     (let ((default (Generic-default generic)))
                       (let ((begin-temp.594
                              (set! *traced-generics*
                                    ('#<procedure #10 ##cons>
                                     ('#<procedure #10 ##cons> generic default)
                                     *traced-generics*))))
                         (let ((begin-temp.593
                                (set-Generic-default!
                                 generic
                                 (lambda all-arguments
                                   (let ((begin-temp.592
                                          ('#<procedure #8 apply>
                                           before
                                           all-arguments)))
                                     (after ('#<procedure #8 apply>
                                             default
                                             all-arguments)))))))
                           (set-Generic-dispatcher!
                            generic
                            (make-Tracing-Dispatcher
                             (build-Tracing-Dispatcher-find-method
                              before
                              after)
                             (Generic-dispatcher generic)
                             default))))))))
            generic))))))

(define build-Tracing-Dispatcher-find-method
  (lambda (before after)
    (lambda (d args)
      (lambda all-arguments
        (let ((nextd (Tracing-Dispatcher-dispatcher d)))
          (let ((method (('#<procedure #32 ##vector-ref> nextd 1) nextd args)))
            (let ((begin-temp.598
                   ('#<procedure #8 apply> before all-arguments)))
              (after ('#<procedure #8 apply>
                      (or method (Tracing-Dispatcher-default d))
                      all-arguments)))))))))

(define generic-untrace
  (lambda (generic)
    (let ((generic (->Generic generic)))
      (let ((name (Generic-name generic)))
        (let ((p (let ((temp.1109 *traced-generics*))
                   (letrec ((loop.1110
                             (lambda (generic lst1.1111)
                               (if ('#<procedure #4 ##pair?> lst1.1111)
                                   (let ((x.1112 ('#<procedure #6 ##car>
                                                  lst1.1111)))
                                     (if ('#<procedure #3 ##eq?>
                                          generic
                                          ('#<procedure #6 ##car> x.1112))
                                         x.1112
                                         (loop.1110
                                          generic
                                          ('#<procedure #7 ##cdr> lst1.1111))))
                                   #f))))
                     (loop.1110 generic temp.1109)))))
          (if ('#<procedure #4 ##pair?> p)
              (let ((begin-temp.601
                     (set! *traced-generics*
                           (letrec ((remq (lambda (p g*)
                                            (if ('#<procedure #4 ##pair?> g*)
                                                (if ('#<procedure #3 ##eq?>
                                                     ('#<procedure #6 ##car>
                                                      g*)
                                                     p)
                                                    ('#<procedure #7 ##cdr> g*)
                                                    ('#<procedure #10 ##cons>
                                                     ('#<procedure #6 ##car>
                                                      g*)
                                                     (remq p
                                                           ('#<procedure #7 ##cdr>
                                                            g*))))
                                                g*))))
                             (remq p *traced-generics*)))))
                (let ((begin-temp.600
                       (set-Generic-default!
                        generic
                        ('#<procedure #7 ##cdr> p))))
                  (let ((begin-temp.599
                         (set-Generic-dispatcher!
                          generic
                          (remove-Tracing-Dispatcher!
                           (Generic-dispatcher generic)))))
                    generic)))
              #!void))))))

(define remove-Tracing-Dispatcher!
  (let ((#:g876 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.602
           ('#<procedure #63 ##set-box!>
            #:g876
            (register-Generic-1
             '(1 . 1)
             'remove-Tracing-Dispatcher!
             meroon-uninitialized
             '((d Dispatcher))
             'Dispatcher))))
      (lambda (d)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g876) d)
         d)))))

(register-method
 'remove-Tracing-Dispatcher!
 '((d Immediate-Dispatcher))
 '(1 . 1)
 (lambda (#:g878 #:g879 #:g880) (lambda (d) d))
 'Immediate-Dispatcher)

(register-method
 'remove-Tracing-Dispatcher!
 '((d Indexed-Dispatcher))
 '(1 . 1)
 (lambda (#:g882 #:g883 #:g884)
   (lambda (d)
     (let ((begin-temp.603
            (set-Indexed-Dispatcher-no!
             d
             (remove-Tracing-Dispatcher! (Indexed-Dispatcher-no d)))))
       d)))
 'Indexed-Dispatcher)

(register-method
 'remove-Tracing-Dispatcher!
 '((d Global-Dispatcher))
 '(1 . 1)
 (lambda (#:g886 #:g887 #:g888) (lambda (d) d))
 'Global-Dispatcher)

(register-method
 'remove-Tracing-Dispatcher!
 '((d Subclass-Dispatcher))
 '(1 . 1)
 (lambda (#:g890 #:g891 #:g892)
   (lambda (d)
     (let ((begin-temp.605
            (set-Subclass-Dispatcher-no!
             d
             (remove-Tracing-Dispatcher! (Subclass-Dispatcher-no d)))))
       (let ((begin-temp.604
              (set-Subclass-Dispatcher-yes!
               d
               (remove-Tracing-Dispatcher! (Subclass-Dispatcher-yes d)))))
         d))))
 'Subclass-Dispatcher)

(register-method
 'remove-Tracing-Dispatcher!
 '((d Linear-Dispatcher))
 '(1 . 1)
 (lambda (#:g894 #:g895 #:g896)
   (lambda (d)
     (let ((begin-temp.606
            (set-Linear-Dispatcher-no!
             d
             (remove-Tracing-Dispatcher! (Linear-Dispatcher-no d)))))
       d)))
 'Linear-Dispatcher)

(register-method
 'remove-Tracing-Dispatcher!
 '((d Tracing-Dispatcher))
 '(1 . 1)
 (lambda (#:g898 #:g899 #:g900)
   (lambda (d) (remove-Tracing-Dispatcher! (Tracing-Dispatcher-dispatcher d))))
 'Tracing-Dispatcher)

(register-method
 'enlarge-dispatcher!
 '((d Tracing-Dispatcher))
 '(1 . 1)
 (lambda (#:g902 #:g903 #:g904)
   (lambda (d)
     (let ((begin-temp.607
            (set-Tracing-Dispatcher-dispatcher!
             d
             (enlarge-dispatcher! (Tracing-Dispatcher-dispatcher d)))))
       d)))
 'Tracing-Dispatcher)

(define show-generic-trace
  (lambda names
    (letrec ((loop2.1120
              (lambda (lst2.1121)
                (if ('#<procedure #4 ##pair?> lst2.1121)
                    (let ((x.1122 (let ((name ('#<procedure #6 ##car>
                                               lst2.1121)))
                                    (let ((after (lambda (result)
                                                   (let ((begin-temp.615
                                                          (show name)))
                                                     (let ((begin-temp.614
                                                            ('#<procedure #41 display>
                                                             ">> ")))
                                                       (let ((begin-temp.613
                                                              (show result)))
                                                         (let ((begin-temp.612
                                                                ('#<procedure #42 newline>)))
                                                           result))))))
                                          (before (lambda args
                                                    (let ((begin-temp.611
                                                           (show name)))
                                                      (let ((begin-temp.610
                                                             ('#<procedure #41 display>
                                                              "<<")))
                                                        (let ((begin-temp.609
                                                               (letrec ((loop2.1115
                                                                         (lambda (lst2.1116)
                                                                           (if ('#<procedure #4 ##pair?>
                                                                                lst2.1116)
                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                         lst2.1116)))
                                                                                               (let ((begin-temp.608
                                                                                                      ('#<procedure #41 display>
                                                                                                       " ")))
                                                                                                 (show arg)))))
                                                                                 (let ((lst2.1116
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         lst2.1116)))
                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                        lst2.1116)
                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                 lst2.1116)))
                                                                                                       (let ((begin-temp.608
                                                                                                              ('#<procedure #41 display>
                                                                                                               " ")))
                                                                                                         (show arg)))))
                                                                                         (let ((lst2.1116
                                                                                                ('#<procedure #7 ##cdr>
                                                                                                 lst2.1116)))
                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                lst2.1116)
                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                         lst2.1116)))
                                                                                                               (let ((begin-temp.608
                                                                                                                      ('#<procedure #41 display>
                                                                                                                       " ")))
                                                                                                                 (show arg)))))
                                                                                                 (let ((lst2.1116
                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                         lst2.1116)))
                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                        lst2.1116)
                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                 lst2.1116)))
                                                                                                                       (let ((begin-temp.608
                                                                                                                              ('#<procedure #41 display>
                                                                                                                               " ")))
                                                                                                                         (show arg)))))
                                                                                                         (let ((lst2.1116
                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                 lst2.1116)))
                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                lst2.1116)
                                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                         lst2.1116)))
                                                                                                                               (let ((begin-temp.608
                                                                                                                                      ('#<procedure #41 display>
                                                                                                                                       " ")))
                                                                                                                                 (show arg)))))
                                                                                                                 (let ((lst2.1116
                                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                                         lst2.1116)))
                                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                                        lst2.1116)
                                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                 lst2.1116)))
                                                                                                                                       (let ((begin-temp.608
                                                                                                                                              ('#<procedure #41 display>
                                                                                                                                               " ")))
                                                                                                                                         (show arg)))))
                                                                                                                         (let ((lst2.1116
                                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                                 lst2.1116)))
                                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                                lst2.1116)
                                                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                         lst2.1116)))
                                                                                                                                               (let ((begin-temp.608
                                                                                                                                                      ('#<procedure #41 display>
                                                                                                                                                       " ")))
                                                                                                                                                 (show arg)))))
                                                                                                                                 (let ((lst2.1116
                                                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                                                         lst2.1116)))
                                                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                                                        lst2.1116)
                                                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                                 lst2.1116)))
                                                                                                                                                       (let ((begin-temp.608
                                                                                                                                                              ('#<procedure #41 display>
                                                                                                                                                               " ")))
                                                                                                                                                         (show arg)))))
                                                                                                                                         (let ((lst2.1116
                                                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                                                 lst2.1116)))
                                                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                                                lst2.1116)
                                                                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                                         lst2.1116)))
                                                                                                                                                               (let ((begin-temp.608
                                                                                                                                                                      ('#<procedure #41 display>
                                                                                                                                                                       " ")))
                                                                                                                                                                 (show arg)))))
                                                                                                                                                 (loop2.1115
                                                                                                                                                  ('#<procedure #7 ##cdr>
                                                                                                                                                   lst2.1116)))
                                                                                                                                               #!void)))
                                                                                                                                       #!void)))
                                                                                                                               #!void)))
                                                                                                                       #!void)))
                                                                                                               #!void)))
                                                                                                       #!void)))
                                                                                               #!void)))
                                                                                       #!void)))
                                                                               #!void))))
                                                                 (loop2.1115
                                                                  args))))
                                                          ('#<procedure #42 newline>))))))
                                          (generic (->Generic name)))
                                      (let ((generic (->Generic generic)))
                                        (let ((begin-temp.597
                                               (if ('#<procedure #74 ##procedure?>
                                                    before)
                                                   #!void
                                                   (report-meroon-error
                                                    'Domain
                                                    'generic-trace
                                                    "Not a procedure"
                                                    before))))
                                          (let ((begin-temp.596
                                                 (if ('#<procedure #74 ##procedure?>
                                                      after)
                                                     #!void
                                                     (report-meroon-error
                                                      'Domain
                                                      'generic-trace
                                                      "Not a procedure"
                                                      after))))
                                            (let ((begin-temp.595
                                                   (if (let ((temp.1104
                                                              *traced-generics*))
                                                         (letrec ((loop.1105
                                                                   (lambda (generic
                                                                            lst1.1106)
                                                                     (if ('#<procedure #4 ##pair?>
                                                                          lst1.1106)
                                                                         (let ((x.1107 ('#<procedure #6 ##car>
                                                                                        lst1.1106)))
                                                                           (if ('#<procedure #3 ##eq?>
                                                                                generic
                                                                                ('#<procedure #6 ##car>
                                                                                 x.1107))
                                                                               x.1107
                                                                               (loop.1105
                                                                                generic
                                                                                ('#<procedure #7 ##cdr>
                                                                                 lst1.1106))))
                                                                         #f))))
                                                           (loop.1105
                                                            generic
                                                            temp.1104)))
                                                       #!void
                                                       (let ((default (Generic-default
                                                                       generic)))
                                                         (let ((begin-temp.594
                                                                (set! *traced-generics*
                                                                      ('#<procedure #10 ##cons>
                                                                       ('#<procedure #10 ##cons>
                                                                        generic
                                                                        default)
                                                                       *traced-generics*))))
                                                           (let ((begin-temp.593
                                                                  (set-Generic-default!
                                                                   generic
                                                                   (lambda all-arguments
                                                                     (let ((begin-temp.592
                                                                            ('#<procedure #8 apply>
                                                                             before
                                                                             all-arguments)))
                                                                       (after ('#<procedure #8 apply>
                                                                               default
                                                                               all-arguments)))))))
                                                             (set-Generic-dispatcher!
                                                              generic
                                                              (make-Tracing-Dispatcher
                                                               (build-Tracing-Dispatcher-find-method
                                                                before
                                                                after)
                                                               (Generic-dispatcher
                                                                generic)
                                                               default))))))))
                                              generic))))))))
                      (let ((lst2.1121 ('#<procedure #7 ##cdr> lst2.1121)))
                        (if ('#<procedure #4 ##pair?> lst2.1121)
                            (let ((x.1122 (let ((name ('#<procedure #6 ##car>
                                                       lst2.1121)))
                                            (let ((after (lambda (result)
                                                           (let ((begin-temp.615
                                                                  (show name)))
                                                             (let ((begin-temp.614
                                                                    ('#<procedure #41 display>
                                                                     ">> ")))
                                                               (let ((begin-temp.613
                                                                      (show result)))
                                                                 (let ((begin-temp.612
                                                                        ('#<procedure #42 newline>)))
                                                                   result))))))
                                                  (before (lambda args
                                                            (let ((begin-temp.611
                                                                   (show name)))
                                                              (let ((begin-temp.610
                                                                     ('#<procedure #41 display>
                                                                      "<<")))
                                                                (let ((begin-temp.609
                                                                       (letrec ((loop2.1115
                                                                                 (lambda (lst2.1116)
                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                        lst2.1116)
                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                 lst2.1116)))
                                                                                                       (let ((begin-temp.608
                                                                                                              ('#<procedure #41 display>
                                                                                                               " ")))
                                                                                                         (show arg)))))
                                                                                         (let ((lst2.1116
                                                                                                ('#<procedure #7 ##cdr>
                                                                                                 lst2.1116)))
                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                lst2.1116)
                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                         lst2.1116)))
                                                                                                               (let ((begin-temp.608
                                                                                                                      ('#<procedure #41 display>
                                                                                                                       " ")))
                                                                                                                 (show arg)))))
                                                                                                 (let ((lst2.1116
                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                         lst2.1116)))
                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                        lst2.1116)
                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                 lst2.1116)))
                                                                                                                       (let ((begin-temp.608
                                                                                                                              ('#<procedure #41 display>
                                                                                                                               " ")))
                                                                                                                         (show arg)))))
                                                                                                         (let ((lst2.1116
                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                 lst2.1116)))
                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                lst2.1116)
                                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                         lst2.1116)))
                                                                                                                               (let ((begin-temp.608
                                                                                                                                      ('#<procedure #41 display>
                                                                                                                                       " ")))
                                                                                                                                 (show arg)))))
                                                                                                                 (let ((lst2.1116
                                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                                         lst2.1116)))
                                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                                        lst2.1116)
                                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                 lst2.1116)))
                                                                                                                                       (let ((begin-temp.608
                                                                                                                                              ('#<procedure #41 display>
                                                                                                                                               " ")))
                                                                                                                                         (show arg)))))
                                                                                                                         (let ((lst2.1116
                                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                                 lst2.1116)))
                                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                                lst2.1116)
                                                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                         lst2.1116)))
                                                                                                                                               (let ((begin-temp.608
                                                                                                                                                      ('#<procedure #41 display>
                                                                                                                                                       " ")))
                                                                                                                                                 (show arg)))))
                                                                                                                                 (let ((lst2.1116
                                                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                                                         lst2.1116)))
                                                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                                                        lst2.1116)
                                                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                                 lst2.1116)))
                                                                                                                                                       (let ((begin-temp.608
                                                                                                                                                              ('#<procedure #41 display>
                                                                                                                                                               " ")))
                                                                                                                                                         (show arg)))))
                                                                                                                                         (let ((lst2.1116
                                                                                                                                                ('#<procedure #7 ##cdr>
                                                                                                                                                 lst2.1116)))
                                                                                                                                           (if ('#<procedure #4 ##pair?>
                                                                                                                                                lst2.1116)
                                                                                                                                               (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                                         lst2.1116)))
                                                                                                                                                               (let ((begin-temp.608
                                                                                                                                                                      ('#<procedure #41 display>
                                                                                                                                                                       " ")))
                                                                                                                                                                 (show arg)))))
                                                                                                                                                 (let ((lst2.1116
                                                                                                                                                        ('#<procedure #7 ##cdr>
                                                                                                                                                         lst2.1116)))
                                                                                                                                                   (if ('#<procedure #4 ##pair?>
                                                                                                                                                        lst2.1116)
                                                                                                                                                       (let ((x.1117 (let ((arg ('#<procedure #6 ##car>
                                                                                                                                                                                 lst2.1116)))
                                                                                                                                                                       (let ((begin-temp.608
                                                                                                                                                                              ('#<procedure #41 display>
                                                                                                                                                                               " ")))
                                                                                                                                                                         (show arg)))))
                                                                                                                                                         (loop2.1115
                                                                                                                                                          ('#<procedure #7 ##cdr>
                                                                                                                                                           lst2.1116)))
                                                                                                                                                       #!void)))
                                                                                                                                               #!void)))
                                                                                                                                       #!void)))
                                                                                                                               #!void)))
                                                                                                                       #!void)))
                                                                                                               #!void)))
                                                                                                       #!void)))
                                                                                               #!void)))
                                                                                       #!void))))
                                                                         (loop2.1115
                                                                          args))))
                                                                  ('#<procedure #42 newline>))))))
                                                  (generic (->Generic name)))
                                              (let ((generic (->Generic
                                                              generic)))
                                                (let ((begin-temp.597
                                                       (if ('#<procedure #74 ##procedure?>
                                                            before)
                                                           #!void
                                                           (report-meroon-error
                                                            'Domain
                                                            'generic-trace
                                                            "Not a procedure"
                                                            before))))
                                                  (let ((begin-temp.596
                                                         (if ('#<procedure #74 ##procedure?>
                                                              after)
                                                             #!void
                                                             (report-meroon-error
                                                              'Domain
                                                              'generic-trace
                                                              "Not a procedure"
                                                              after))))
                                                    (let ((begin-temp.595
                                                           (if (let ((temp.1104
                                                                      *traced-generics*))
                                                                 (letrec ((loop.1105
                                                                           (lambda (generic
                                                                                    lst1.1106)
                                                                             (if ('#<procedure #4 ##pair?>
                                                                                  lst1.1106)
                                                                                 (let ((x.1107 ('#<procedure #6 ##car>
                                                                                                lst1.1106)))
                                                                                   (if ('#<procedure #3 ##eq?>
                                                                                        generic
                                                                                        ('#<procedure #6 ##car>
                                                                                         x.1107))
                                                                                       x.1107
                                                                                       (loop.1105
                                                                                        generic
                                                                                        ('#<procedure #7 ##cdr>
                                                                                         lst1.1106))))
                                                                                 #f))))
                                                                   (loop.1105
                                                                    generic
                                                                    temp.1104)))
                                                               #!void
                                                               (let ((default (Generic-default
                                                                               generic)))
                                                                 (let ((begin-temp.594
                                                                        (set! *traced-generics*
                                                                              ('#<procedure #10 ##cons>
                                                                               ('#<procedure #10 ##cons>
                                                                                generic
                                                                                default)
                                                                               *traced-generics*))))
                                                                   (let ((begin-temp.593
                                                                          (set-Generic-default!
                                                                           generic
                                                                           (lambda all-arguments
                                                                             (let ((begin-temp.592
                                                                                    ('#<procedure #8 apply>
                                                                                     before
                                                                                     all-arguments)))
                                                                               (after ('#<procedure #8 apply>
                                                                                       default
                                                                                       all-arguments)))))))
                                                                     (set-Generic-dispatcher!
                                                                      generic
                                                                      (make-Tracing-Dispatcher
                                                                       (build-Tracing-Dispatcher-find-method
                                                                        before
                                                                        after)
                                                                       (Generic-dispatcher
                                                                        generic)
                                                                       default))))))))
                                                      generic))))))))
                              (loop2.1120 ('#<procedure #7 ##cdr> lst2.1121)))
                            #!void)))
                    #!void))))
      (loop2.1120 names))))

(define show-generic-untrace
  (lambda names
    (let ((temp.1129
           (if ('#<procedure #4 ##pair?> names)
               names
               (let ((temp.1124 *traced-generics*))
                 (letrec ((loop2.1125
                           (lambda (lst2.1126)
                             (if ('#<procedure #4 ##pair?> lst2.1126)
                                 (let ((x.1127 ('#<procedure #9 car>
                                                ('#<procedure #6 ##car>
                                                 lst2.1126))))
                                   ('#<procedure #10 ##cons>
                                    x.1127
                                    (loop2.1125
                                     ('#<procedure #7 ##cdr> lst2.1126))))
                                 '()))))
                   (loop2.1125 temp.1124))))))
      (letrec ((loop2.1130
                (lambda (lst2.1131)
                  (if ('#<procedure #4 ##pair?> lst2.1131)
                      (let ((x.1132 (let ((o ('#<procedure #6 ##car>
                                              lst2.1131)))
                                      (generic-untrace (->Generic o)))))
                        (let ((lst2.1131 ('#<procedure #7 ##cdr> lst2.1131)))
                          (if ('#<procedure #4 ##pair?> lst2.1131)
                              (let ((x.1132 (let ((o ('#<procedure #6 ##car>
                                                      lst2.1131)))
                                              (generic-untrace
                                               (->Generic o)))))
                                (loop2.1130
                                 ('#<procedure #7 ##cdr> lst2.1131)))
                              #!void)))
                      #!void))))
        (loop2.1130 temp.1129)))))

(define show-meroon
  (lambda stream
    (let ((stream (if ('#<procedure #4 ##pair?> stream)
                      ('#<procedure #6 ##car> stream)
                      (current-output-port))))
      (let ((begin-temp.632 ('#<procedure #42 newline> stream)))
        (let ((begin-temp.631
               ('#<procedure #41 display> meroon-version stream)))
          (let ((begin-temp.630 ('#<procedure #42 newline> stream)))
            (let ((begin-temp.629
                   ('#<procedure #41 display>
                    "Total number of classes: "
                    stream)))
              (let ((begin-temp.628
                     ('#<procedure #41 display> *class-number* stream)))
                (let ((begin-temp.627 ('#<procedure #42 newline> stream)))
                  (let ((begin-temp.626
                         ('#<procedure #41 display>
                          "Total number of generic functions: "
                          stream)))
                    (let ((begin-temp.625
                           ('#<procedure #41 display>
                            *generic-number*
                            stream)))
                      (let ((begin-temp.624
                             ('#<procedure #42 newline> stream)))
                        (let ((begin-temp.623
                               (let ((sum ('#<procedure #61 ##box>
                                           (show-meroon-size Object-class))))
                                 (let ((begin-temp.622
                                        ('#<procedure #63 ##set-box!>
                                         sum
                                         ('#<procedure #21 ##fx+>
                                          ('#<procedure #62 ##unbox> sum)
                                          ('#<procedure #29 ##vector-length>
                                           *classes*)))))
                                   (let ((begin-temp.621
                                          (sequence-map
                                           (lambda (c)
                                             ('#<procedure #63 ##set-box!>
                                              sum
                                              ('#<procedure #21 ##fx+>
                                               ('#<procedure #62 ##unbox> sum)
                                               (show-meroon-size c))))
                                           *classes*)))
                                     (let ((begin-temp.620
                                            ('#<procedure #63 ##set-box!>
                                             sum
                                             ('#<procedure #21 ##fx+>
                                              ('#<procedure #62 ##unbox> sum)
                                              ('#<procedure #29 ##vector-length>
                                               *generics*)))))
                                       (let ((begin-temp.619
                                              (sequence-map
                                               (lambda (g)
                                                 ('#<procedure #63 ##set-box!>
                                                  sum
                                                  ('#<procedure #21 ##fx+>
                                                   ('#<procedure #62 ##unbox>
                                                    sum)
                                                   (show-meroon-size g))))
                                               *generics*)))
                                         (let ((begin-temp.618
                                                ('#<procedure #41 display>
                                                 "(estimated) internal size of Meroon: "
                                                 stream)))
                                           (let ((begin-temp.617
                                                  ('#<procedure #41 display>
                                                   ('#<procedure #62 ##unbox>
                                                    sum)
                                                   stream)))
                                             (let ((begin-temp.616
                                                    ('#<procedure #41 display>
                                                     " pointers"
                                                     stream)))
                                               ('#<procedure #42 newline>
                                                stream)))))))))))
                          #t)))))))))))))

(define show-meroon-size
  (let ((#:g906 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.633
           ('#<procedure #63 ##set-box!>
            #:g906
            (register-Generic-1
             '(1 . 1)
             'show-meroon-size
             (lambda (o)
               (if ('#<procedure #56 ##vector?> o)
                   ('#<procedure #29 ##vector-length> o)
                   (if ('#<procedure #4 ##pair?> o)
                       ('#<procedure #21 ##fx+>
                        (show-meroon-size ('#<procedure #6 ##car> o))
                        (show-meroon-size ('#<procedure #7 ##cdr> o)))
                       0)))
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g906) o)
         o)))))

(register-method
 'show-meroon-size
 '((o Object))
 '(1 . 1)
 (lambda (#:g908 #:g909 #:g910)
   (lambda (o)
     ('#<procedure #21 ##fx+>
      1
      ('#<procedure #39 ##fx-> ('#<procedure #29 ##vector-length> o) 1))))
 'Object)

(register-method
 'show-meroon-size
 '((o Class))
 '(1 . 1)
 (lambda (#:g912 #:g913 #:g914)
   (lambda (o)
     (let ((sum ('#<procedure #61 ##box>
                 (let ((#:g915 (Class-super-number #:g913)))
                   ((or (and #:g915
                             (find-method1
                              ('#<procedure #32 ##vector-ref> #:g912 4)
                              ('#<procedure #32 ##vector-ref>
                               *classes*
                               #:g915)))
                        (Generic-default #:g912))
                    o)))))
       (let ((begin-temp.634
              (let ((temp.1134 (Class-fields o)))
                (letrec ((loop2.1135
                          (lambda (sum lst2.1136)
                            (if ('#<procedure #4 ##pair?> lst2.1136)
                                (let ((x.1137 (let ((field ('#<procedure #6 ##car>
                                                            lst2.1136)))
                                                ('#<procedure #63 ##set-box!>
                                                 sum
                                                 ('#<procedure #21 ##fx+>
                                                  ('#<procedure #62 ##unbox>
                                                   sum)
                                                  (show-meroon-size field))))))
                                  (let ((lst2.1136
                                         ('#<procedure #7 ##cdr> lst2.1136)))
                                    (if ('#<procedure #4 ##pair?> lst2.1136)
                                        (let ((x.1137 (let ((field ('#<procedure #6 ##car>
                                                                    lst2.1136)))
                                                        ('#<procedure #63 ##set-box!>
                                                         sum
                                                         ('#<procedure #21 ##fx+>
                                                          ('#<procedure #62 ##unbox>
                                                           sum)
                                                          (show-meroon-size
                                                           field))))))
                                          (loop2.1135
                                           sum
                                           ('#<procedure #7 ##cdr> lst2.1136)))
                                        #!void)))
                                #!void))))
                  (loop2.1135 sum temp.1134)))))
         ('#<procedure #62 ##unbox> sum)))))
 'Class)

(register-method
 'show-meroon-size
 '((o Generic))
 '(1 . 1)
 (lambda (#:g916 #:g917 #:g918)
   (lambda (o)
     ('#<procedure #21 ##fx+>
      (let ((#:g919 (Class-super-number #:g917)))
        ((or (and #:g919
                  (find-method1
                   ('#<procedure #32 ##vector-ref> #:g916 4)
                   ('#<procedure #32 ##vector-ref> *classes* #:g919)))
             (Generic-default #:g916))
         o))
      (show-meroon-size (Generic-dispatcher o)))))
 'Generic)

(register-method
 'show-meroon-size
 '((o Subclass-Dispatcher))
 '(1 . 1)
 (lambda (#:g920 #:g921 #:g922)
   (lambda (o)
     ('#<procedure #21 ##fx+>
      (let ((#:g923 (Class-super-number #:g921)))
        ((or (and #:g923
                  (find-method1
                   ('#<procedure #32 ##vector-ref> #:g920 4)
                   ('#<procedure #32 ##vector-ref> *classes* #:g923)))
             (Generic-default #:g920))
         o))
      ('#<procedure #21 ##fx+>
       (show-meroon-size (Subclass-Dispatcher-yes o))
       (show-meroon-size (Subclass-Dispatcher-no o))))))
 'Subclass-Dispatcher)

(register-method
 'show-meroon-size
 '((o Indexed-Dispatcher))
 '(1 . 1)
 (lambda (#:g924 #:g925 #:g926)
   (lambda (o)
     ('#<procedure #21 ##fx+>
      (let ((#:g927 (Class-super-number #:g925)))
        ((or (and #:g927
                  (find-method1
                   ('#<procedure #32 ##vector-ref> #:g924 4)
                   ('#<procedure #32 ##vector-ref> *classes* #:g927)))
             (Generic-default #:g924))
         o))
      (show-meroon-size (Indexed-Dispatcher-no o)))))
 'Indexed-Dispatcher)

(register-method
 'show-meroon-size
 '((o Linear-Dispatcher))
 '(1 . 1)
 (lambda (#:g928 #:g929 #:g930)
   (lambda (o)
     ('#<procedure #21 ##fx+>
      (let ((#:g931 (Class-super-number #:g929)))
        ((or (and #:g931
                  (find-method1
                   ('#<procedure #32 ##vector-ref> #:g928 4)
                   ('#<procedure #32 ##vector-ref> *classes* #:g931)))
             (Generic-default #:g928))
         o))
      ('#<procedure #21 ##fx+>
       ('#<procedure #23 length> (Linear-Dispatcher-signature o))
       (show-meroon-size (Linear-Dispatcher-no o))))))
 'Linear-Dispatcher)

(register-method
 'show-meroon-size
 '((o Global-Dispatcher))
 '(1 . 1)
 (lambda (#:g932 #:g933 #:g934)
   (lambda (o)
     ('#<procedure #21 ##fx+>
      (let ((#:g935 (Class-super-number #:g933)))
        ((or (and #:g935
                  (find-method1
                   ('#<procedure #32 ##vector-ref> #:g932 4)
                   ('#<procedure #32 ##vector-ref> *classes* #:g935)))
             (Generic-default #:g932))
         o))
      ('#<procedure #29 ##vector-length> *classes*))))
 'Global-Dispatcher)

(define unveil
  (lambda (o . stream)
    (let ((stream (if ('#<procedure #4 ##pair?> stream)
                      ('#<procedure #6 ##car> stream)
                      (current-output-port))))
      (let ((begin-temp.639 (set! *meroon-already-unveiled-objects* '())))
        (let ((begin-temp.638 (set! *first-time* #t)))
          (let ((begin-temp.637 (show-unveiled o 0 stream)))
            (let ((begin-temp.636 ('#<procedure #42 newline> stream)))
              (let ((begin-temp.635
                     (set! *meroon-already-unveiled-objects* '())))
                #t))))))))

(define *unveil-maximal-indent* 10)

(define *unveil-step* 2)

(define *unveil-bigstep* 6)

(set! *unveil-maximal-indent* *unveil-maximal-indent*)

(set! *unveil-step* *unveil-step*)

(set! *unveil-bigstep* *unveil-bigstep*)

(define *first-time* #t)

(define goto-margin
  (lambda (indent stream)
    (let ((step *unveil-step*))
      (let ((bigstep *unveil-bigstep*))
        (let ((begin-temp.642
               (if *first-time*
                   (set! *first-time* #f)
                   ('#<procedure #42 newline> stream))))
          (letrec ((do-temp.640
                    (lambda (indent stream step bigstep i)
                      (if ('#<procedure #50 ##fx=> i indent)
                          #f
                          (let ((begin-temp.641
                                 ('#<procedure #72 write-char>
                                  (if ('#<procedure #50 ##fx=>
                                       ('#<procedure #39 ##fx-> bigstep 1)
                                       ('#<procedure #75 ##fxmodulo>
                                        i
                                        bigstep))
                                      #\+
                                      (if ('#<procedure #50 ##fx=>
                                           ('#<procedure #39 ##fx-> step 1)
                                           ('#<procedure #75 ##fxmodulo>
                                            i
                                            step))
                                          #\|
                                          #\space))
                                  stream)))
                            (do-temp.640
                             indent
                             stream
                             step
                             bigstep
                             ('#<procedure #21 ##fx+> 1 i)))))))
            (do-temp.640 indent stream step bigstep 0)))))))

(define *meroon-already-unveiled-objects* '())

(define already-unveiled?
  (lambda (o)
    (let ((already-unveiled
           (let ((temp.1139 *meroon-already-unveiled-objects*))
             (letrec ((loop.1140
                       (lambda (o lst1.1141)
                         (if ('#<procedure #4 ##pair?> lst1.1141)
                             (let ((x.1142 ('#<procedure #6 ##car> lst1.1141)))
                               (if ('#<procedure #3 ##eq?> o x.1142)
                                   lst1.1141
                                   (loop.1140
                                    o
                                    ('#<procedure #7 ##cdr> lst1.1141))))
                             #f))))
               (loop.1140 o temp.1139)))))
      (let ((index (if ('#<procedure #4 ##pair?> already-unveiled)
                       ('#<procedure #23 length> already-unveiled)
                       (set! *meroon-already-unveiled-objects*
                             ('#<procedure #10 ##cons>
                              o
                              *meroon-already-unveiled-objects*)))))
        (if already-unveiled index #f)))))

(define get-current-index
  (lambda () ('#<procedure #23 length> *meroon-already-unveiled-objects*)))

(define show-unveiled
  (lambda (o indent stream)
    (if ('#<procedure #28 ##meroon?> o)
        (show-object-unveiled o indent stream)
        (if ('#<procedure #56 ##vector?> o)
            (show-unveiled-vector-content o indent stream)
            (if ('#<procedure #4 ##pair?> o)
                (show-unveiled-list-content o indent stream)
                (show o stream))))))

(define show-object-unveiled
  (let ((#:g936 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.643
           ('#<procedure #63 ##set-box!>
            #:g936
            (register-Generic-1
             '(1 . 1)
             'show-object-unveiled
             meroon-uninitialized
             '((o) indent stream)
             #f))))
      (lambda (o indent stream)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g936) o)
         o
         indent
         stream)))))

(register-method
 'show-object-unveiled
 '((o Object) indent stream)
 '(1 . 1)
 (lambda (#:g938 #:g939 #:g940)
   (lambda (o indent stream)
     (let ((index (already-unveiled? o))
           (class ('#<procedure #32 ##vector-ref>
                   *classes*
                   ('#<procedure #32 ##vector-ref> o 0))))
       (if index
           (show-already-unveiled-object (Class-name class) index stream)
           (let ((begin-temp.650 (goto-margin indent stream)))
             (if ('#<procedure #53 ##fx>> indent *unveil-maximal-indent*)
                 ('#<procedure #41 display> "<details omitted...>" stream)
                 (let ((index ('#<procedure #23 length>
                               *meroon-already-unveiled-objects*)))
                   (let ((begin-temp.649
                          ('#<procedure #41 display> "(a " stream)))
                     (let ((begin-temp.648
                            ('#<procedure #41 display>
                             (Class-name class)
                             stream)))
                       (let ((begin-temp.647 (show-index index stream)))
                         (let ((begin-temp.646
                                (let ((temp.1144 (Class-fields class)))
                                  (letrec ((loop2.1145
                                            (lambda (o indent stream lst2.1146)
                                              (if ('#<procedure #4 ##pair?>
                                                   lst2.1146)
                                                  (let ((x.1147 (let ((field ('#<procedure #6 ##car>
                                                                              lst2.1146)))
                                                                  (show-unveiled-field-content
                                                                   o
                                                                   ('#<procedure #21 ##fx+>
                                                                    1
                                                                    indent)
                                                                   stream
                                                                   field))))
                                                    (let ((lst2.1146
                                                           ('#<procedure #7 ##cdr>
                                                            lst2.1146)))
                                                      (if ('#<procedure #4 ##pair?>
                                                           lst2.1146)
                                                          (let ((x.1147 (let ((field ('#<procedure #6 ##car>
                                                                                      lst2.1146)))
                                                                          (show-unveiled-field-content
                                                                           o
                                                                           ('#<procedure #21 ##fx+>
                                                                            1
                                                                            indent)
                                                                           stream
                                                                           field))))
                                                            (loop2.1145
                                                             o
                                                             indent
                                                             stream
                                                             ('#<procedure #7 ##cdr>
                                                              lst2.1146)))
                                                          #!void)))
                                                  #!void))))
                                    (loop2.1145 o indent stream temp.1144)))))
                           (let ((begin-temp.645
                                  ('#<procedure #41 display> " end " stream)))
                             (let ((begin-temp.644
                                    ('#<procedure #41 display>
                                     (Class-name class)
                                     stream)))
                               ('#<procedure #41 display>
                                ")"
                                stream))))))))))))))
 'Object)

(define show-index
  (lambda (index stream)
    (let ((begin-temp.652
           ('#<procedure #41 display> " <------------- [Id: " stream)))
      (let ((begin-temp.651 ('#<procedure #41 display> index stream)))
        ('#<procedure #41 display> "]" stream)))))

(define show-already-unveiled-object
  (lambda (class-name index stream)
    (let ((begin-temp.656 ('#<procedure #41 display> "<the " stream)))
      (let ((begin-temp.655 ('#<procedure #41 display> class-name stream)))
        (let ((begin-temp.654
               ('#<procedure #41 display> " referred above as " stream)))
          (let ((begin-temp.653 ('#<procedure #41 display> index stream)))
            ('#<procedure #41 display> ">" stream)))))))

(define show-unveiled-field-content
  (let ((#:g942 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.657
           ('#<procedure #63 ##set-box!>
            #:g942
            (register-Generic-1
             '(1 . 1)
             'show-unveiled-field-content
             meroon-uninitialized
             '(o indent stream (field))
             #f))))
      (lambda (o indent stream field)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g942) field)
         o
         indent
         stream
         field)))))

(register-method
 'show-unveiled-field-content
 '(o indent stream (field Mono-Field))
 '(1 . 1)
 (lambda (#:g944 #:g945 #:g946)
   (lambda (o indent stream field)
     (let ((begin-temp.660 (goto-margin indent stream)))
       (let ((begin-temp.659
              ('#<procedure #41 display> (Field-name field) stream)))
         (let ((begin-temp.658 ('#<procedure #41 display> ": " stream)))
           (if (field-defined? o field)
               (show-unveiled (field-value o field) indent stream)
               ('#<procedure #41 display> "#<Uninitialized>" stream)))))))
 'Mono-Field)

(register-method
 'show-unveiled-field-content
 '(o indent stream (field Poly-Field))
 '(1 . 1)
 (lambda (#:g948 #:g949 #:g950)
   (lambda (o indent stream field)
     (letrec ((loop (lambda (o indent stream field n i)
                      (if ('#<procedure #20 ##fx<> i n)
                          (let ((begin-temp.666 (goto-margin indent stream)))
                            (let ((begin-temp.665
                                   ('#<procedure #41 display>
                                    (Field-name field)
                                    stream)))
                              (let ((begin-temp.664
                                     ('#<procedure #41 display> "[" stream)))
                                (let ((begin-temp.663
                                       ('#<procedure #41 display> i stream)))
                                  (let ((begin-temp.662
                                         ('#<procedure #41 display>
                                          "]: "
                                          stream)))
                                    (let ((begin-temp.661
                                           (if (field-defined? o field i)
                                               (let ((o (field-value
                                                         o
                                                         field
                                                         i)))
                                                 (if ('#<procedure #28 ##meroon?>
                                                      o)
                                                     (show-object-unveiled
                                                      o
                                                      indent
                                                      stream)
                                                     (if ('#<procedure #56 ##vector?>
                                                          o)
                                                         (show-unveiled-vector-content
                                                          o
                                                          indent
                                                          stream)
                                                         (if ('#<procedure #4 ##pair?>
                                                              o)
                                                             (show-unveiled-list-content
                                                              o
                                                              indent
                                                              stream)
                                                             (show o
                                                                   stream)))))
                                               ('#<procedure #41 display>
                                                "#<Uninitialized>"
                                                stream))))
                                      (loop o
                                            indent
                                            stream
                                            field
                                            n
                                            ('#<procedure #21 ##fx+>
                                             1
                                             i))))))))
                          #!void))))
       (loop o indent stream field (field-length o field) 0))))
 'Poly-Field)

(define show-unveiled-vector-content
  (lambda (o indent stream)
    (let ((index (already-unveiled? o)))
      (if index
          (show-already-unveiled-object "Vector" index stream)
          (let ((index ('#<procedure #23 length>
                        *meroon-already-unveiled-objects*)))
            (let ((begin-temp.678 (goto-margin indent stream)))
              (let ((begin-temp.677
                     ('#<procedure #41 display> "(a Vector " stream)))
                (let ((begin-temp.676 (show-index index stream)))
                  (let ((begin-temp.675
                         (let ((indent ('#<procedure #21 ##fx+> 1 indent)))
                           (let ((begin-temp.672 (goto-margin indent stream)))
                             (letrec ((loop (lambda (o stream indent n i)
                                              (if ('#<procedure #20 ##fx<> i n)
                                                  (let ((begin-temp.671
                                                         ('#<procedure #41 display>
                                                          "Vector["
                                                          stream)))
                                                    (let ((begin-temp.670
                                                           ('#<procedure #41 display>
                                                            i
                                                            stream)))
                                                      (let ((begin-temp.669
                                                             ('#<procedure #41 display>
                                                              "]: "
                                                              stream)))
                                                        (let ((begin-temp.668
                                                               (show-unveiled
                                                                ('#<procedure #32 ##vector-ref>
                                                                 o
                                                                 i)
                                                                indent
                                                                stream)))
                                                          (let ((begin-temp.667
                                                                 (goto-margin
                                                                  indent
                                                                  stream)))
                                                            (loop o
                                                                  stream
                                                                  indent
                                                                  n
                                                                  ('#<procedure #21 ##fx+>
                                                                   1
                                                                   i)))))))
                                                  #!void))))
                               (loop o
                                     stream
                                     indent
                                     ('#<procedure #29 ##vector-length> o)
                                     0))))))
                    (let ((begin-temp.674
                           ('#<procedure #41 display> " end " stream)))
                      (let ((begin-temp.673
                             ('#<procedure #41 display> "Vector" stream)))
                        ('#<procedure #41 display> ")" stream))))))))))))

(define show-unveiled-list-content
  (lambda (o indent stream)
    (let ((index (already-unveiled? o)))
      (if index
          (show-already-unveiled-object "List" index stream)
          (let ((index ('#<procedure #23 length>
                        *meroon-already-unveiled-objects*)))
            (let ((begin-temp.694 (goto-margin indent stream)))
              (let ((begin-temp.693
                     ('#<procedure #41 display> "(a List " stream)))
                (let ((begin-temp.692 (show-index index stream)))
                  (let ((begin-temp.691
                         (let ((indent ('#<procedure #21 ##fx+> 1 indent)))
                           (let ((begin-temp.688 (goto-margin indent stream)))
                             (letrec ((loop (lambda (stream indent o i)
                                              (if ('#<procedure #4 ##pair?> o)
                                                  (let ((begin-temp.685
                                                         ('#<procedure #41 display>
                                                          "List["
                                                          stream)))
                                                    (let ((begin-temp.684
                                                           ('#<procedure #41 display>
                                                            i
                                                            stream)))
                                                      (let ((begin-temp.683
                                                             ('#<procedure #41 display>
                                                              "]: "
                                                              stream)))
                                                        (let ((begin-temp.682
                                                               (show-unveiled
                                                                ('#<procedure #6 ##car>
                                                                 o)
                                                                indent
                                                                stream)))
                                                          (let ((begin-temp.681
                                                                 (goto-margin
                                                                  indent
                                                                  stream)))
                                                            (if ('#<procedure #4 ##pair?>
                                                                 ('#<procedure #7 ##cdr>
                                                                  o))
                                                                (let ((index (already-unveiled?
                                                                              ('#<procedure #7 ##cdr>
                                                                               o))))
                                                                  (if index
                                                                      (let ((begin-temp.679
                                                                             ('#<procedure #41 display>
                                                                              " . "
                                                                              stream)))
                                                                        (show-already-unveiled-object
                                                                         "List"
                                                                         index
                                                                         stream))
                                                                      (loop stream
                                                                            indent
                                                                            ('#<procedure #7 ##cdr>
                                                                             o)
                                                                            ('#<procedure #21 ##fx+>
                                                                             1
                                                                             i))))
                                                                (if ('#<procedure #24 ##null?>
                                                                     ('#<procedure #7 ##cdr>
                                                                      o))
                                                                    #!void
                                                                    (let ((begin-temp.680
                                                                           ('#<procedure #41 display>
                                                                            " . "
                                                                            stream)))
                                                                      (show-unveiled
                                                                       ('#<procedure #7 ##cdr>
                                                                        o)
                                                                       indent
                                                                       stream)))))))))
                                                  (if ('#<procedure #24 ##null?>
                                                       o)
                                                      #!void
                                                      (let ((begin-temp.687
                                                             ('#<procedure #41 display>
                                                              " . "
                                                              stream)))
                                                        (let ((begin-temp.686
                                                               (show-unveiled
                                                                o
                                                                indent
                                                                stream)))
                                                          (goto-margin
                                                           indent
                                                           stream))))))))
                               (loop stream indent o 0))))))
                    (let ((begin-temp.690
                           ('#<procedure #41 display> " end " stream)))
                      (let ((begin-temp.689
                             ('#<procedure #41 display> "List" stream)))
                        ('#<procedure #41 display> ")" stream))))))))))))

(define *already-compared-objects* '())

(define substituable?
  (lambda (o1 o2)
    (let ((begin-temp.696 (set! *already-compared-objects* '())))
      (let ((result (compare4egal o1 o2)))
        (let ((begin-temp.695 (set! *already-compared-objects* '())))
          result)))))

(define compare4egal
  (lambda (o1 o2)
    (letrec ((look (lambda (o1 o2 cache)
                     (if ('#<procedure #4 ##pair?> cache)
                         (let ((entry ('#<procedure #6 ##car> cache)))
                           (if (or (and ('#<procedure #3 ##eq?>
                                         ('#<procedure #6 ##car> entry)
                                         o1)
                                        ('#<procedure #3 ##eq?>
                                         ('#<procedure #67 ##cadr> entry)
                                         o2))
                                   (and ('#<procedure #3 ##eq?>
                                         ('#<procedure #6 ##car> entry)
                                         o2)
                                        ('#<procedure #3 ##eq?>
                                         ('#<procedure #67 ##cadr> entry)
                                         o1)))
                               entry
                               (look o1 o2 ('#<procedure #7 ##cdr> cache))))
                         #f))))
      (or ('#<procedure #3 ##eq?> o1 o2)
          (and ('#<procedure #28 ##meroon?> o1)
               (and ('#<procedure #28 ##meroon?> o2)
                    (and ('#<procedure #50 ##fx=>
                          ('#<procedure #32 ##vector-ref> o1 0)
                          ('#<procedure #32 ##vector-ref> o2 0))
                         (and (Class-immutable?
                               ('#<procedure #32 ##vector-ref>
                                *classes*
                                ('#<procedure #32 ##vector-ref> o1 0)))
                              (let ((entry (look o1
                                                 o2
                                                 *already-compared-objects*)))
                                (if ('#<procedure #4 ##pair?> entry)
                                    ('#<procedure #70 ##cddr> entry)
                                    (let ((c ('#<procedure #32 ##vector-ref>
                                              *classes*
                                              ('#<procedure #32 ##vector-ref>
                                               o1
                                               0)))
                                          (entry ('#<procedure #10 ##cons>
                                                  o1
                                                  ('#<procedure #10 ##cons>
                                                   o2
                                                   #t))))
                                      (let ((begin-temp.698
                                             (set! *already-compared-objects*
                                                   ('#<procedure #10 ##cons>
                                                    entry
                                                    *already-compared-objects*))))
                                        (let ((result (every? (lambda (field)
                                                                (Field-compare
                                                                 field
                                                                 o1
                                                                 o2))
                                                              (Class-fields
                                                               c))))
                                          (let ((begin-temp.697
                                                 ('#<procedure #12 ##set-cdr!>
                                                  ('#<procedure #7 ##cdr>
                                                   entry)
                                                  result)))
                                            result))))))))))))))

(define Field-compare
  (let ((#:g952 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.699
           ('#<procedure #63 ##set-box!>
            #:g952
            (register-Generic-1
             '(1 . 1)
             'Field-compare
             meroon-uninitialized
             '((field Field) o1 o2)
             'Field))))
      (lambda (field o1 o2)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g952) field)
         field
         o1
         o2)))))

(register-method
 'Field-compare
 '((field Mono-Field) o1 o2)
 '(1 . 1)
 (lambda (#:g954 #:g955 #:g956)
   (lambda (field o1 o2)
     (compare4egal (field-value o1 field) (field-value o2 field))))
 'Mono-Field)

(register-method
 'Field-compare
 '((field Poly-Field) o1 o2)
 '(1 . 1)
 (lambda (#:g958 #:g959 #:g960)
   (lambda (field o1 o2)
     (let ((len2 (field-length o1 field)) (len1 (field-length o1 field)))
       (and ('#<procedure #50 ##fx=> len1 len2)
            (letrec ((iter (lambda (field o1 o2 len1 i)
                             (or ('#<procedure #36 ##fx>=> i len1)
                                 (and (compare4egal
                                       (field-value o1 field i)
                                       (field-value o2 field i))
                                      (iter field
                                            o1
                                            o2
                                            len1
                                            ('#<procedure #21 ##fx+> i 1)))))))
              (iter field o1 o2 len1 0))))))
 'Poly-Field)

(define process-modify-form
  (lambda (desc parms)
    (let ((begin-temp.700
           (if (and ('#<procedure #4 ##pair?> desc)
                    (and ('#<procedure #4 ##pair?>
                          ('#<procedure #7 ##cdr> desc))
                         ('#<procedure #24 ##null?>
                          ('#<procedure #70 ##cddr> desc))))
               #!void
               (report-meroon-error
                'Syntax
                'modify
                "Incorrect specification"
                desc))))
      (process-modification
       ('#<procedure #6 ##car> desc)
       (symbol->class
        ('#<procedure #67 ##cadr> desc)
        (lambda (name)
          (report-meroon-error 'Syntax 'modify "No such class" name)))
       parms))))

(define process-modification
  (lambda (ins-tance class parms)
    (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
      (let ((o (gensym)))
        (let ((index (gensym)))
          ('#<procedure #43 ##quasi-cons>
           'let
           ('#<procedure #43 ##quasi-cons>
            ('#<procedure #44 ##quasi-list>
             ('#<procedure #44 ##quasi-list> o ins-tance)
             ('#<procedure #43 ##quasi-cons> index '(0)))
            ('#<procedure #43 ##quasi-cons>
             ('#<procedure #43 ##quasi-cons>
              'check-class
              ('#<procedure #43 ##quasi-cons>
               o
               ('#<procedure #43 ##quasi-cons>
                ('#<procedure #44 ##quasi-list>
                 'symbol->class
                 ('#<procedure #44 ##quasi-list>
                  'quote
                  ('#<procedure #32 ##vector-ref> class 1)))
                '('modify))))
             ('#<procedure #45 ##quasi-append>
              (let ((contents
                     (let ((contents
                            (process-initialization
                             fields
                             parms
                             find-modification)))
                       ('#<procedure #69 map>
                        (lambda (field content)
                          (if ('#<procedure #4 ##pair?> content)
                              (check-modification field content)
                              (arrange-modification field content)))
                        fields
                        contents))))
                (meroon-reduce
                 (lambda (forms field content)
                   (generate-modification field content o index forms))
                 '()
                 fields
                 contents))
              ('#<procedure #44 ##quasi-list> o))))))))))

(define find-modification
  (let ((#:g962 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.701
           ('#<procedure #63 ##set-box!>
            #:g962
            (register-Generic-1
             '(1 . 1)
             'find-modification
             meroon-uninitialized
             '((field Field) parms k)
             'Field))))
      (lambda (field parms k)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g962) field)
         field
         parms
         k)))))

(register-method
 'find-modification
 '((f Mono-Field) parms k)
 '(1 . 1)
 (lambda (#:g964 #:g965 #:g966)
   (lambda (f parms k)
     (let ((form (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                   (let ((kw+values (find-option-plus-values keyword parms)))
                     (if ('#<procedure #4 ##pair?> kw+values)
                         (let ((values ('#<procedure #7 ##cdr> kw+values)))
                           (if (and ('#<procedure #4 ##pair?> values)
                                    ('#<procedure #24 ##null?>
                                     ('#<procedure #7 ##cdr> values)))
                               ('#<procedure #6 ##car> values)
                               (report-meroon-error
                                'Syntax
                                'find-option
                                "This option expects a single value"
                                keyword
                                values)))
                         meroon-option-not-there)))))
       (let ((other-parms
              (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                (letrec ((skip (lambda (keyword options)
                                 (if ('#<procedure #4 ##pair?> options)
                                     (if (and (let ((e ('#<procedure #6 ##car>
                                                        options)))
                                                (or ('#<procedure #59 ##keyword?>
                                                     e)
                                                    (and ('#<procedure #16 ##symbol?>
                                                          e)
                                                         ('#<procedure #60 ##char=?>
                                                          ('#<procedure #37 ##string-ref>
                                                           ('#<procedure #17 symbol->string>
                                                            e)
                                                           0)
                                                          #\:))))
                                              (meroon-keyword-eq?
                                               ('#<procedure #6 ##car> options)
                                               keyword))
                                         (skip2next-keyword
                                          ('#<procedure #7 ##cdr> options))
                                         ('#<procedure #10 ##cons>
                                          ('#<procedure #6 ##car> options)
                                          (skip keyword
                                                ('#<procedure #7 ##cdr>
                                                 options))))
                                     '()))))
                  (skip keyword parms)))))
         (if ('#<procedure #3 ##eq?> form meroon-option-not-there)
             (k ('#<procedure #34 ##list>) other-parms)
             (k ('#<procedure #34 ##list> 1 form) other-parms))))))
 'Mono-Field)

(register-method
 'find-modification
 '((f Poly-Field) parms k)
 '(1 . 1)
 (lambda (#:g968 #:g969 #:g970)
   (lambda (f parms k)
     (let ((content (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                      (let ((kw+values
                             (find-option-plus-values keyword parms)))
                        (if ('#<procedure #4 ##pair?> kw+values)
                            ('#<procedure #7 ##cdr> kw+values)
                            meroon-option-not-there)))))
       (let ((parms (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                      (letrec ((skip (lambda (keyword options)
                                       (if ('#<procedure #4 ##pair?> options)
                                           (if (and (let ((e ('#<procedure #6 ##car>
                                                              options)))
                                                      (or ('#<procedure #59 ##keyword?>
                                                           e)
                                                          (and ('#<procedure #16 ##symbol?>
                                                                e)
                                                               ('#<procedure #60 ##char=?>
                                                                ('#<procedure #37 ##string-ref>
                                                                 ('#<procedure #17 symbol->string>
                                                                  e)
                                                                 0)
                                                                #\:))))
                                                    (meroon-keyword-eq?
                                                     ('#<procedure #6 ##car>
                                                      options)
                                                     keyword))
                                               (skip2next-keyword
                                                ('#<procedure #7 ##cdr>
                                                 options))
                                               ('#<procedure #10 ##cons>
                                                ('#<procedure #6 ##car>
                                                 options)
                                                (skip keyword
                                                      ('#<procedure #7 ##cdr>
                                                       options))))
                                           '()))))
                        (skip keyword parms)))))
         (if ('#<procedure #3 ##eq?> content meroon-option-not-there)
             (let ((kw ('#<procedure #34 ##list>
                        ('#<procedure #32 ##vector-ref> f 1)
                        '-length)))
               (let ((size (find-option-single-value
                            kw
                            parms
                            option-not-there)))
                 (if ('#<procedure #3 ##eq?> size meroon-option-not-there)
                     (k ('#<procedure #34 ##list>) parms)
                     (report-meroon-error
                      'Syntax
                      'modify
                      "No :kw-length keyword possible in a modify form"
                      ('#<procedure #32 ##vector-ref> f 1)))))
             (k ('#<procedure #10 ##cons>
                 ('#<procedure #23 length> content)
                 content)
                parms))))))
 'Poly-Field)

(define arrange-whole-modification
  (lambda (fields contents)
    ('#<procedure #69 map>
     (lambda (field content)
       (if ('#<procedure #4 ##pair?> content)
           (check-modification field content)
           (arrange-modification field content)))
     fields
     contents)))

(define arrange-modification
  (let ((#:g972 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.702
           ('#<procedure #63 ##set-box!>
            #:g972
            (register-Generic-1
             '(1 . 1)
             'arrange-modification
             meroon-uninitialized
             '((field Field) content)
             'Field))))
      (lambda (field content)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g972) field)
         field
         content)))))

(register-method
 'arrange-modification
 '((field Mono-Field) content)
 '(1 . 1)
 (lambda (#:g974 #:g975 #:g976)
   (lambda (field content) ('#<procedure #34 ##list> 1 'meroon-uninitialized)))
 'Mono-Field)

(register-method
 'arrange-modification
 '((field Poly-Field) content)
 '(1 . 1)
 (lambda (#:g978 #:g979 #:g980)
   (lambda (field content) ('#<procedure #34 ##list>)))
 'Poly-Field)

(define check-modification
  (let ((#:g982 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.703
           ('#<procedure #63 ##set-box!>
            #:g982
            (register-Generic-1
             '(1 . 1)
             'check-modification
             meroon-uninitialized
             '((field Field) content)
             'Field))))
      (lambda (field content)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g982) field)
         field
         content)))))

(register-method
 'check-modification
 '((field Mono-Field) content)
 '(1 . 1)
 (lambda (#:g984 #:g985 #:g986)
   (lambda (field content)
     (if ('#<procedure #5 ##not> (Field-immutable? field))
         content
         (report-meroon-error
          'Syntax
          'modify
          "Immutable field"
          ('#<procedure #32 ##vector-ref> field 1)))))
 'Mono-Field)

(register-method
 'check-modification
 '((field Poly-Field) content)
 '(1 . 1)
 (lambda (#:g988 #:g989 #:g990)
   (lambda (field content)
     (if ('#<procedure #5 ##not> (Field-immutable? field))
         content
         (report-meroon-error
          'Syntax
          'modify
          "Immutable field"
          ('#<procedure #32 ##vector-ref> field 1)))))
 'Poly-Field)

(define generate-whole-modification
  (lambda (o index fields contents)
    (meroon-reduce
     (lambda (forms field content)
       (generate-modification field content o index forms))
     '()
     fields
     contents)))

(define generate-modification
  (let ((#:g992 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.704
           ('#<procedure #63 ##set-box!>
            #:g992
            (register-Generic-1
             '(1 . 1)
             'generate-modification
             meroon-uninitialized
             '((field Field) content o index forms)
             'Field))))
      (lambda (field content o index forms)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g992) field)
         field
         content
         o
         index
         forms)))))

(register-method
 'generate-modification
 '((field Mono-Field) content o index forms)
 '(1 . 1)
 (lambda (#:g994 #:g995 #:g996)
   (lambda (field content o index forms)
     (if ('#<procedure #3 ##eq?>
          'meroon-uninitialized
          ('#<procedure #67 ##cadr> content))
         (adjust-index
          ('#<procedure #44 ##quasi-list>
           'set!
           index
           ('#<procedure #44 ##quasi-list> 'fx+ 1 index))
          forms)
         ('#<procedure #10 ##cons>
          ('#<procedure #44 ##quasi-list>
           'instance-set!
           o
           index
           ('#<procedure #67 ##cadr> content))
          (adjust-index
           ('#<procedure #44 ##quasi-list>
            'set!
            index
            ('#<procedure #44 ##quasi-list> 'fx+ 1 index))
           forms)))))
 'Mono-Field)

(register-method
 'generate-modification
 '((field Poly-Field) content o index forms)
 '(1 . 1)
 (lambda (#:g998 #:g999 #:g1000)
   (lambda (field content o index forms)
     (if (and ('#<procedure #4 ##pair?> content)
              ('#<procedure #58 ##fixnum?> ('#<procedure #6 ##car> content)))
         ('#<procedure #10 ##cons>
          ('#<procedure #44 ##quasi-list>
           'check-same-size
           ('#<procedure #6 ##car> content)
           o
           index)
          (let ((forms (letrec ((enum (lambda (o index forms contents)
                                        (if ('#<procedure #4 ##pair?> contents)
                                            ('#<procedure #10 ##cons>
                                             ('#<procedure #44 ##quasi-list>
                                              'instance-set!
                                              o
                                              index
                                              ('#<procedure #6 ##car>
                                               contents))
                                             (adjust-index
                                              ('#<procedure #44 ##quasi-list>
                                               'set!
                                               index
                                               ('#<procedure #44 ##quasi-list>
                                                'fx+
                                                1
                                                index))
                                              (let ((contents
                                                     ('#<procedure #7 ##cdr>
                                                      contents)))
                                                (if ('#<procedure #4 ##pair?>
                                                     contents)
                                                    ('#<procedure #10 ##cons>
                                                     ('#<procedure #44 ##quasi-list>
                                                      'instance-set!
                                                      o
                                                      index
                                                      ('#<procedure #6 ##car>
                                                       contents))
                                                     (adjust-index
                                                      ('#<procedure #44 ##quasi-list>
                                                       'set!
                                                       index
                                                       ('#<procedure #44 ##quasi-list>
                                                        'fx+
                                                        1
                                                        index))
                                                      (let ((contents
                                                             ('#<procedure #7 ##cdr>
                                                              contents)))
                                                        (if ('#<procedure #4 ##pair?>
                                                             contents)
                                                            ('#<procedure #10 ##cons>
                                                             ('#<procedure #44 ##quasi-list>
                                                              'instance-set!
                                                              o
                                                              index
                                                              ('#<procedure #6 ##car>
                                                               contents))
                                                             (adjust-index
                                                              ('#<procedure #44 ##quasi-list>
                                                               'set!
                                                               index
                                                               ('#<procedure #44 ##quasi-list>
                                                                'fx+
                                                                1
                                                                index))
                                                              (enum o
                                                                    index
                                                                    forms
                                                                    ('#<procedure #7 ##cdr>
                                                                     contents))))
                                                            forms))))
                                                    forms))))
                                            forms))))
                         (enum o
                               index
                               forms
                               ('#<procedure #7 ##cdr> content))))
                (expression
                 ('#<procedure #44 ##quasi-list>
                  'set!
                  index
                  ('#<procedure #44 ##quasi-list> 'fx+ 1 index))))
            (if ('#<procedure #24 ##null?> forms)
                forms
                (if (and ('#<procedure #4 ##pair?>
                          ('#<procedure #6 ##car> forms))
                         (and ('#<procedure #3 ##eq?>
                               ('#<procedure #6 ##car>
                                ('#<procedure #6 ##car> forms))
                               'set!)
                              (and ('#<procedure #3 ##eq?>
                                    ('#<procedure #6 ##car>
                                     ('#<procedure #66 ##caddr>
                                      ('#<procedure #6 ##car> forms)))
                                    '+)
                                   (and ('#<procedure #50 ##fx=>
                                         ('#<procedure #23 length>
                                          ('#<procedure #66 ##caddr>
                                           ('#<procedure #6 ##car> forms)))
                                         3)
                                        ('#<procedure #50 ##fx=>
                                         ('#<procedure #23 length>
                                          ('#<procedure #66 ##caddr>
                                           expression))
                                         3)))))
                    (let ((n2 ('#<procedure #67 ##cadr>
                               ('#<procedure #66 ##caddr> expression)))
                          (n1 ('#<procedure #67 ##cadr>
                               ('#<procedure #66 ##caddr>
                                ('#<procedure #6 ##car> forms)))))
                      ('#<procedure #10 ##cons>
                       ('#<procedure #44 ##quasi-list>
                        'set!
                        ('#<procedure #67 ##cadr> expression)
                        ('#<procedure #44 ##quasi-list>
                         'fx+
                         ('#<procedure #21 ##fx+> n1 n2)
                         ('#<procedure #66 ##caddr>
                          ('#<procedure #66 ##caddr>
                           ('#<procedure #6 ##car> forms)))))
                       ('#<procedure #7 ##cdr> forms)))
                    ('#<procedure #10 ##cons> expression forms)))))
         (adjust-index
          ('#<procedure #44 ##quasi-list>
           'set!
           index
           ('#<procedure #44 ##quasi-list>
            'fx+
            1
            ('#<procedure #44 ##quasi-list>
             'fx+
             ('#<procedure #44 ##quasi-list> 'instance-ref o index)
             index)))
          forms))))
 'Poly-Field)

(define check-same-size
  (lambda (size o offset)
    (if ('#<procedure #5 ##not>
         ('#<procedure #50 ##fx=>
          size
          (let ((i ('#<procedure #21 ##fx+> 1 offset)))
            ('#<procedure #32 ##vector-ref> o i))))
        (report-meroon-error 'Domain 'modify "Lengths may not be modified" o)
        #!void)))

(define process-duplicate-form
  (lambda (desc parms)
    (let ((begin-temp.705
           (if (and ('#<procedure #4 ##pair?> desc)
                    (and ('#<procedure #4 ##pair?>
                          ('#<procedure #7 ##cdr> desc))
                         ('#<procedure #24 ##null?>
                          ('#<procedure #70 ##cddr> desc))))
               #!void
               (report-meroon-error
                'Syntax
                'duplicate
                "Incorrect specification"
                desc))))
      (process-duplication
       ('#<procedure #6 ##car> desc)
       (symbol->class
        ('#<procedure #67 ##cadr> desc)
        (lambda (name)
          (report-meroon-error 'Syntax 'duplicate "No such class" name)))
       parms))))

(define process-instantiation-from-form
  (lambda (desc parms)
    (let ((begin-temp.706
           (if (and ('#<procedure #4 ##pair?> desc)
                    (and ('#<procedure #4 ##pair?>
                          ('#<procedure #7 ##cdr> desc))
                         ('#<procedure #24 ##null?>
                          ('#<procedure #70 ##cddr> desc))))
               #!void
               (report-meroon-error
                'Syntax
                'instantiate-from
                "Incorrect specification"
                desc))))
      (process-instantiation-from
       ('#<procedure #6 ##car> desc)
       (symbol->class
        ('#<procedure #67 ##cadr> desc)
        (lambda (name)
          (report-meroon-error
           'Syntax
           'instantiate-from
           "No such class"
           name)))
       parms))))

(define process-duplication
  (lambda (ins-tance class parms)
    (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
      (let ((class-name
             (symbol-concatenate
              ('#<procedure #32 ##vector-ref> class 1)
              '-class)))
        (let ((g (gensym)))
          (let ((org (gensym)))
            (let ((index (gensym)))
              (let ((contents
                     (let ((contents
                            (process-initialization
                             fields
                             parms
                             find-duplication)))
                       ('#<procedure #69 map>
                        (lambda (field content)
                          (if ('#<procedure #4 ##pair?> content)
                              content
                              (arrange-initialization org field content)))
                        fields
                        contents))))
                ('#<procedure #44 ##quasi-list>
                 'let
                 ('#<procedure #44 ##quasi-list>
                  ('#<procedure #43 ##quasi-cons> index '(0))
                  ('#<procedure #44 ##quasi-list> org ins-tance))
                 ('#<procedure #44 ##quasi-list>
                  'if
                  ('#<procedure #44 ##quasi-list>
                   'is-a?
                   org
                   (find-highest-class-name class parms))
                  ('#<procedure #43 ##quasi-cons>
                   'let
                   ('#<procedure #43 ##quasi-cons>
                    ('#<procedure #44 ##quasi-list>
                     ('#<procedure #44 ##quasi-list>
                      g
                      ('#<procedure #43 ##quasi-cons>
                       ('#<procedure #44 ##quasi-list>
                        'careless-Class-allocator
                        class-name)
                       (meroon-reduce
                        (lambda (forms field content)
                          (generate-size field content forms))
                        '()
                        fields
                        contents))))
                    ('#<procedure #45 ##quasi-append>
                     (meroon-reduce
                      (lambda (forms field content)
                        (generate-initialization field content g index forms))
                      '()
                      fields
                      contents)
                     ('#<procedure #44 ##quasi-list>
                      ('#<procedure #44 ##quasi-list>
                       'initialize!
                       ('#<procedure #44 ##quasi-list>
                        'fill-other-fields-from-instance!
                        g
                        org))))))
                  ('#<procedure #44 ##quasi-list>
                   'report-meroon-error
                   ''Syntax
                   ''duplicate
                   "Missing fields from original"
                   org
                   class-name)))))))))))

(define process-instantiation-from
  (lambda (ins-tance class parms)
    (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
      (let ((class-name
             (symbol-concatenate
              ('#<procedure #32 ##vector-ref> class 1)
              '-class)))
        (let ((g (gensym)))
          (let ((org (gensym)))
            (let ((index (gensym)))
              (let ((lnew (gensym)))
                (let ((llnew (gensym)))
                  (let ((lorg (gensym)))
                    (let ((llorg (gensym)))
                      (let ((contents
                             (let ((contents
                                    (process-initialization
                                     fields
                                     parms
                                     find-instantiation-from)))
                               ('#<procedure #69 map>
                                (lambda (field content)
                                  (if ('#<procedure #4 ##pair?> content)
                                      content
                                      (arrange-initialization
                                       org
                                       field
                                       content)))
                                fields
                                contents))))
                        ('#<procedure #44 ##quasi-list>
                         'let
                         ('#<procedure #44 ##quasi-list>
                          ('#<procedure #43 ##quasi-cons> index '(0))
                          ('#<procedure #44 ##quasi-list> org ins-tance))
                         ('#<procedure #44 ##quasi-list>
                          'if
                          ('#<procedure #44 ##quasi-list>
                           'is-a?
                           org
                           class-name)
                          ('#<procedure #43 ##quasi-cons>
                           'let
                           ('#<procedure #43 ##quasi-cons>
                            ('#<procedure #44 ##quasi-list>
                             ('#<procedure #44 ##quasi-list>
                              g
                              ('#<procedure #44 ##quasi-list>
                               'apply
                               ('#<procedure #44 ##quasi-list>
                                'careless-Class-allocator
                                ('#<procedure #44 ##quasi-list>
                                 'object->class
                                 org))
                               ('#<procedure #44 ##quasi-list>
                                'let*
                                ('#<procedure #44 ##quasi-list>
                                 ('#<procedure #44 ##quasi-list>
                                  lnew
                                  ('#<procedure #43 ##quasi-cons>
                                   'list
                                   (meroon-reduce
                                    (lambda (forms field content)
                                      (generate-size field content forms))
                                    '()
                                    fields
                                    contents)))
                                 ('#<procedure #44 ##quasi-list>
                                  llnew
                                  ('#<procedure #44 ##quasi-list>
                                   'length
                                   lnew))
                                 ('#<procedure #44 ##quasi-list>
                                  lorg
                                  ('#<procedure #44 ##quasi-list>
                                   'find-repeated-fields-lengths
                                   org))
                                 ('#<procedure #44 ##quasi-list>
                                  llorg
                                  ('#<procedure #44 ##quasi-list>
                                   'length
                                   lorg)))
                                ('#<procedure #44 ##quasi-list>
                                 'if
                                 ('#<procedure #44 ##quasi-list>
                                  'fx<
                                  llnew
                                  llorg)
                                 ('#<procedure #44 ##quasi-list>
                                  'append
                                  lnew
                                  ('#<procedure #44 ##quasi-list>
                                   'list-tail
                                   lorg
                                   llnew))
                                 lnew)))))
                            ('#<procedure #43 ##quasi-cons>
                             ('#<procedure #44 ##quasi-list>
                              'fill-other-fields-from-instance!
                              g
                              org)
                             ('#<procedure #45 ##quasi-append>
                              (meroon-reduce
                               (lambda (forms field content)
                                 (generate-initialization
                                  field
                                  content
                                  g
                                  index
                                  forms))
                               '()
                               fields
                               contents)
                              ('#<procedure #44 ##quasi-list>
                               ('#<procedure #44 ##quasi-list>
                                'initialize!
                                g))))))
                          ('#<procedure #44 ##quasi-list>
                           'report-meroon-error
                           ''Syntax
                           ''instantiate-from
                           "Wrong class for original"
                           org
                           class-name)))))))))))))))

(define find-repeated-fields-lengths
  (lambda (o)
    (let ((class ('#<procedure #32 ##vector-ref>
                  *classes*
                  ('#<procedure #32 ##vector-ref> o 0))))
      (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
        (meroon-reduce
         (lambda (sizes field)
           (if (Poly-Field? field)
               ('#<procedure #10 ##cons> (field-length o field) sizes)
               sizes))
         '()
         fields)))))

(define find-highest-class-name
  (lambda (class parms)
    (letrec ((scan (lambda (parms fields)
                     (if ('#<procedure #4 ##pair?> fields)
                         (let ((field ('#<procedure #6 ##car> fields)))
                           (if (find-if-initialized field parms)
                               (scan parms ('#<procedure #7 ##cdr> fields))
                               (symbol-concatenate
                                (let ((class (let ((i ('#<procedure #32 ##vector-ref>
                                                       field
                                                       3)))
                                               ('#<procedure #32 ##vector-ref>
                                                *classes*
                                                i))))
                                  ('#<procedure #32 ##vector-ref> class 1))
                                '-class)))
                         'Object-class))))
      (scan parms ('#<procedure #76 reverse> (Class-fields class))))))

(define find-if-initialized
  (let ((#:g1002 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.707
           ('#<procedure #63 ##set-box!>
            #:g1002
            (register-Generic-1
             '(1 . 1)
             'find-if-initialized
             (lambda (f parms) #f)
             '((f Field) parms)
             'Field))))
      (lambda (f parms)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1002) f)
         f
         parms)))))

(register-method
 'find-if-initialized
 '((f Mono-Field) parms)
 '(1 . 1)
 (lambda (#:g1004 #:g1005 #:g1006)
   (lambda (f parms)
     (let ((form (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                   (let ((kw+values (find-option-plus-values keyword parms)))
                     (if ('#<procedure #4 ##pair?> kw+values)
                         (let ((values ('#<procedure #7 ##cdr> kw+values)))
                           (if (and ('#<procedure #4 ##pair?> values)
                                    ('#<procedure #24 ##null?>
                                     ('#<procedure #7 ##cdr> values)))
                               ('#<procedure #6 ##car> values)
                               (report-meroon-error
                                'Syntax
                                'find-option
                                "This option expects a single value"
                                keyword
                                values)))
                         meroon-option-not-there)))))
       ('#<procedure #5 ##not>
        (and ('#<procedure #3 ##eq?> form meroon-option-not-there)
             (and ('#<procedure #32 ##vector-ref> f 4)
                  ('#<procedure #5 ##not>
                   (field-defined? f 'initializer))))))))
 'Mono-Field)

(register-method
 'find-if-initialized
 '((f Poly-Field) parms)
 '(1 . 1)
 (lambda (#:g1008 #:g1009 #:g1010)
   (lambda (f parms)
     (let ((form (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                   (let ((kw+values (find-option-plus-values keyword parms)))
                     (if ('#<procedure #4 ##pair?> kw+values)
                         ('#<procedure #7 ##cdr> kw+values)
                         meroon-option-not-there)))))
       ('#<procedure #5 ##not>
        (and ('#<procedure #3 ##eq?> form meroon-option-not-there)
             (and ('#<procedure #32 ##vector-ref> f 4)
                  ('#<procedure #5 ##not>
                   (field-defined? f 'initializer))))))))
 'Poly-Field)

(define arrange-whole-initialization
  (lambda (org fields contents)
    ('#<procedure #69 map>
     (lambda (field content)
       (if ('#<procedure #4 ##pair?> content)
           content
           (arrange-initialization org field content)))
     fields
     contents)))

(define arrange-initialization
  (let ((#:g1012 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.708
           ('#<procedure #63 ##set-box!>
            #:g1012
            (register-Generic-1
             '(1 . 1)
             'arrange-initialization
             meroon-uninitialized
             '(org (field Field) content)
             'Field))))
      (lambda (org field content)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1012) field)
         org
         field
         content)))))

(register-method
 'arrange-initialization
 '(org (field Mono-Field) content)
 '(1 . 1)
 (lambda (#:g1014 #:g1015 #:g1016)
   (lambda (org field content)
     ('#<procedure #34 ##list> 1 'meroon-uninitialized)))
 'Mono-Field)

(register-method
 'arrange-initialization
 '(org (field Poly-Field) content)
 '(1 . 1)
 (lambda (#:g1018 #:g1019 #:g1020)
   (lambda (org field content)
     (let ((fname (Field-name field)))
       ('#<procedure #34 ##list>
        ('#<procedure #44 ##quasi-list>
         'field-length
         org
         ('#<procedure #44 ##quasi-list> 'quote fname))))))
 'Poly-Field)

(define find-duplication
  (let ((#:g1022 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.709
           ('#<procedure #63 ##set-box!>
            #:g1022
            (register-Generic-1
             '(1 . 1)
             'find-duplication
             meroon-uninitialized
             '((f Field) parms k)
             'Field))))
      (lambda (f parms k)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1022) f)
         f
         parms
         k)))))

(register-method
 'find-duplication
 '((f Mono-Field) parms k)
 '(1 . 1)
 (lambda (#:g1024 #:g1025 #:g1026)
   (lambda (f parms k)
     (let ((form (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                   (let ((kw+values (find-option-plus-values keyword parms)))
                     (if ('#<procedure #4 ##pair?> kw+values)
                         (let ((values ('#<procedure #7 ##cdr> kw+values)))
                           (if (and ('#<procedure #4 ##pair?> values)
                                    ('#<procedure #24 ##null?>
                                     ('#<procedure #7 ##cdr> values)))
                               ('#<procedure #6 ##car> values)
                               (report-meroon-error
                                'Syntax
                                'find-option
                                "This option expects a single value"
                                keyword
                                values)))
                         meroon-option-not-there)))))
       (let ((other-parms
              (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                (letrec ((skip (lambda (keyword options)
                                 (if ('#<procedure #4 ##pair?> options)
                                     (if (and (let ((e ('#<procedure #6 ##car>
                                                        options)))
                                                (or ('#<procedure #59 ##keyword?>
                                                     e)
                                                    (and ('#<procedure #16 ##symbol?>
                                                          e)
                                                         ('#<procedure #60 ##char=?>
                                                          ('#<procedure #37 ##string-ref>
                                                           ('#<procedure #17 symbol->string>
                                                            e)
                                                           0)
                                                          #\:))))
                                              (meroon-keyword-eq?
                                               ('#<procedure #6 ##car> options)
                                               keyword))
                                         (skip2next-keyword
                                          ('#<procedure #7 ##cdr> options))
                                         ('#<procedure #10 ##cons>
                                          ('#<procedure #6 ##car> options)
                                          (skip keyword
                                                ('#<procedure #7 ##cdr>
                                                 options))))
                                     '()))))
                  (skip keyword parms)))))
         (if ('#<procedure #3 ##eq?> form meroon-option-not-there)
             (k ('#<procedure #34 ##list>) other-parms)
             (k ('#<procedure #34 ##list> 1 form) other-parms))))))
 'Mono-Field)

(register-method
 'find-duplication
 '((f Poly-Field) parms k)
 '(1 . 1)
 (lambda (#:g1028 #:g1029 #:g1030)
   (lambda (f parms k)
     (let ((content (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                      (let ((kw+values
                             (find-option-plus-values keyword parms)))
                        (if ('#<procedure #4 ##pair?> kw+values)
                            ('#<procedure #7 ##cdr> kw+values)
                            meroon-option-not-there)))))
       (let ((parms (let ((keyword ('#<procedure #32 ##vector-ref> f 1)))
                      (letrec ((skip (lambda (keyword options)
                                       (if ('#<procedure #4 ##pair?> options)
                                           (if (and (let ((e ('#<procedure #6 ##car>
                                                              options)))
                                                      (or ('#<procedure #59 ##keyword?>
                                                           e)
                                                          (and ('#<procedure #16 ##symbol?>
                                                                e)
                                                               ('#<procedure #60 ##char=?>
                                                                ('#<procedure #37 ##string-ref>
                                                                 ('#<procedure #17 symbol->string>
                                                                  e)
                                                                 0)
                                                                #\:))))
                                                    (meroon-keyword-eq?
                                                     ('#<procedure #6 ##car>
                                                      options)
                                                     keyword))
                                               (skip2next-keyword
                                                ('#<procedure #7 ##cdr>
                                                 options))
                                               ('#<procedure #10 ##cons>
                                                ('#<procedure #6 ##car>
                                                 options)
                                                (skip keyword
                                                      ('#<procedure #7 ##cdr>
                                                       options))))
                                           '()))))
                        (skip keyword parms)))))
         (if ('#<procedure #3 ##eq?> content meroon-option-not-there)
             (let ((kw ('#<procedure #34 ##list>
                        ('#<procedure #32 ##vector-ref> f 1)
                        '-length)))
               (let ((size (find-option-single-value
                            kw
                            parms
                            option-not-there)))
                 (if ('#<procedure #3 ##eq?> size meroon-option-not-there)
                     (k ('#<procedure #34 ##list>) parms)
                     (report-meroon-error
                      'Syntax
                      'duplicate
                      "No :kw-length keyword possible in a duplicate form"
                      ('#<procedure #32 ##vector-ref> f 1)))))
             (k ('#<procedure #10 ##cons>
                 ('#<procedure #23 length> content)
                 content)
                parms))))))
 'Poly-Field)

(define find-instantiation-from
  (let ((#:g1032 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.710
           ('#<procedure #63 ##set-box!>
            #:g1032
            (register-Generic-1
             '(1 . 1)
             'find-instantiation-from
             (lambda (f parms k) (find-duplication f parms k))
             '((f Field) parms k)
             'Field))))
      (lambda (f parms k)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1032) f)
         f
         parms
         k)))))

(define fill-other-fields-from-instance!
  (lambda (o original)
    (let ((original-class
           ('#<procedure #32 ##vector-ref>
            *classes*
            ('#<procedure #32 ##vector-ref> original 0))))
      (let ((begin-temp.712
             (let ((temp.1149
                    (let ((class ('#<procedure #32 ##vector-ref>
                                  *classes*
                                  ('#<procedure #32 ##vector-ref> o 0))))
                      ('#<procedure #32 ##vector-ref> class 3))))
               (letrec ((loop2.1150
                         (lambda (o original original-class lst2.1151)
                           (if ('#<procedure #4 ##pair?> lst2.1151)
                               (let ((x.1152 (let ((field ('#<procedure #6 ##car>
                                                           lst2.1151)))
                                               (let ((begin-temp.711
                                                      (if (let ((class2 (let ((i ('#<procedure #32 ##vector-ref>
                                                                                  field
                                                                                  3)))
                                                                          ('#<procedure #32 ##vector-ref>
                                                                           *classes*
                                                                           i))))
                                                            (let ((depth2 ('#<procedure #32 ##vector-ref>
                                                                           class2
                                                                           4))
                                                                  (cn2 ('#<procedure #32 ##vector-ref>
                                                                        class2
                                                                        2)))
                                                              (and ('#<procedure #36 ##fx>=>
                                                                    ('#<procedure #32 ##vector-ref>
                                                                     original-class
                                                                     4)
                                                                    depth2)
                                                                   ('#<procedure #50 ##fx=>
                                                                    cn2
                                                                    (if (and ('#<procedure #36 ##fx>=>
                                                                              depth2
                                                                              0)
                                                                             ('#<procedure #49 ##fx<=>
                                                                              depth2
                                                                              ('#<procedure #32 ##vector-ref>
                                                                               original-class
                                                                               4)))
                                                                        (let ((offset ('#<procedure #21 ##fx+>
                                                                                       10
                                                                                       ('#<procedure #21 ##fx+>
                                                                                        1
                                                                                        depth2))))
                                                                          (let ((i ('#<procedure #21 ##fx+>
                                                                                    1
                                                                                    offset)))
                                                                            ('#<procedure #32 ##vector-ref>
                                                                             original-class
                                                                             i)))
                                                                        (report-bad-index
                                                                         'super
                                                                         original-class
                                                                         depth2))))))
                                                          (fill-uninitialized-field-from-instance!
                                                           o
                                                           field
                                                           original)
                                                          #!void)))
                                                 (fill-uninitialized-field!
                                                  o
                                                  field)))))
                                 (let ((lst2.1151
                                        ('#<procedure #7 ##cdr> lst2.1151)))
                                   (if ('#<procedure #4 ##pair?> lst2.1151)
                                       (let ((x.1152 (let ((field ('#<procedure #6 ##car>
                                                                   lst2.1151)))
                                                       (let ((begin-temp.711
                                                              (if (let ((class2 (let ((i ('#<procedure #32 ##vector-ref>
                                                                                          field
                                                                                          3)))
                                                                                  ('#<procedure #32 ##vector-ref>
                                                                                   *classes*
                                                                                   i))))
                                                                    (let ((depth2 ('#<procedure #32 ##vector-ref>
                                                                                   class2
                                                                                   4))
                                                                          (cn2 ('#<procedure #32 ##vector-ref>
                                                                                class2
                                                                                2)))
                                                                      (and ('#<procedure #36 ##fx>=>
                                                                            ('#<procedure #32 ##vector-ref>
                                                                             original-class
                                                                             4)
                                                                            depth2)
                                                                           ('#<procedure #50 ##fx=>
                                                                            cn2
                                                                            (if (and ('#<procedure #36 ##fx>=>
                                                                                      depth2
                                                                                      0)
                                                                                     ('#<procedure #49 ##fx<=>
                                                                                      depth2
                                                                                      ('#<procedure #32 ##vector-ref>
                                                                                       original-class
                                                                                       4)))
                                                                                (let ((offset ('#<procedure #21 ##fx+>
                                                                                               10
                                                                                               ('#<procedure #21 ##fx+>
                                                                                                1
                                                                                                depth2))))
                                                                                  (let ((i ('#<procedure #21 ##fx+>
                                                                                            1
                                                                                            offset)))
                                                                                    ('#<procedure #32 ##vector-ref>
                                                                                     original-class
                                                                                     i)))
                                                                                (report-bad-index
                                                                                 'super
                                                                                 original-class
                                                                                 depth2))))))
                                                                  (fill-uninitialized-field-from-instance!
                                                                   o
                                                                   field
                                                                   original)
                                                                  #!void)))
                                                         (fill-uninitialized-field!
                                                          o
                                                          field)))))
                                         (loop2.1150
                                          o
                                          original
                                          original-class
                                          ('#<procedure #7 ##cdr> lst2.1151)))
                                       #!void)))
                               #!void))))
                 (loop2.1150 o original original-class temp.1149)))))
        o))))

(define fill-uninitialized-field-from-instance!
  (let ((#:g1034 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.713
           ('#<procedure #63 ##set-box!>
            #:g1034
            (register-Generic-1
             '(1 . 1)
             'fill-uninitialized-field-from-instance!
             meroon-uninitialized
             '(o (field Field) original)
             'Field))))
      (lambda (o field original)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1034) field)
         o
         field
         original)))))

(register-method
 'fill-uninitialized-field-from-instance!
 '(o (field Mono-Field) original)
 '(1 . 1)
 (lambda (#:g1036 #:g1037 #:g1038)
   (lambda (o field original)
     (let ((offset (compute-value-offset o field)))
       (if (let ((value (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                          ('#<procedure #32 ##vector-ref> o i))))
             ('#<procedure #3 ##eq?> meroon-uninitialized value))
           (let ((orgoffset (compute-value-offset original field)))
             (let ((value (let ((i ('#<procedure #21 ##fx+> 1 orgoffset)))
                            ('#<procedure #32 ##vector-ref> original i))))
               (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                 ('#<procedure #33 ##vector-set!> o i value))))
           #!void))))
 'Mono-Field)

(register-method
 'fill-uninitialized-field-from-instance!
 '(o (field Poly-Field) original)
 '(1 . 1)
 (lambda (#:g1040 #:g1041 #:g1042)
   (lambda (o field original)
     (let ((len ('#<procedure #57 ##fxmin>
                 (field-length o field)
                 (field-length original field))))
       (letrec ((do-temp.714
                 (lambda (o field original len i)
                   (if ('#<procedure #36 ##fx>=> i len)
                       o
                       (let ((begin-temp.715
                              (if (field-defined? o field i)
                                  #!void
                                  (let ((orgoffset
                                         (compute-value-offset
                                          original
                                          field
                                          i))
                                        (offset (compute-value-offset
                                                 o
                                                 field
                                                 i)))
                                    (let ((value (let ((i ('#<procedure #21 ##fx+>
                                                           1
                                                           orgoffset)))
                                                   ('#<procedure #32 ##vector-ref>
                                                    original
                                                    i))))
                                      (let ((i ('#<procedure #21 ##fx+>
                                                1
                                                offset)))
                                        ('#<procedure #33 ##vector-set!>
                                         o
                                         i
                                         value)))))))
                         (do-temp.714
                          o
                          field
                          original
                          len
                          ('#<procedure #21 ##fx+> i 1)))))))
         (do-temp.714 o field original len 0)))))
 'Poly-Field)

(define Inlinable-Class-class
  (initialize!
   (fill-other-fields!
    (let ((own-fields ('#<procedure #34 ##list>))
          (class ((Class-allocator MeroonV2-Class-class) 9)))
      (let ((begin-temp.32 (check-revision '(1 . 1))))
        (let ((begin-temp.31
               (if (field-defined? class 'name)
                   #!void
                   ('#<procedure #33 ##vector-set!>
                    class
                    1
                    'Inlinable-Class))))
          (let ((begin-temp.30
                 (if (field-defined? class 'super-number)
                     #!void
                     (let ((scn (Class-number Handy-Class-class)))
                       ('#<procedure #33 ##vector-set!> class 5 scn)))))
            (Class-add-subclass class Handy-Class-class own-fields))))))))

#t

(define Inlinable-Class-name
  (Mono-Field-create-careful-reader Inlinable-Class-class 'name))

(define Inlinable-Class-number
  (Mono-Field-create-careful-reader Inlinable-Class-class 'number))

(define Inlinable-Class-fields
  (Mono-Field-create-careful-reader Inlinable-Class-class 'fields))

(define Inlinable-Class-depth
  (Mono-Field-create-careful-reader Inlinable-Class-class 'depth))

(define Inlinable-Class-super-number
  (Mono-Field-create-careful-reader Inlinable-Class-class 'super-number))

(define Inlinable-Class-subclass-numbers
  (Mono-Field-create-careful-reader Inlinable-Class-class 'subclass-numbers))

(define set-Inlinable-Class-subclass-numbers!
  (Mono-Field-create-careful-writer Inlinable-Class-class 'subclass-numbers))

(define Inlinable-Class-next
  (Mono-Field-create-careful-reader Inlinable-Class-class 'next))

(define set-Inlinable-Class-next!
  (Mono-Field-create-careful-writer Inlinable-Class-class 'next))

(define Inlinable-Class-allocator
  (Mono-Field-create-careful-reader Inlinable-Class-class 'allocator))

(define Inlinable-Class-immutable?
  (Mono-Field-create-careful-reader Inlinable-Class-class 'immutable?))

(define Inlinable-Class-views
  (Mono-Field-create-careful-reader Inlinable-Class-class 'views))

(define Inlinable-Class-suprel-length
  (Poly-Field-create-careful-lengther Inlinable-Class-class 'suprel))

(define Inlinable-Class-suprel
  (Poly-Field-create-careful-reader Inlinable-Class-class 'suprel))

(define Inlinable-Class?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Inlinable-Class-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Inlinable-Class-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define make-Inlinable-Class (make-maker Inlinable-Class-class))

(define allocate-Inlinable-Class (Class-allocator Inlinable-Class-class))

(define ->Inlinable-Class
  (let ((#:g1044 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.716
           ('#<procedure #63 ##set-box!>
            #:g1044
            (register-Generic-1
             '(1 . 1)
             '->Inlinable-Class
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1044) o)
         o)))))

(register-method
 '->Inlinable-Class
 '((o Inlinable-Class))
 '(1 . 1)
 (lambda (#:g1046 #:g1047 #:g1048) (lambda (o) o))
 'Inlinable-Class)

'Inlinable-Class

(define Inlinable-Mono-Field-class
  (initialize!
   (fill-other-fields!
    (let ((own-fields ('#<procedure #34 ##list>))
          (class ((Class-allocator MeroonV2-Class-class) 9)))
      (let ((begin-temp.32 (check-revision '(1 . 1))))
        (let ((begin-temp.31
               (if (field-defined? class 'name)
                   #!void
                   ('#<procedure #33 ##vector-set!>
                    class
                    1
                    'Inlinable-Mono-Field))))
          (let ((begin-temp.30
                 (if (field-defined? class 'super-number)
                     #!void
                     (let ((scn (Class-number Mono-Field-class)))
                       ('#<procedure #33 ##vector-set!> class 5 scn)))))
            (Class-add-subclass class Mono-Field-class own-fields))))))))

#t

(define Inlinable-Mono-Field-name
  (Mono-Field-create-careful-reader Inlinable-Mono-Field-class 'name))

(define Inlinable-Mono-Field-immutable?
  (Mono-Field-create-careful-reader Inlinable-Mono-Field-class 'immutable?))

(define Inlinable-Mono-Field-class-number
  (Mono-Field-create-careful-reader Inlinable-Mono-Field-class 'class-number))

(define set-Inlinable-Mono-Field-class-number!
  (Mono-Field-create-careful-writer Inlinable-Mono-Field-class 'class-number))

(define Inlinable-Mono-Field-initialized?
  (Mono-Field-create-careful-reader Inlinable-Mono-Field-class 'initialized?))

(define Inlinable-Mono-Field-initializer
  (Mono-Field-create-careful-reader Inlinable-Mono-Field-class 'initializer))

(define set-Inlinable-Mono-Field-initializer!
  (Mono-Field-create-careful-writer Inlinable-Mono-Field-class 'initializer))

(define Inlinable-Mono-Field-path-length
  (Poly-Field-create-careful-lengther Inlinable-Mono-Field-class 'path))

(define Inlinable-Mono-Field-path
  (Poly-Field-create-careful-reader Inlinable-Mono-Field-class 'path))

(define Inlinable-Mono-Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Inlinable-Mono-Field-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Inlinable-Mono-Field-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define make-Inlinable-Mono-Field (make-maker Inlinable-Mono-Field-class))

(define allocate-Inlinable-Mono-Field
  (Class-allocator Inlinable-Mono-Field-class))

(define ->Inlinable-Mono-Field
  (let ((#:g1050 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.717
           ('#<procedure #63 ##set-box!>
            #:g1050
            (register-Generic-1
             '(1 . 1)
             '->Inlinable-Mono-Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1050) o)
         o)))))

(register-method
 '->Inlinable-Mono-Field
 '((o Inlinable-Mono-Field))
 '(1 . 1)
 (lambda (#:g1052 #:g1053 #:g1054) (lambda (o) o))
 'Inlinable-Mono-Field)

'Inlinable-Mono-Field

(define Inlinable-Poly-Field-class
  (initialize!
   (fill-other-fields!
    (let ((own-fields ('#<procedure #34 ##list>))
          (class ((Class-allocator MeroonV2-Class-class) 9)))
      (let ((begin-temp.32 (check-revision '(1 . 1))))
        (let ((begin-temp.31
               (if (field-defined? class 'name)
                   #!void
                   ('#<procedure #33 ##vector-set!>
                    class
                    1
                    'Inlinable-Poly-Field))))
          (let ((begin-temp.30
                 (if (field-defined? class 'super-number)
                     #!void
                     (let ((scn (Class-number Poly-Field-class)))
                       ('#<procedure #33 ##vector-set!> class 5 scn)))))
            (Class-add-subclass class Poly-Field-class own-fields))))))))

#t

(define Inlinable-Poly-Field-name
  (Mono-Field-create-careful-reader Inlinable-Poly-Field-class 'name))

(define Inlinable-Poly-Field-immutable?
  (Mono-Field-create-careful-reader Inlinable-Poly-Field-class 'immutable?))

(define Inlinable-Poly-Field-class-number
  (Mono-Field-create-careful-reader Inlinable-Poly-Field-class 'class-number))

(define set-Inlinable-Poly-Field-class-number!
  (Mono-Field-create-careful-writer Inlinable-Poly-Field-class 'class-number))

(define Inlinable-Poly-Field-initialized?
  (Mono-Field-create-careful-reader Inlinable-Poly-Field-class 'initialized?))

(define Inlinable-Poly-Field-initializer
  (Mono-Field-create-careful-reader Inlinable-Poly-Field-class 'initializer))

(define set-Inlinable-Poly-Field-initializer!
  (Mono-Field-create-careful-writer Inlinable-Poly-Field-class 'initializer))

(define Inlinable-Poly-Field-path-length
  (Poly-Field-create-careful-lengther Inlinable-Poly-Field-class 'path))

(define Inlinable-Poly-Field-path
  (Poly-Field-create-careful-reader Inlinable-Poly-Field-class 'path))

(define Inlinable-Poly-Field?
  (lambda (o)
    (and ('#<procedure #28 ##meroon?> o)
         (let ((class1 ('#<procedure #32 ##vector-ref>
                        *classes*
                        ('#<procedure #32 ##vector-ref> o 0))))
           (let ((depth2 ('#<procedure #32 ##vector-ref>
                          Inlinable-Poly-Field-class
                          4))
                 (cn2 ('#<procedure #32 ##vector-ref>
                       Inlinable-Poly-Field-class
                       2)))
             (and ('#<procedure #36 ##fx>=>
                   ('#<procedure #32 ##vector-ref> class1 4)
                   depth2)
                  ('#<procedure #50 ##fx=>
                   cn2
                   (if (and ('#<procedure #36 ##fx>=> depth2 0)
                            ('#<procedure #49 ##fx<=>
                             depth2
                             ('#<procedure #32 ##vector-ref> class1 4)))
                       (let ((offset ('#<procedure #21 ##fx+>
                                      10
                                      ('#<procedure #21 ##fx+> 1 depth2))))
                         (let ((i ('#<procedure #21 ##fx+> 1 offset)))
                           ('#<procedure #32 ##vector-ref> class1 i)))
                       (report-bad-index 'super class1 depth2)))))))))

(define make-Inlinable-Poly-Field (make-maker Inlinable-Poly-Field-class))

(define allocate-Inlinable-Poly-Field
  (Class-allocator Inlinable-Poly-Field-class))

(define ->Inlinable-Poly-Field
  (let ((#:g1056 ('#<procedure #61 ##box> 'wait)))
    (let ((begin-temp.718
           ('#<procedure #63 ##set-box!>
            #:g1056
            (register-Generic-1
             '(1 . 1)
             '->Inlinable-Poly-Field
             meroon-uninitialized
             '((o))
             #f))))
      (lambda (o)
        ((careless-determine-method1 ('#<procedure #62 ##unbox> #:g1056) o)
         o)))))

(register-method
 '->Inlinable-Poly-Field
 '((o Inlinable-Poly-Field))
 '(1 . 1)
 (lambda (#:g1058 #:g1059 #:g1060) (lambda (o) o))
 'Inlinable-Poly-Field)

'Inlinable-Poly-Field

(set! *standard-class-metaclass-name* 'Inlinable-Class)

(set! *standard-mono-field-metaclass-name* 'Inlinable-Mono-Field)

(set! *standard-poly-field-metaclass-name* 'Inlinable-Poly-Field)

(define generate-reader-name
  (lambda (field class)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate classname '- fieldname))))

(define generate-writer-name
  (lambda (field class)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate classname '- fieldname '- 'set!))))

(define generate-lengther-name
  (lambda (field class)
    (let ((fieldname ('#<procedure #32 ##vector-ref> field 1))
          (classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate classname '- fieldname '- 'length))))

(define generate-class-name
  (lambda (class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate classname '- 'class))))

(define generate-predicate-name
  (lambda (class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate classname "?"))))

(define generate-allocator-name
  (lambda (class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate 'allocate- classname))))

(define generate-maker-name
  (lambda (class)
    (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
      (symbol-concatenate 'make- classname))))

(register-method
 'generate-accessors
 '((class Inlinable-Class) class-options)
 '(1 . 1)
 (lambda (#:g1062 #:g1063 #:g1064)
   (lambda (class class-options)
     ('#<procedure #43 ##quasi-cons>
      'begin
      ('#<procedure #43 ##quasi-cons>
       #t
       (let ((temp.1154 (Class-fields class)))
         (letrec ((loop2.1155
                   (lambda (class lst2.1156)
                     (if ('#<procedure #4 ##pair?> lst2.1156)
                         (let ((x.1157 (let ((field ('#<procedure #6 ##car>
                                                     lst2.1156)))
                                         (Field-generate-Handy-accessors
                                          field
                                          class))))
                           ('#<procedure #10 ##cons>
                            x.1157
                            (loop2.1155
                             class
                             ('#<procedure #7 ##cdr> lst2.1156))))
                         '()))))
           (loop2.1155 class temp.1154)))))))
 'Inlinable-Class)

(register-method
 'Field-generate-Handy-accessors
 '((field Inlinable-Mono-Field) class)
 '(1 . 1)
 (lambda (#:g1066 #:g1067 #:g1068)
   (lambda (field class)
     (let ((class-variable (generate-class-name class)))
       ('#<procedure #43 ##quasi-cons>
        'begin
        ('#<procedure #43 ##quasi-cons>
         ('#<procedure #44 ##quasi-list>
          'meroon-define
          (generate-reader-name field class)
          (generate-fast-careful-reader field class-variable))
         (if (Field-immutable? field)
             '()
             ('#<procedure #44 ##quasi-list>
              ('#<procedure #44 ##quasi-list>
               'meroon-define
               (generate-writer-name field class)
               (generate-fast-careful-writer field class-variable)))))))))
 'Inlinable-Mono-Field)

(register-method
 'Field-generate-Handy-accessors
 '((field Inlinable-Poly-Field) class)
 '(1 . 1)
 (lambda (#:g1070 #:g1071 #:g1072)
   (lambda (field class)
     (let ((class-variable (generate-class-name class)))
       ('#<procedure #43 ##quasi-cons>
        'begin
        ('#<procedure #43 ##quasi-cons>
         ('#<procedure #44 ##quasi-list>
          'meroon-define
          (generate-lengther-name field class)
          (generate-fast-careful-lengther field class-variable))
         ('#<procedure #43 ##quasi-cons>
          ('#<procedure #44 ##quasi-list>
           'meroon-define
           (generate-reader-name field class)
           (generate-fast-careful-reader field class-variable))
          (if (Field-immutable? field)
              '()
              ('#<procedure #44 ##quasi-list>
               ('#<procedure #44 ##quasi-list>
                'meroon-define
                (generate-writer-name field class)
                (generate-fast-careful-writer field class-variable))))))))))
 'Inlinable-Poly-Field)

(register-method
 'generate-predicate
 '((class Inlinable-Class) class-options)
 '(1 . 1)
 (lambda (#:g1074 #:g1075 #:g1076)
   (lambda (class class-options)
     (let ((o (gensym)))
       ('#<procedure #44 ##quasi-list>
        'meroon-define
        (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
          (symbol-concatenate classname "?"))
        ('#<procedure #44 ##quasi-list>
         'let
         '()
         '(declare (standard-bindings) (extended-bindings) (not safe))
         ('#<procedure #44 ##quasi-list>
          'lambda
          ('#<procedure #44 ##quasi-list> o)
          ('#<procedure #44 ##quasi-list>
           'and
           ('#<procedure #44 ##quasi-list> '##meroon? o)
           ('#<procedure #44 ##quasi-list>
            'careless-subclass?
            ('#<procedure #44 ##quasi-list>
             'vector-ref
             '*classes*
             ('#<procedure #44 ##quasi-list> 'object->class-number o))
            (generate-class-name class)))))))))
 'Inlinable-Class)

(register-method
 'generate-maker
 '((class Inlinable-Class) class-options)
 '(1 . 1)
 (lambda (#:g1078 #:g1079 #:g1080)
   (lambda (class class-options)
     (if (find-option-present? 'virtual class-options)
         ''**no-maker**
         (let ((poly-fields-number
                (let ((fields ('#<procedure #32 ##vector-ref> class 3)))
                  (letrec ((count (lambda (fields)
                                    (if ('#<procedure #4 ##pair?> fields)
                                        (if (Poly-Field?
                                             ('#<procedure #6 ##car> fields))
                                            ('#<procedure #21 ##fx+>
                                             1
                                             (let ((fields ('#<procedure #7 ##cdr>
                                                            fields)))
                                               (if ('#<procedure #4 ##pair?>
                                                    fields)
                                                   (if (Poly-Field?
                                                        ('#<procedure #6 ##car>
                                                         fields))
                                                       ('#<procedure #21 ##fx+>
                                                        1
                                                        (count ('#<procedure #7 ##cdr>
                                                                fields)))
                                                       (count ('#<procedure #7 ##cdr>
                                                               fields)))
                                                   0)))
                                            (count ('#<procedure #7 ##cdr>
                                                    fields)))
                                        0))))
                    (count fields)))))
           ('#<procedure #44 ##quasi-list>
            'meroon-define
            (let ((classname ('#<procedure #32 ##vector-ref> class 1)))
              (symbol-concatenate 'make- classname))
            (if ('#<procedure #50 ##fx=> 0 poly-fields-number)
                (let ((field-names
                       (let ((temp.1159
                              ('#<procedure #32 ##vector-ref> class 3)))
                         (letrec ((loop2.1160
                                   (lambda (lst2.1161)
                                     (if ('#<procedure #4 ##pair?> lst2.1161)
                                         (let ((x.1162 (Field-name
                                                        ('#<procedure #6 ##car>
                                                         lst2.1161))))
                                           ('#<procedure #10 ##cons>
                                            x.1162
                                            (loop2.1160
                                             ('#<procedure #7 ##cdr>
                                              lst2.1161))))
                                         '()))))
                           (loop2.1160 temp.1159)))))
                  ('#<procedure #44 ##quasi-list>
                   'lambda
                   field-names
                   ('#<procedure #44 ##quasi-list>
                    'initialize!
                    ('#<procedure #43 ##quasi-cons>
                     'instance
                     ('#<procedure #43 ##quasi-cons>
                      ('#<procedure #44 ##quasi-list>
                       'careless-Class-number
                       (generate-class-name class))
                      field-names)))))
                ('#<procedure #44 ##quasi-list>
                 'make-maker
                 (generate-class-name class))))))))
 'Inlinable-Class)

