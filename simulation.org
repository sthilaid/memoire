
* Idée

  L'idée d'utiliser des système de simulation afin de contrôler le
  flot d'exécution m'est venue suite au cours de simulation
  stochastiques que j'ai suivi. En effet, en décrivant des simulations
  sous formes d'événements discrets ou de fils d'éxécution (threads),
  on pouvait facilement écrire le comportement de chaque individu, et
  ce de manière modulaire.

* Simulation à événements discrets

  La première forme de simulation utilisée fut une simulation à
  événements discrets. Le résultat de son utilisation est moyen,
  principalement dû au fait que les objets possèdent la pluspart du
  temps des comportements + ou - infinis, ou dont la durée n'est pas
  pré-déterminée. Par exemple, 

#+BEGIN_SRC scheme
;; Event that moves a mothership and handles its collisions.
(define (create-mothership-event level)
  (define mothership-event
    (synchronized-event-thunk level
      (let ((mothership (level-mothership level)))
        (if mothership
            (let ((collision-occured? (move-object! level mothership)))
              (if (or (not collision-occured?)
                      (is-explosion? collision-occured?)
                      (eq? collision-occured? 'message))
                  (in mothership-update-interval mothership-event)))))))
  mothership-event) 
#+END_SRC

  où l'on constate que l'évènement principal contrôlant les entitées
  de type "mothership" doit se re-schéduler plus tard dans le temps,
  et vérifier que le vaiseau "mothership" est toujours en un seul
  morceau avant de pouvoir continuer. Cela résulte donc en l'écriture
  de code pouvant facilement mener à des bugs (par exemple par l'oubli
  de la vérification de l'existance du "mothership" lors de
  l'exécution du prochain évenement.
  
  Par contre, cette approche semblait fonctionner assez bien pour la
  création d'animation, où justement la durée est décidée à l'avance.

#+BEGIN_SRC scheme
  (define (explode-mothership! level mothership)
    (define expl-obj (make-game-object (gensym 'explosion) ...))
    (object-type-score-value-set! (get-type 'mothership) score-val)
    (level-remove-object! level mothership)
    (level-add-object! level expl-obj)
    (in animation-duration
        (create-explosion-end-event!
         level expl-obj
         (show-points-event level pos score-val end-of-continuation-event)))) 
#+END_SRC

  Come l'illustre cet exemple d'animation d'explosion,

* Simulations par fils d'exécutions

  Une approche qui nous a donc semblée plus naturelle pour la suite
  fut donc de transformer le système de simulation à événements
  discrets pour créer une simulations par "threads". Par contre, un
  des désavantages majeurs de la programmation parallèle est la
  difficulté, généralement reliée aux conditions de courses et aux
  problèmes de synchronisations.

  Ainsi, nous avons décider de créer un système de "threads"
  co-opératifs, changeant de context avec des yields explicites ou
  avec des sleeps. Ainsi, le comportement des objets était beaucoup
  plus compact et facile à écrire et comprendre. De plus, l'écriture
  de quelques macros ont permis de pouvoir composer facilement
  plusieurs animations.

#+BEGIN_SRC scheme
  (define (toto x) x)
#+END_SRC

  
